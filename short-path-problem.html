<!DOCTYPE html><html lang="zh-CN"><head><meta name="viewport" content="width=device-width"/><title>求最短路径的基本算法</title><meta name="robots" content="follow, index"/><meta charSet="UTF-8"/><meta name="keywords" content="Blog, Notion, Tech, Python, Django"/><meta name="description" content="五种求最短路径的基本算法"/><meta property="og:locale" content="zh-CN"/><meta property="og:title" content="求最短路径的基本算法"/><meta property="og:description" content="五种求最短路径的基本算法"/><meta property="og:url" content="https://hhmy27.github.io/"/><meta property="og:image" content="https://og-image-craigary.vercel.app/%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.png?theme=dark&amp;md=1&amp;fontSize=125px&amp;images=https%3A%2F%2Fnobelium.vercel.app%2Flogo-for-dark-bg.svg"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:description" content="五种求最短路径的基本算法"/><meta name="twitter:title" content="求最短路径的基本算法"/><meta name="twitter:image" content="https://og-image-craigary.vercel.app/%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.png?theme=dark&amp;md=1&amp;fontSize=125px&amp;images=https%3A%2F%2Fnobelium.vercel.app%2Flogo-for-dark-bg.svg"/><meta property="article:published_time"/><meta property="article:author" content="hhmy"/><meta name="next-head-count" content="18"/><link rel="preload" href="/fonts/IBMPlexSansVar-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/IBMPlexSansVar-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><link rel="preload" as="style" data-href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&amp;display=swap"/><link rel="stylesheet" data-href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&amp;display=swap"/><noscript><link rel="stylesheet" data-href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&amp;display=swap"/></noscript><link rel="icon" href="/favicon.svg" type="image/svg+xml"/><link rel="icon" href="/favicon.ico"/><link rel="apple-touch-icon" sizes="192x192" href="/apple-touch-icon.png"/><link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/feed"/><meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)"/><meta name="theme-color" content="#18181B" media="(prefers-color-scheme: dark)"/><link rel="preload" href="/_next/static/css/8e8bd7c50b2739f5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e8bd7c50b2739f5.css" data-n-g=""/><link rel="preload" href="/_next/static/css/6a5815369e10547f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6a5815369e10547f.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-c0a56147c8fcef8f.js" defer=""></script><script src="/_next/static/chunks/main-e557dee8cfeafd6c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f726f15a8a4ffa78.js" defer=""></script><script src="/_next/static/chunks/b5f2ed29-08db60af0c3043ba.js" defer=""></script><script src="/_next/static/chunks/684-63c1a25e215d8bed.js" defer=""></script><script src="/_next/static/chunks/580-c0214944b9e37cce.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-03011df04807c853.js" defer=""></script><script src="/_next/static/JKkGUEINve2JoC-CStCvR/_buildManifest.js" defer=""></script><script src="/_next/static/JKkGUEINve2JoC-CStCvR/_ssgManifest.js" defer=""></script><script src="/_next/static/JKkGUEINve2JoC-CStCvR/_middlewareManifest.js" defer=""></script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"/></head><body class="bg-day dark:bg-night"><div id="__next" data-reactroot=""><div><div class="wrapper font-sans"><div class="observer-element h-4 md:h-12"></div><div class="sticky-nav m-auto w-full h-6 flex flex-row justify-between items-center mb-2 md:mb-12 py-8 bg-opacity-60 max-w-3xl px-4" id="sticky-nav"><div class="flex items-center"><a aria-label="hhmy 的博客" href="/"><div class="h-6"><svg width="28" height="28" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="14" cy="14" r="14" class="fill-current text-black dark:text-white"></circle><circle cx="14" cy="14" r="14" fill="url(#paint0_radial)"></circle><circle cx="8" cy="8" r="1.5" fill="white"></circle><defs><radialGradient id="paint0_radial" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="rotate(45) scale(39.598)"><stop stop-color="#3399FF" stop-opacity="0.9"></stop><stop offset="1" stop-color="#FF3399" stop-opacity="0.6"></stop></radialGradient></defs></svg></div></a><p class="ml-2 font-medium text-day dark:text-night header-name">求最短路径的基本算法</p></div><div class="flex-shrink-0"><ul class="flex flex-row"><li class="block ml-4 text-black dark:text-gray-50 nav"><a href="/about">关于</a></li><li class="block ml-4 text-black dark:text-gray-50 nav"><a href="/search">搜索</a></li></ul></div></div><main class="m-auto flex-grow w-full transition-all max-w-3xl px-4"><article><h1 class="font-bold text-3xl text-black dark:text-white"> <!-- -->求最短路径的基本算法</h1><nav class="flex mt-7 items-start text-gray-500 dark:text-gray-400"><div class="flex mb-4"><a href="https://github.com/hhmy27" class="flex"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2724%27%20height=%2724%27/%3e"/></span><img alt="hhmy" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="rounded-full" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="hhmy" srcSet="https://gravatar.com/avatar/c8089598dc27a7944c95a8ed30867b78?imwidth=32 1x, https://gravatar.com/avatar/c8089598dc27a7944c95a8ed30867b78?imwidth=48 2x" src="https://gravatar.com/avatar/c8089598dc27a7944c95a8ed30867b78?imwidth=48" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="rounded-full" loading="lazy"/></noscript></span><p class="ml-2 md:block">hhmy</p></a><span class="block"> / </span></div><div class="mr-2 mb-4 md:ml-0">2023 年 1 月 29 日</div><div class="flex flex-nowrap max-w-full overflow-x-auto article-tags"><a href="/tag/%E7%AE%97%E6%B3%95"><p class="mr-1 rounded-full px-2 py-1 border leading-none text-sm dark:border-gray-600">算法</p></a></div></nav><div class="-mt-4"><main class="notion light-mode notion-page notion-block-cf1ae05adc0549ed934badf97088cd5c"><div class="notion-viewport"></div><div class="notion-collection-row"><div class="notion-collection-row-body"><div class="notion-collection-row-property"><div class="notion-collection-column-title"><svg viewBox="0 0 14 14" class="notion-collection-column-title-icon"><path d="M10.889 5.5H3.11v1.556h7.778V5.5zm1.555-4.444h-.777V0H10.11v1.056H3.89V0H2.333v1.056h-.777c-.864 0-1.548.7-1.548 1.555L0 12.5c0 .856.692 1.5 1.556 1.5h10.888C13.3 14 14 13.356 14 12.5V2.611c0-.855-.7-1.555-1.556-1.555zm0 11.444H1.556V3.944h10.888V12.5zM8.556 8.611H3.11v1.556h5.445V8.61z"></path></svg><div class="notion-collection-column-title-body">date</div></div><div class="notion-collection-row-value"><span class="notion-property notion-property-date">Jan 29, 2023</span></div></div><div class="notion-collection-row-property"><div class="notion-collection-column-title"><svg viewBox="0 0 14 14" class="notion-collection-column-title-icon"><path d="M7 4.568a.5.5 0 00-.5-.5h-6a.5.5 0 00-.5.5v1.046a.5.5 0 00.5.5h6a.5.5 0 00.5-.5V4.568zM.5 1a.5.5 0 00-.5.5v1.045a.5.5 0 00.5.5h12a.5.5 0 00.5-.5V1.5a.5.5 0 00-.5-.5H.5zM0 8.682a.5.5 0 00.5.5h11a.5.5 0 00.5-.5V7.636a.5.5 0 00-.5-.5H.5a.5.5 0 00-.5.5v1.046zm0 3.068a.5.5 0 00.5.5h9a.5.5 0 00.5-.5v-1.045a.5.5 0 00-.5-.5h-9a.5.5 0 00-.5.5v1.045z"></path></svg><div class="notion-collection-column-title-body">slug</div></div><div class="notion-collection-row-value"><span class="notion-property notion-property-text">short-path-problem</span></div></div><div class="notion-collection-row-property"><div class="notion-collection-column-title"><svg viewBox="0 0 14 14" class="notion-collection-column-title-icon"><path d="M7 13A6 6 0 107 1a6 6 0 000 12zM3.751 5.323A.2.2 0 013.909 5h6.182a.2.2 0 01.158.323L7.158 9.297a.2.2 0 01-.316 0L3.751 5.323z"></path></svg><div class="notion-collection-column-title-body">status</div></div><div class="notion-collection-row-value"><span class="notion-property notion-property-select"><div class="notion-property-select-item notion-item-red">Published</div></span></div></div><div class="notion-collection-row-property"><div class="notion-collection-column-title"><svg viewBox="0 0 14 14" class="notion-collection-column-title-icon"><path d="M4 3a1 1 0 011-1h7a1 1 0 110 2H5a1 1 0 01-1-1zm0 4a1 1 0 011-1h7a1 1 0 110 2H5a1 1 0 01-1-1zm0 4a1 1 0 011-1h7a1 1 0 110 2H5a1 1 0 01-1-1zM2 4a1 1 0 110-2 1 1 0 010 2zm0 4a1 1 0 110-2 1 1 0 010 2zm0 4a1 1 0 110-2 1 1 0 010 2z"></path></svg><div class="notion-collection-column-title-body">tags</div></div><div class="notion-collection-row-value"><span class="notion-property notion-property-multi_select"><div class="notion-property-multi_select-item notion-item-purple">算法</div></span></div></div><div class="notion-collection-row-property"><div class="notion-collection-column-title"><svg viewBox="0 0 14 14" class="notion-collection-column-title-icon"><path d="M7 4.568a.5.5 0 00-.5-.5h-6a.5.5 0 00-.5.5v1.046a.5.5 0 00.5.5h6a.5.5 0 00.5-.5V4.568zM.5 1a.5.5 0 00-.5.5v1.045a.5.5 0 00.5.5h12a.5.5 0 00.5-.5V1.5a.5.5 0 00-.5-.5H.5zM0 8.682a.5.5 0 00.5.5h11a.5.5 0 00.5-.5V7.636a.5.5 0 00-.5-.5H.5a.5.5 0 00-.5.5v1.046zm0 3.068a.5.5 0 00.5.5h9a.5.5 0 00.5-.5v-1.045a.5.5 0 00-.5-.5h-9a.5.5 0 00-.5.5v1.045z"></path></svg><div class="notion-collection-column-title-body">summary</div></div><div class="notion-collection-row-value"><span class="notion-property notion-property-text">五种求最短路径的基本算法</span></div></div><div class="notion-collection-row-property"><div class="notion-collection-column-title"><svg viewBox="0 0 14 14" class="notion-collection-column-title-icon"><path d="M7 13A6 6 0 107 1a6 6 0 000 12zM3.751 5.323A.2.2 0 013.909 5h6.182a.2.2 0 01.158.323L7.158 9.297a.2.2 0 01-.316 0L3.751 5.323z"></path></svg><div class="notion-collection-column-title-body">type</div></div><div class="notion-collection-row-value"><span class="notion-property notion-property-select"><div class="notion-property-select-item notion-item-purple">Post</div></span></div></div></div></div><div class="notion-table-of-contents notion-gray notion-block-c1ea8b8f165640f79e124606bdac87d7"><a href="#195db797754a4d65b26292c2c40b9251" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">简介</span></a><a href="#ca72d4f7c2e44cc68999129aaacb48f7" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">问题分类</span></a><a href="#3771f43d9ca947f394092b934a3c5317" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">图的存储</span></a><a href="#ae9a99dd03274094a30c7f967a6ec4f8" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">邻接矩阵</span></a><a href="#4af6bf982b17443d9b7d858f333ce0ea" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">邻接表</span></a><a href="#9ed4b1e931af48c6912d9bcf41d43fd7" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">单源最短路问题算法</span></a><a href="#454c67cec7214ecf9f61b540bcb88576" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">dijkstra 算法</span></a><a href="#77c270d6028e4f12b79136e62fd59c7d" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">朴素版 dijkstra</span></a><a href="#fe9d2211d4d347acada8419f561785e9" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">堆优化版 dijkstra</span></a><a href="#8de2296e47554ba48f9ca3a7001a7ee8" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">BF 算法</span></a><a href="#e1d3262805a54666a3c883d178e4e158" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">SPFA 算法</span></a><a href="#dfdc1164ec5240018bcee8af894a1d4f" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">负权回路</span></a><a href="#6f05c08985fa4a51b9f8e1b23ab856fe" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">对比 SPFA 和堆优化 dijkstra</span></a><a href="#fb182adbd8d74a2c9abcb9aa44d4e9c8" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">Floyd 算法</span></a><a href="#b9825e52097b495f825051846560a004" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">总结</span></a><a href="#b0eebf59397243c2960a1be9598a6341" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">参考</span></a></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-195db797754a4d65b26292c2c40b9251" data-id="195db797754a4d65b26292c2c40b9251"><span><div id="195db797754a4d65b26292c2c40b9251" class="notion-header-anchor"></div><a class="notion-hash-link" href="#195db797754a4d65b26292c2c40b9251" title="简介"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">简介</span></span></h2><div class="notion-text notion-block-83a4984765d544bfa5f8114e10ec88f0">最短路径问题要求我们给出点与点之间的最短路径，根据问题的分类一共有 5 种解决该类问题的方法。</div><div class="notion-text notion-block-5a0821b2fe8a43a98a4cf70a8d685664">本文将依次介绍每种算法的思想、时间复杂度、适用场景。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-570427a144dd40c28e3dc16b095e4cd0"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe045bf49-c643-450c-84cb-8d7e80f87827%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20230129%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20230129T095041Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D5fc0447ba6764ada16799711df7dd794637d8e79c93367f988fd75bc011ee10b%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=570427a1-44dd-40c2-8e3d-c16b095e4cd0&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-ca72d4f7c2e44cc68999129aaacb48f7" data-id="ca72d4f7c2e44cc68999129aaacb48f7"><span><div id="ca72d4f7c2e44cc68999129aaacb48f7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ca72d4f7c2e44cc68999129aaacb48f7" title="问题分类"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">问题分类</span></span></h2><div class="notion-text notion-block-7e6199289e4c474ead4005e6c3c4362e">最短路问题分为两类：</div><ol start="1" class="notion-list notion-list-numbered notion-block-939c90f4b6ab4520903353d76e46c9d8"><li>单源最短路：求两个点之间的最短路径，一般是 1 到 n 号点</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-40e3e64704db48e9a14fed6fbf29931c"><li>多源汇最短路：求任意两个点之间的最短路径</li></ol><div class="notion-blank notion-block-49925caeef1f4f9ca1cda83133ba9f32"> </div><div class="notion-text notion-block-bba72da2e4b24a7eac88973fc377e261">而单源最短路问题，根据边的不同，又有一些需要注意的地方：</div><ol start="1" class="notion-list notion-list-numbered notion-block-f5eb2c8f48554dc0871019667b3c7f4e"><li>所有边权都是正数：这种情况是最常见的，用 dijkstra 就能求解</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-549c05a473a54e3a822c6122c52fb1cf"><li>边权存在负数：此时 dijkstra 无法求解，只能使用 BF 或者 SPFA 算法求解</li></ol><div class="notion-blank notion-block-40afe4b44bad4ff2b21ee939b8f6288f"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-3771f43d9ca947f394092b934a3c5317" data-id="3771f43d9ca947f394092b934a3c5317"><span><div id="3771f43d9ca947f394092b934a3c5317" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3771f43d9ca947f394092b934a3c5317" title="图的存储"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">图的存储</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-ae9a99dd03274094a30c7f967a6ec4f8" data-id="ae9a99dd03274094a30c7f967a6ec4f8"><span><div id="ae9a99dd03274094a30c7f967a6ec4f8" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ae9a99dd03274094a30c7f967a6ec4f8" title="邻接矩阵"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">邻接矩阵</span></span></h3><div class="notion-text notion-block-a055e8692264412a8b8802c69974fbc3">最简单的存储方式</div><div class="notion-text notion-block-41bb197800cb461fbb048494ead8a01a">N是点数，一般不会太大，用于存储稀疏图</div><pre class="notion-code language-c++"><code class="language-c++">int g<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-4af6bf982b17443d9b7d858f333ce0ea" data-id="4af6bf982b17443d9b7d858f333ce0ea"><span><div id="4af6bf982b17443d9b7d858f333ce0ea" class="notion-header-anchor"></div><a class="notion-hash-link" href="#4af6bf982b17443d9b7d858f333ce0ea" title="邻接表"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">邻接表</span></span></h3><div class="notion-text notion-block-e1490e3d81a9424a876d185ff40e40f6">又称为链式前向星</div><pre class="notion-code language-c++"><code class="language-c++"><span class="token comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。</span>
<span class="token comment">// h[k]存储这个单链表的头节点</span>
<span class="token comment">// e 存储 value， ne 存储 next 指针， w 存储边权</span>
int h<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ne<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> idx<span class="token punctuation">;</span>

<span class="token comment">// 添加一条边 a -> b, 边权为 c</span>
<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">int a<span class="token punctuation">,</span> int b<span class="token punctuation">,</span> int c</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
		e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">,</span> ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">,</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx <span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 遍历点t的所有出边</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		distance <span class="token operator">=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 边权</span>
		<span class="token comment">// 具体操作</span>
<span class="token punctuation">}</span>

<span class="token comment">// 初始化</span>
idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> sizeof h<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-9ed4b1e931af48c6912d9bcf41d43fd7" data-id="9ed4b1e931af48c6912d9bcf41d43fd7"><span><div id="9ed4b1e931af48c6912d9bcf41d43fd7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#9ed4b1e931af48c6912d9bcf41d43fd7" title="单源最短路问题算法"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">单源最短路问题算法</span></span></h2><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-454c67cec7214ecf9f61b540bcb88576" data-id="454c67cec7214ecf9f61b540bcb88576"><span><div id="454c67cec7214ecf9f61b540bcb88576" class="notion-header-anchor"></div><a class="notion-hash-link" href="#454c67cec7214ecf9f61b540bcb88576" title="dijkstra 算法"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">dijkstra 算法</span></span></h2><div class="notion-text notion-block-b8468e1aff914346a49fa98fcc373ea0">该算法的思想是：</div><div class="notion-text notion-block-0e8da0ac62384a069990556e2aab5e7f">维护一个<b>点集</b>，每一轮找到一个离当前点集最近的一个点<code class="notion-inline-code">t</code>，然后将<code class="notion-inline-code">t</code>加入到点集中，同时用这个最近点<b>去尝试更新</b>其它未遍历点的距离，遍历n - 1轮即可得到答案。</div><div class="notion-text notion-block-3e284938c88d47178c54259b5759773e">伪代码：</div><pre class="notion-code language-c++"><code class="language-c++"><span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">// dist[i] 表示从 1 号点出发到点 i 的最短路径</span>
		<span class="token keyword">for</span> 遍历n<span class="token operator">-</span><span class="token number">1</span>轮：
			<span class="token comment">// 寻找最近点 O(n)</span>
			<span class="token keyword">for</span> 遍历所有节点 j<span class="token operator">:</span>
				如果当前点j没有确认最短路，并且距离最小：
					t <span class="token operator">=</span> j，记录最近点是j
			
			<span class="token comment">// O(n)</span>
			<span class="token keyword">for</span> 遍历所有点 j<span class="token operator">:</span>
				<span class="token comment">// 尝试用 t 去更新其它点的距离，g是邻接矩阵</span>
				<span class="token comment">// 如果 1 -> j 的距离大于 1 -> t -> j，更新最短路径为 1 -> t -> j 的距离</span>
				dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> g<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			
			标记 t 点已经确认最短路径
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-3f0cccd6904e463797d55708b68d1a84">经过上面的计算，<code class="notion-inline-code">dist[n]</code> 就是最终答案了。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-77c270d6028e4f12b79136e62fd59c7d" data-id="77c270d6028e4f12b79136e62fd59c7d"><span><div id="77c270d6028e4f12b79136e62fd59c7d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#77c270d6028e4f12b79136e62fd59c7d" title="朴素版 dijkstra"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">朴素版 dijkstra</span></span></h3><div class="notion-text notion-block-9af9674caad144f3a335144e2291fc13">朴素版的 dijkstra 基本上是伪代码的实现，代码如下：</div><pre class="notion-code language-c++"><code class="language-c++">int g<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储每条边</span>
int dist<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储1号点到每个点的最短距离</span>
bool st<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 存储每个点的最短路是否已经确定</span>

<span class="token comment">// 求1号点到n号点的最短路，如果不存在则返回-1 </span>
int <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
		<span class="token comment">// 0x3f3f3f3f 表示无穷大</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> <span class="token number">0x3f</span><span class="token punctuation">,</span> sizeof dist<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dist<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 在还未确定最短路的点中，寻找距离最小的点</span>
        int t <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>int j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">></span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                t <span class="token operator">=</span> j<span class="token punctuation">;</span>
        
        <span class="token comment">// 尝试用t更新其它点</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>int j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> g<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        st<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-ffb0148c8c0744ca96f5154fe31cd4c8">时间复杂度：<span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>，n是点数，m是边数</div><blockquote class="notion-quote notion-block-88380cd524f446408620dfe52a37cc20">有关时间复杂度的计算可以参考这篇文章：<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://blog.csdn.net/michealoven/article/details/114040136"> Dijkstra算法时间复杂度分析</a></blockquote><div class="notion-text notion-block-7c2f8ef2433e4c92923d308d0dbafb9a">适用场景：稠密图，即点少但边多的场景，因此可以用邻接矩阵来存储图</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-fe9d2211d4d347acada8419f561785e9" data-id="fe9d2211d4d347acada8419f561785e9"><span><div id="fe9d2211d4d347acada8419f561785e9" class="notion-header-anchor"></div><a class="notion-hash-link" href="#fe9d2211d4d347acada8419f561785e9" title="堆优化版 dijkstra"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">堆优化版 dijkstra</span></span></h3><div class="notion-text notion-block-8e645975609844979c965a2a554c19b4">在朴素版 dijkstra 中，下面的步骤：</div><pre class="notion-code language-c++"><code class="language-c++">  <span class="token comment">// 在还未确定最短路的点中，寻找距离最小的点</span>
  int t <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>int j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">></span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          t <span class="token operator">=</span> j<span class="token punctuation">;</span></code></pre><div class="notion-text notion-block-5368d39254e84c669464acb5dde07459"><b>寻找距离最小的点，</b>这个操作可以用堆来优化。具体做法是小根堆来存储当前距离最小的点，其它步骤相同</div><pre class="notion-code language-c++"><code class="language-c++">typedef pair<span class="token operator">&lt;</span>int<span class="token punctuation">,</span> int<span class="token operator">></span> <span class="token constant">PII</span><span class="token punctuation">;</span>
int n<span class="token punctuation">;</span>                            <span class="token comment">// 点的数量</span>
int h<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ne<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> idx<span class="token punctuation">;</span> <span class="token comment">// 邻接表存储所有边, w[i] 是距离</span>
int dist<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                      <span class="token comment">// 存储所有点到1号点的距离</span>
bool st<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                       <span class="token comment">// 存储每个点的最短距离是否已确定</span>

int <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> <span class="token number">0x3f</span><span class="token punctuation">,</span> sizeof dist<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dist<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    priority_queue<span class="token operator">&lt;</span><span class="token constant">PII</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token constant">PII</span><span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span><span class="token constant">PII</span><span class="token operator">>></span> heap<span class="token punctuation">;</span>
    heap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// first存储距离，second存储节点编号</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>heap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
				<span class="token comment">// 弹出距离最近的点，优化它的出边</span>
        auto t <span class="token operator">=</span> heap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        heap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        int ver <span class="token operator">=</span> t<span class="token punctuation">.</span>second<span class="token punctuation">,</span> distance <span class="token operator">=</span> t<span class="token punctuation">.</span>first<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">[</span>ver<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>

        st<span class="token punctuation">[</span>ver<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				<span class="token comment">// 遍历t的所有出边</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> h<span class="token punctuation">[</span>ver<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            int j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> distance <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> distance <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                heap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> j<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 如果能优化，则放入点</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-873667bd7f0444a5a12adb98e9eb05e9">需要注意的是，堆里面允许冗余点存在，比如{4, 3}，{2, 3}，{7, 3}这几个组合是允许同时存在的。</div><div class="notion-text notion-block-ad31d36198cc4ffeb84f82a19c9c2089"><code class="notion-inline-code">st</code> 的含义是点是否被处理过，因此只有在从堆中弹出的时候才标记 <code class="notion-inline-code">st[t] = true</code> </div><div class="notion-text notion-block-d92dba5b71644d6988f561a10025e55e">时间复杂度：<span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span></div><div class="notion-text notion-block-305ca289b4ac44238cb341a5cc7ed7f8">适用场景：稀疏图，点多边少</div><hr class="notion-hr notion-block-41938f35dc0646d990c77f0a12521f06"/><div class="notion-text notion-block-fe3602f2aa034822aad5e5016d22a911">一旦图中存在负权边，dijkstra 算法就失效了，只能使用 BF 算法或者 SPFA 算法求解</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-8de2296e47554ba48f9ca3a7001a7ee8" data-id="8de2296e47554ba48f9ca3a7001a7ee8"><span><div id="8de2296e47554ba48f9ca3a7001a7ee8" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8de2296e47554ba48f9ca3a7001a7ee8" title="BF 算法"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">BF 算法</span></span></h2><div class="notion-text notion-block-45900b25aa684ba2ad9916b43fe34d0c">思想：</div><div class="notion-text notion-block-5ff1add47bc64c0b9dd3ed2805ba5cef">迭代 n 次，每次遍历所有边，尝试去更新dist数组。这样得到的dist数组就是最终结果了</div><div class="notion-text notion-block-7249a3eed7c44806aa840c2a1d395d4a">伪代码：</div><pre class="notion-code language-c++"><code class="language-c++"><span class="token keyword">for</span> <span class="token literal-property property">迭代n次</span><span class="token operator">:</span>
	<span class="token keyword">for</span> 所有边 a <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">,</span> 边权 w<span class="token operator">:</span>
		dist<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">,</span> dist<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 松弛操作</span></code></pre><div class="notion-text notion-block-fc56b7e6100a41bca8fe5ee64c59ef26">实现：</div><pre class="notion-code language-c++"><code class="language-c++">int n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>
int dist<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 边，a表示出点，b表示入点，w表示边的权重</span>
struct Edge
<span class="token punctuation">{</span>
    int a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> w<span class="token punctuation">;</span>
<span class="token punctuation">}</span> edges<span class="token punctuation">[</span><span class="token constant">M</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

int <span class="token function">bellman_ford</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> <span class="token number">0x3f</span><span class="token punctuation">,</span> sizeof dist<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dist<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，</span>
    <span class="token comment">// 由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>int j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            int a <span class="token operator">=</span> edges<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> b <span class="token operator">=</span> edges<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">,</span> w <span class="token operator">=</span> edges<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">></span> dist<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span>
                dist<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0x3f3f3f3f</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-59a84b8ec45d4775a3e2ff29f05e842f">时间复杂度： <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span></div><div class="notion-text notion-block-4e335f48d4b049e399d1743b4c8165c0">适用场景：图中存在负权边</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-e1d3262805a54666a3c883d178e4e158" data-id="e1d3262805a54666a3c883d178e4e158"><span><div id="e1d3262805a54666a3c883d178e4e158" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e1d3262805a54666a3c883d178e4e158" title="SPFA 算法"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">SPFA 算法</span></span></h2><div class="notion-text notion-block-561c0d291bdc414c9c7e81994356c387">从 BF 算法中我们可以观察这个条件：</div><pre class="notion-code language-c++"><code class="language-c++"><span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">></span> dist<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span>
    dist<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">;</span></code></pre><div class="notion-text notion-block-b0ec13cd0b304c9ea29bbb4e186cce82">何时才能更新 dist[b] 呢？当然是只有 dist[a] 发生变动的时候才能更新了。</div><div class="notion-text notion-block-5ccbdfff5f1f4bb0a3ea7a13886abfa2">SPFA 的思想也很简单，当一个点被更新的时候，才去更新它的所有出边。</div><div class="notion-text notion-block-78c664a536b847e2a56577104cf28f04">这样就避免每次都遍历所有边尝试去更新最短距离了。</div><div class="notion-text notion-block-e40b098ac2414ec3ab0e8553fa96004d">代码：</div><pre class="notion-code language-c++"><code class="language-c++">int n<span class="token punctuation">;</span>                            <span class="token comment">// 总点数</span>
int h<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ne<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> idx<span class="token punctuation">;</span> <span class="token comment">// 邻接表存储所有边</span>
int dist<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                      <span class="token comment">// 存储每个点到1号点的最短距离</span>
bool st<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                       <span class="token comment">// 存储每个点是否在队列中</span>

int <span class="token function">spfa</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> <span class="token number">0x3f</span><span class="token punctuation">,</span> sizeof dist<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dist<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    queue<span class="token operator">&lt;</span>int<span class="token operator">></span> q<span class="token punctuation">;</span>
    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    st<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        auto t <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        st<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            int j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="notion-text notion-block-481069a89264486fa0b0c1eb86b1ae97">需要注意的地方是：<code class="notion-inline-code">st</code> 记录的是点是否存在队列中，所以在入队的时候要标记<code class="notion-inline-code">st[j] = true</code> ，而出队的时候要修改<code class="notion-inline-code">st[j] = false</code></div><div class="notion-text notion-block-ec140ca2c31343ac802d35ca67157e80">时间复杂度：一般 <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>，最差 <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span></div><div class="notion-text notion-block-857fb32786bb4f88ac51409122aae584">适用场景：存在负权边</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-dfdc1164ec5240018bcee8af894a1d4f" data-id="dfdc1164ec5240018bcee8af894a1d4f"><span><div id="dfdc1164ec5240018bcee8af894a1d4f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#dfdc1164ec5240018bcee8af894a1d4f" title="负权回路"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">负权回路</span></span></h2><div class="notion-text notion-block-f3168a7ec7894cce9c4caded2c9fd01d">首先介绍一个概念，叫做负权回路，如下图所示</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-35456df632194f62a1dc14bf4c45eea8"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F844bb17e-a37b-4d92-b968-91b56af5972a%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20230129%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20230129T095041Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Df86bdd02b405a7c487607204912c6f398ec59d020f03e928ecd4622795b4b43d%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=35456df6-3219-4f62-a1dc-14bf4c45eea8&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-6207ea19b45242d396b35c60607c4c45">图中2，3，4组成了一个负权回路。</div><div class="notion-text notion-block-b10bad308a584162bf084ff2c9f08b61">当负权回路处于源点和目标点的路径上时，必然无法求出最短路径。因为每经过一次负权回路，边权就-1。</div><div class="notion-text notion-block-10169151a2884e989c4ecd3985e1bc57">对比BF算法和SPFA算法我们可以发现，上面这种情况发生的时候，BF算法迭代n次就停止，不会发生死循环，而SPFA会发生死循环。</div><div class="notion-text notion-block-9a12e3c17d714ea2968dfe5bac863641">对于这种情况，SPFA可以做一些改进，检测出是否有上面情况的存在。</div><pre class="notion-code language-c++"><code class="language-c++">int n<span class="token punctuation">;</span>                            <span class="token comment">// 总点数</span>
int h<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ne<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> idx<span class="token punctuation">;</span> <span class="token comment">// 邻接表存储所有边</span>
int dist<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span>
bool st<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                       <span class="token comment">// 存储每个点是否在队列中</span>

<span class="token comment">// 如果存在负环，则返回true，否则返回false。</span>
bool <span class="token function">spfa</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 不需要初始化dist数组</span>
    <span class="token comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点</span>
    <span class="token comment">// 由抽屉原理一定有两个点相同，所以存在环。</span>

    queue<span class="token operator">&lt;</span>int<span class="token operator">></span> q<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        auto t <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        st<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            int j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                cnt<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> n<span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-9951eca852e042579a3e28002e567712">具体做法是，使用<code class="notion-inline-code">cnt</code>数组来记录经过的点数，如果到某个点经过点数≥n，那么根据抽屉原理，此时有n+1个点，但是最多图中有n个点，所以必然存在2个点相同，因此图中存在负权回路。</div><hr class="notion-hr notion-block-b427db4be4fd46c7bd0c50d503ef6530"/><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-6f05c08985fa4a51b9f8e1b23ab856fe" data-id="6f05c08985fa4a51b9f8e1b23ab856fe"><span><div id="6f05c08985fa4a51b9f8e1b23ab856fe" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6f05c08985fa4a51b9f8e1b23ab856fe" title="对比 SPFA 和堆优化 dijkstra"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">对比 SPFA 和堆优化 dijkstra</span></span></h2><div class="notion-row notion-block-ce956d67d1094d6ea96e36e2e2b5016a"><div class="notion-column notion-block-76f352c5a9684fe794606a7de6555eab" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><div class="notion-text notion-block-a71030891e634d9baf647fa4baad4ff3">堆优化 dijkstra</div><div class="notion-text notion-block-3641bca73f194972afb66950a7584cae">思想：使用小根堆来存储最小距离的点，遍历它的所有出边，尝试优化 dist</div><div class="notion-text notion-block-97f8dba5f02b4c62978f3dc5a8f57852">时间复杂度：O(nlogm)</div><div class="notion-text notion-block-9221a0b40583437c95fff71df620d90c">核心代码：</div><pre class="notion-code language-c++"><code class="language-c++"><span class="token keyword">while</span> <span class="token punctuation">(</span>heap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
		<span class="token comment">// 弹出距离最近的点，优化它的出边</span>
    auto t <span class="token operator">=</span> heap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    heap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    int ver <span class="token operator">=</span> t<span class="token punctuation">.</span>second<span class="token punctuation">,</span> distance <span class="token operator">=</span> t<span class="token punctuation">.</span>first<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">[</span>ver<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>

    st<span class="token punctuation">[</span>ver<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token comment">// 遍历t的所有出边</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> h<span class="token punctuation">[</span>ver<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        int j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> distance <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> distance <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            heap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> j<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 如果能优化，则放入点</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-53ce08cb947f48a6a05649f2bb575aec">st的作用：标记是否被处理过</div></div><div class="notion-spacer"></div><div class="notion-column notion-block-383288cbbacb4927a50565d9d6c3fbf2" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><div class="notion-text notion-block-ceccc611fb584652893982069e74fd95">SPFA</div><div class="notion-text notion-block-2e1d100b45ee4316889b8935ae471529">思想：使用队列来存储被更新的点，优化它的所有出边</div><div class="notion-text notion-block-b89ca272e05c4e7b85189b1211371084">时间复杂度：O(n)，最差O(nm)</div><div class="notion-text notion-block-17ff269bbdde4c479d645513064ac070">核心代码：</div><pre class="notion-code language-c++"><code class="language-c++"><span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
		<span class="token comment">// 弹出被更新的点</span>
    auto t <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    st<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token comment">// 遍历所有出边，尝试优化</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        int j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
                st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-2f251fcab61f4585805da309ef54f7d2">st的作用：标记是否存在队列中</div></div><div class="notion-spacer"></div></div><div class="notion-text notion-block-574ef502c94f46c3b291aa9863a0b5f3">可以发现上面两个版本的思想非常相似，区别仅仅在于：</div><div class="notion-text notion-block-5a43c95b159c4f63bd0c4d02b551f349">堆优化dijkstra使用小根堆来保证弹出的点是目前距离最小的点，而SPFA只需要获得被更新过的点即可。</div><div class="notion-text notion-block-cdb2a1ce32a741d88c2326410fe36e93">一般我们都可以用 SPFA 来解决单源最短路径问题，只有被卡的时候，才考虑堆优化版 dijkstra。</div><hr class="notion-hr notion-block-0384a964ce1b497e9ad94d76bc51fcb9"/><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-fb182adbd8d74a2c9abcb9aa44d4e9c8" data-id="fb182adbd8d74a2c9abcb9aa44d4e9c8"><span><div id="fb182adbd8d74a2c9abcb9aa44d4e9c8" class="notion-header-anchor"></div><a class="notion-hash-link" href="#fb182adbd8d74a2c9abcb9aa44d4e9c8" title="Floyd 算法"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Floyd 算法</span></span></h2><div class="notion-text notion-block-5ac01c7cb055455cab9d494b1e9fba0f">如果是要求任意两个点之间的最短路径的话，就考虑用 floyd 算法了，这个算法很暴力：</div><pre class="notion-code language-c++"><code class="language-c++">初始化：
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>int j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">INF</span><span class="token punctuation">;</span>

<span class="token comment">// 算法结束后，d[a][b]表示a到b的最短距离</span>
<span class="token keyword">void</span> <span class="token function">floyd</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>int k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> k <span class="token operator">++</span> <span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>int j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>
                d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> d<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-b5f91a4336aa4baeaa8d218a546cd474">时间复杂度：O(n^3)</div><div class="notion-text notion-block-234dbb79118843eca2290621e0bc6865">需要注意的是，先枚举中间点k，再枚举左右端点i和j</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-b9825e52097b495f825051846560a004" data-id="b9825e52097b495f825051846560a004"><span><div id="b9825e52097b495f825051846560a004" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b9825e52097b495f825051846560a004" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h2><div class="notion-text notion-block-14b0a4095f724048b2fc15b2aed3ffba">单源最短路径：优先考虑SPFA，被卡再考虑堆优化版dijkstra</div><div class="notion-text notion-block-2322dc5c2fe24726a19f2d204bf860e9">多源最短路径：Floyd</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-b0eebf59397243c2960a1be9598a6341" data-id="b0eebf59397243c2960a1be9598a6341"><span><div id="b0eebf59397243c2960a1be9598a6341" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b0eebf59397243c2960a1be9598a6341" title="参考"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">参考</span></span></h2><div class="notion-text notion-block-07a2443e56e447419696de6a9af81778"><b>
</b><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.acwing.com/activity/content/punch_the_clock/11/">AcWing 算法基础课</a></div><div class="notion-blank notion-block-96eff80ca79f468686ea8767657e1196"> </div></main></div></article><div class="flex justify-between font-medium text-gray-500 dark:text-gray-400"><a><button class="mt-2 cursor-pointer hover:text-black dark:hover:text-gray-100">← <!-- -->返回</button></a><a><button class="mt-2 cursor-pointer hover:text-black dark:hover:text-gray-100">↑ <!-- -->回到顶部</button></a></div><div></div></main><div class="mt-6 flex-shrink-0 m-auto w-full text-gray-500 dark:text-gray-400 transition-all max-w-3xl px-4"><hr class="border-gray-200 dark:border-gray-600"/><div class="my-4 text-sm leading-6"><div class="flex align-baseline justify-between flex-wrap"><p>© <!-- -->hhmy<!-- --> <!-- -->2019 - 2023</p><p>powered by <a href="https://github.com/craigary/nobelium"><u>nobelium</u></a></p></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","date":{"start_date":"2023-01-29"},"type":["Post"],"slug":"short-path-problem","tags":["算法"],"summary":"五种求最短路径的基本算法","title":"求最短路径的基本算法","status":["Published"],"createdTime":"Sun Jan 29 2023 04:58:44 GMT+0000 (Coordinated Universal Time)","fullWidth":false,"pageIcon":null,"pageCover":null},"blockMap":{"block":{"cf1ae05a-dc05-49ed-934b-adf97088cd5c":{"role":"reader","value":{"id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","version":613,"type":"page","properties":{"NX\\Q":[["‣",[["d",{"type":"date","start_date":"2023-01-29"}]]]],"`gQ~":[["Post"]],"d]hq":[["short-path-problem"]],"sD^m":[["算法"]],"wz|S":[["五种求最短路径的基本算法"]],"title":[["求最短路径的基本算法"]],"f211bdc0-ee00-4186-9a7d-f68c055ec2ee":[["Published"]]},"content":["c1ea8b8f-1656-40f7-9e12-4606bdac87d7","195db797-754a-4d65-b262-92c2c40b9251","83a49847-65d5-44bf-a5f8-114e10ec88f0","5a0821b2-fe8a-43a9-8a4c-f70a8d685664","570427a1-44dd-40c2-8e3d-c16b095e4cd0","ca72d4f7-c2e4-4cc6-8999-129aaacb48f7","7e619928-9e4c-474e-ad40-05e6c3c4362e","939c90f4-b6ab-4520-9033-53d76e46c9d8","40e3e647-04db-48e9-a14f-ed6fbf29931c","49925cae-ef1f-4f9c-a1cd-a83133ba9f32","bba72da2-e4b2-4a7e-ac88-973fc377e261","f5eb2c8f-4855-4dc0-8710-19667b3c7f4e","549c05a4-73a5-4e3a-822c-6122c52fb1cf","40afe4b4-4bad-4ff2-b21e-e939b8f6288f","3771f43d-9ca9-47f3-9409-2b934a3c5317","ae9a99dd-0327-4094-a30c-7f967a6ec4f8","a055e869-2264-412a-8b88-02c69974fbc3","41bb1978-00cb-461f-bb04-8494ead8a01a","e48a63ef-cfd9-4f18-b9d9-57c3adc417e7","4af6bf98-2b17-443d-9b7d-858f333ce0ea","e1490e3d-81a9-424a-876d-185ff40e40f6","c1f5e7b5-d40f-4cd1-9535-0b76d3010750","9ed4b1e9-31af-48c6-912d-9bcf41d43fd7","454c67ce-c721-4ecf-9f61-b540bcb88576","b8468e1a-ff91-4346-a49f-a98fcc373ea0","0e8da0ac-6238-4a06-9990-556e2aab5e7f","3e284938-c88d-4717-8c54-259b5759773e","c8fd202a-fbef-438b-93cf-ed00cc19ccdc","3f0cccd6-904e-4637-97d5-5708b68d1a84","77c270d6-028e-4f12-b791-36e62fd59c7d","9af9674c-aad1-44f3-a335-144e2291fc13","6b6bbc5e-4417-4fe4-b535-cf516462e83b","ffb0148c-8c07-44ca-96f5-154fe31cd4c8","88380cd5-24f4-4640-8620-dfe52a37cc20","7c2f8ef2-433e-4c92-923d-308d0dbafb9a","fe9d2211-d4d3-47ac-ada8-419f561785e9","8e645975-6098-4497-9c96-5a2a554c19b4","82fe1cb3-2eff-4380-ba25-ab263b364243","5368d392-54e8-4c66-9464-acb5dde07459","cce910ad-bdda-4685-899e-eac434a5a07e","873667bd-7f04-44a5-a12a-db98e9eb05e9","ad31d361-98cc-4ffe-b84f-82a19c9c2089","d92dba5b-7164-4d69-88f5-61a10025e55e","305ca289-b4ac-4423-8cb3-41a5cc7ed7f8","41938f35-dc06-46d9-90c7-7f0a12521f06","fe3602f2-aa03-4822-aad5-e5016d22a911","8de2296e-4755-4ba4-8f9c-a3a7001a7ee8","45900b25-aa68-4ba2-ad99-16b43fe34d0c","5ff1add4-7bc6-4c0b-9dd3-ed2805ba5cef","7249a3ee-d7c4-4806-aa84-0c2a1d395d4a","a36add07-0a13-4e12-8d58-cb3dbacd568c","fc56b7e6-100a-41bc-a8fe-5ee64c59ef26","69265b46-b98f-4b23-9459-4ead68111086","59a84b8e-c45d-4775-a3e2-ff29f05e842f","4e335f48-d4b0-49e3-99d1-743b4c8165c0","e1d32628-05a5-4666-a3c8-83d178e4e158","561c0d29-1bdc-414c-9c7e-81994356c387","8b79d122-ef32-47f8-bae7-74fcb4736e7f","b0ec13cd-0b30-4c9e-a29b-bb4e186cce82","5ccbdfff-5f1f-4bb0-a3ea-7a13886abfa2","78c664a5-36b8-47e2-a565-77104cf28f04","e40b098a-c241-4ec3-ab0e-8553fa96004d","e0bda813-84d9-410d-9905-f980b5fa68af","481069a8-9264-486f-a0b0-c1eb86b1ae97","ec140ca2-c313-43ac-802d-35ca67157e80","857fb327-86bb-4f88-ac51-409122aae584","dfdc1164-ec52-4001-8bce-e8af894a1d4f","f3168a7e-c789-4cce-9c4c-aded2c9fd01d","35456df6-3219-4f62-a1dc-14bf4c45eea8","6207ea19-b452-42d3-96b3-5c60607c4c45","b10bad30-8a58-4162-bf08-4ff2c9f08b61","10169151-a288-4e98-9c4e-cd3985e1bc57","9a12e3c1-7d71-4ea2-968d-fe5bac863641","716534c7-d995-40fa-abc2-6b70bb584a35","9951eca8-52e0-4257-9a3e-28002e567712","b427db4b-e4fd-46c7-bd0c-50d503ef6530","6f05c089-85fa-4a51-b9f8-e1b23ab856fe","ce956d67-d109-4d6e-a96e-36e2e2b5016a","574ef502-c94f-46c3-b291-aa9863a0b5f3","5a43c95b-159c-4f63-bd0c-4d02b551f349","cdb2a1ce-32a7-41d8-8c23-26410fe36e93","0384a964-ce1b-497e-9ad9-4d76bc51fcb9","fb182adb-d8d7-4a2c-9abc-b9aa44d4e9c8","5ac01c7c-b055-455c-ab9d-494b1e9fba0f","721bfef7-5635-497c-96f6-0cf9c21e47f4","b5f91a43-36aa-4bae-aa8d-218a546cd474","234dbb79-1188-43ec-a229-0621e0bc6865","b9825e52-097b-495f-8250-51846560a004","14b0a409-5f72-4048-b2fc-15b2aed3ffba","2322dc5c-2fe2-4726-a19f-2d204bf860e9","b0eebf59-3972-43c2-960a-1be9598a6341","07a2443e-56e4-4741-9696-de6a9af81778","96eff80c-a79f-4686-86ea-8767657e1196"],"created_time":1674968324338,"last_edited_time":1674976021909,"parent_id":"a3ce75fe-7085-406b-a33f-74958ef7ee13","parent_table":"collection","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"1d21f050-c8c4-41f3-9fd4-8ff7de49c962":{"role":"reader","value":{"id":"1d21f050-c8c4-41f3-9fd4-8ff7de49c962","version":52,"type":"collection_view_page","view_ids":["876cf270-3f6b-4f1a-b6c8-5ffbd27ca40f"],"collection_id":"a3ce75fe-7085-406b-a33f-74958ef7ee13","format":{"block_locked":false,"block_locked_by":"2c0e0b01-f59e-4e03-b7b6-7d706eecada3","collection_pointer":{"id":"a3ce75fe-7085-406b-a33f-74958ef7ee13","table":"collection","spaceId":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"},"copied_from_pointer":{"id":"866916e3-b939-468b-9b6f-1d47dce99f9c","table":"block","spaceId":"ac4cb96d-c8f8-4040-9bb2-868d9fc7f526"}},"permissions":[{"role":"editor","type":"user_permission","user_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec"},{"role":"reader","type":"public_permission","added_timestamp":1671187403441}],"created_time":1670483100421,"last_edited_time":1674968741252,"parent_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4","parent_table":"space","alive":true,"copied_from":"866916e3-b939-468b-9b6f-1d47dce99f9c","created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"c1ea8b8f-1656-40f7-9e12-4606bdac87d7":{"role":"reader","value":{"id":"c1ea8b8f-1656-40f7-9e12-4606bdac87d7","version":4,"type":"table_of_contents","format":{"block_color":"gray"},"created_time":1674968441328,"last_edited_time":1674968441331,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"195db797-754a-4d65-b262-92c2c40b9251":{"role":"reader","value":{"id":"195db797-754a-4d65-b262-92c2c40b9251","version":4,"type":"header","properties":{"title":[["简介"]]},"created_time":1674968350311,"last_edited_time":1674968438944,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"83a49847-65d5-44bf-a5f8-114e10ec88f0":{"role":"reader","value":{"id":"83a49847-65d5-44bf-a5f8-114e10ec88f0","version":718,"type":"text","properties":{"title":[["最短路径问题要求我们给出点与点之间的最短路径，根据问题的分类一共有 5 种解决该类问题的方法。"]]},"created_time":1674968360005,"last_edited_time":1674968419802,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"5a0821b2-fe8a-43a9-8a4c-f70a8d685664":{"role":"reader","value":{"id":"5a0821b2-fe8a-43a9-8a4c-f70a8d685664","version":202,"type":"text","properties":{"title":[["本文将依次介绍每种算法的思想、时间复杂度、适用场景。"]]},"created_time":1674968419977,"last_edited_time":1674968434570,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"570427a1-44dd-40c2-8e3d-c16b095e4cd0":{"role":"reader","value":{"id":"570427a1-44dd-40c2-8e3d-c16b095e4cd0","version":18,"type":"image","properties":{"size":[["167.8KB"]],"title":[["Untitled"]],"source":[["https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e045bf49-c643-450c-84cb-8d7e80f87827/Untitled.png"]]},"format":{"block_width":1720,"display_source":"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e045bf49-c643-450c-84cb-8d7e80f87827/Untitled.png","block_full_width":false,"block_page_width":true,"block_aspect_ratio":0.6162790697674418,"block_preserve_scale":true},"created_time":1674968348644,"last_edited_time":1674968463682,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"file_ids":["e045bf49-c643-450c-84cb-8d7e80f87827"],"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"ca72d4f7-c2e4-4cc6-8999-129aaacb48f7":{"role":"reader","value":{"id":"ca72d4f7-c2e4-4cc6-8999-129aaacb48f7","version":54,"type":"header","properties":{"title":[["问题分类"]]},"created_time":1674968435626,"last_edited_time":1674968445192,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"7e619928-9e4c-474e-ad40-05e6c3c4362e":{"role":"reader","value":{"id":"7e619928-9e4c-474e-ad40-05e6c3c4362e","version":191,"type":"text","properties":{"title":[["最短路问题分为两类："]]},"created_time":1674968445355,"last_edited_time":1674968456663,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"939c90f4-b6ab-4520-9033-53d76e46c9d8":{"role":"reader","value":{"id":"939c90f4-b6ab-4520-9033-53d76e46c9d8","version":222,"type":"numbered_list","properties":{"title":[["单源最短路：求两个点之间的最短路径，一般是 1 到 n 号点"]]},"created_time":1674968456858,"last_edited_time":1674968496141,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"40e3e647-04db-48e9-a14f-ed6fbf29931c":{"role":"reader","value":{"id":"40e3e647-04db-48e9-a14f-ed6fbf29931c","version":178,"type":"numbered_list","properties":{"title":[["多源汇最短路：求任意两个点之间的最短路径"]]},"created_time":1674968465843,"last_edited_time":1674968502324,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"49925cae-ef1f-4f9c-a1cd-a83133ba9f32":{"role":"reader","value":{"id":"49925cae-ef1f-4f9c-a1cd-a83133ba9f32","version":109,"type":"text","created_time":1674968471959,"last_edited_time":1674968505615,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"bba72da2-e4b2-4a7e-ac88-973fc377e261":{"role":"reader","value":{"id":"bba72da2-e4b2-4a7e-ac88-973fc377e261","version":261,"type":"text","properties":{"title":[["而单源最短路问题，根据边的不同，又有一些需要注意的地方："]]},"created_time":1674968471959,"last_edited_time":1674968588773,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"f5eb2c8f-4855-4dc0-8710-19667b3c7f4e":{"role":"reader","value":{"id":"f5eb2c8f-4855-4dc0-8710-19667b3c7f4e","version":350,"type":"numbered_list","properties":{"title":[["所有边权都是正数：这种情况是最常见的，用 dijkstra 就能求解"]]},"created_time":1674968531524,"last_edited_time":1674968580704,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"549c05a4-73a5-4e3a-822c-6122c52fb1cf":{"role":"reader","value":{"id":"549c05a4-73a5-4e3a-822c-6122c52fb1cf","version":355,"type":"numbered_list","properties":{"title":[["边权存在负数：此时 dijkstra 无法求解，只能使用 BF 或者 SPFA 算法求解"]]},"created_time":1674968543779,"last_edited_time":1674968606110,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"40afe4b4-4bad-4ff2-b21e-e939b8f6288f":{"role":"reader","value":{"id":"40afe4b4-4bad-4ff2-b21e-e939b8f6288f","version":11,"type":"text","created_time":1674968606625,"last_edited_time":1674969445895,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"3771f43d-9ca9-47f3-9409-2b934a3c5317":{"role":"reader","value":{"id":"3771f43d-9ca9-47f3-9409-2b934a3c5317","version":66,"type":"header","properties":{"title":[["图的存储"]]},"created_time":1674968606625,"last_edited_time":1674969449870,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"ae9a99dd-0327-4094-a30c-7f967a6ec4f8":{"role":"reader","value":{"id":"ae9a99dd-0327-4094-a30c-7f967a6ec4f8","version":49,"type":"sub_header","properties":{"title":[["邻接矩阵"]]},"created_time":1674969450439,"last_edited_time":1674969456785,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"a055e869-2264-412a-8b88-02c69974fbc3":{"role":"reader","value":{"id":"a055e869-2264-412a-8b88-02c69974fbc3","version":73,"type":"text","properties":{"title":[["最简单的存储方式"]]},"created_time":1674971849017,"last_edited_time":1674971852495,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"41bb1978-00cb-461f-bb04-8494ead8a01a":{"role":"reader","value":{"id":"41bb1978-00cb-461f-bb04-8494ead8a01a","version":126,"type":"text","properties":{"title":[["N是点数，一般不会太大，用于存储稀疏图"]]},"created_time":1674971860416,"last_edited_time":1674971868035,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"e48a63ef-cfd9-4f18-b9d9-57c3adc417e7":{"role":"reader","value":{"id":"e48a63ef-cfd9-4f18-b9d9-57c3adc417e7","version":41,"type":"code","properties":{"title":[["int g[N][N];"]],"language":[["C++"]]},"created_time":1674971853687,"last_edited_time":1674971858857,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"4af6bf98-2b17-443d-9b7d-858f333ce0ea":{"role":"reader","value":{"id":"4af6bf98-2b17-443d-9b7d-858f333ce0ea","version":44,"type":"sub_header","properties":{"title":[["邻接表"]]},"created_time":1674969456894,"last_edited_time":1674969459313,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"e1490e3d-81a9-424a-876d-185ff40e40f6":{"role":"reader","value":{"id":"e1490e3d-81a9-424a-876d-185ff40e40f6","version":143,"type":"text","properties":{"title":[["又称为链式前向星"]]},"created_time":1674971869536,"last_edited_time":1674971880751,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"c1f5e7b5-d40f-4cd1-9535-0b76d3010750":{"role":"reader","value":{"id":"c1f5e7b5-d40f-4cd1-9535-0b76d3010750","version":825,"type":"code","properties":{"title":[["// 对于每个点k，开一个单链表，存储k所有可以走到的点。\n// h[k]存储这个单链表的头节点\n// e 存储 value， ne 存储 next 指针， w 存储边权\nint h[N], e[N], ne[N], w[N], idx;\n\n// 添加一条边 a -\u003e b, 边权为 c\nvoid add(int a, int b, int c)\n{\n\t\te[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;\n}\n\n// 遍历点t的所有出边\nfor (int i = h[t]; i != -1; i = ne[i]){\n\t\tdistance = w[i]; // 边权\n\t\t// 具体操作\n}\n\n// 初始化\nidx = 0;\nmemset(h, -1, sizeof h);"]],"language":[["C++"]]},"created_time":1674971882729,"last_edited_time":1674971998272,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"9ed4b1e9-31af-48c6-912d-9bcf41d43fd7":{"role":"reader","value":{"id":"9ed4b1e9-31af-48c6-912d-9bcf41d43fd7","version":99,"type":"header","properties":{"title":[["单源最短路问题算法"]]},"created_time":1674968606625,"last_edited_time":1674969444577,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"454c67ce-c721-4ecf-9f61-b540bcb88576":{"role":"reader","value":{"id":"454c67ce-c721-4ecf-9f61-b540bcb88576","version":160,"type":"header","properties":{"title":[["dijkstra 算法"]]},"created_time":1674968612600,"last_edited_time":1674972337284,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"b8468e1a-ff91-4346-a49f-a98fcc373ea0":{"role":"reader","value":{"id":"b8468e1a-ff91-4346-a49f-a98fcc373ea0","version":168,"type":"text","properties":{"title":[["该算法的思想是："]]},"created_time":1674968352847,"last_edited_time":1674968860842,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"0e8da0ac-6238-4a06-9990-556e2aab5e7f":{"role":"reader","value":{"id":"0e8da0ac-6238-4a06-9990-556e2aab5e7f","version":164,"type":"text","properties":{"title":[["维护一个"],["点集",[["b"]]],["，每一轮找到一个离当前点集最近的一个点"],["t",[["c"]]],["，然后将"],["t",[["c"]]],["加入到点集中，同时用这个最近点"],["去尝试更新",[["b"]]],["其它未遍历点的距离，遍历n - 1轮即可得到答案。"]]},"created_time":1674968860839,"last_edited_time":1674969007557,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"3e284938-c88d-4717-8c54-259b5759773e":{"role":"reader","value":{"id":"3e284938-c88d-4717-8c54-259b5759773e","version":31,"type":"text","properties":{"title":[["伪代码："]]},"created_time":1674968930933,"last_edited_time":1674968933023,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"c8fd202a-fbef-438b-93cf-ed00cc19ccdc":{"role":"reader","value":{"id":"c8fd202a-fbef-438b-93cf-ed00cc19ccdc","version":2246,"type":"code","properties":{"title":[["dijkstra(){\n\t\t// dist[i] 表示从 1 号点出发到点 i 的最短路径\n\t\tfor 遍历n-1轮：\n\t\t\t// 寻找最近点 O(n)\n\t\t\tfor 遍历所有节点 j:\n\t\t\t\t如果当前点j没有确认最短路，并且距离最小：\n\t\t\t\t\tt = j，记录最近点是j\n\t\t\t\n\t\t\t// O(n)\n\t\t\tfor 遍历所有点 j:\n\t\t\t\t// 尝试用 t 去更新其它点的距离，g是邻接矩阵\n\t\t\t\t// 如果 1 -\u003e j 的距离大于 1 -\u003e t -\u003e j，更新最短路径为 1 -\u003e t -\u003e j 的距离\n\t\t\t\tdist[j] = min(dist[j], dist[t] + g[t][j]);\n\t\t\t\n\t\t\t标记 t 点已经确认最短路径\n}"]],"language":[["C++"]]},"created_time":1674968934050,"last_edited_time":1674969216046,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"3f0cccd6-904e-4637-97d5-5708b68d1a84":{"role":"reader","value":{"id":"3f0cccd6-904e-4637-97d5-5708b68d1a84","version":332,"type":"text","properties":{"title":[["经过上面的计算，"],["dist[n]",[["c"]]],[" 就是最终答案了。"]]},"created_time":1674968857079,"last_edited_time":1674969303996,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"77c270d6-028e-4f12-b791-36e62fd59c7d":{"role":"reader","value":{"id":"77c270d6-028e-4f12-b791-36e62fd59c7d","version":78,"type":"sub_header","properties":{"title":[["朴素版 dijkstra"]]},"created_time":1674969304379,"last_edited_time":1674969312067,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"9af9674c-aad1-44f3-a335-144e2291fc13":{"role":"reader","value":{"id":"9af9674c-aad1-44f3-a335-144e2291fc13","version":271,"type":"text","properties":{"title":[["朴素版的 dijkstra 基本上是伪代码的实现，代码如下："]]},"created_time":1674969312607,"last_edited_time":1674969330570,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"6b6bbc5e-4417-4fe4-b535-cf516462e83b":{"role":"reader","value":{"id":"6b6bbc5e-4417-4fe4-b535-cf516462e83b","version":197,"type":"code","properties":{"title":[["int g[N][N]; // 存储每条边\nint dist[N]; // 存储1号点到每个点的最短距离\nbool st[N];  // 存储每个点的最短路是否已经确定\n\n// 求1号点到n号点的最短路，如果不存在则返回-1 \nint dijkstra()\n{\n\t\t// 0x3f3f3f3f 表示无穷大\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    for (int i = 0; i \u003c n - 1; i++)\n    {\n        // 在还未确定最短路的点中，寻找距离最小的点\n        int t = -1;\n        for (int j = 1; j \u003c= n; j++)\n            if (!st[j] \u0026\u0026 (t == -1 || dist[t] \u003e dist[j]))\n                t = j;\n        \n        // 尝试用t更新其它点\n        for (int j = 1; j \u003c= n; j++)\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n        st[t] = true;\n    }\n\n    if (dist[n] == 0x3f3f3f3f)\n        return -1;\n    return dist[n];\n}"]],"language":[["C++"]]},"created_time":1674969331618,"last_edited_time":1674969396892,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"ffb0148c-8c07-44ca-96f5-154fe31cd4c8":{"role":"reader","value":{"id":"ffb0148c-8c07-44ca-96f5-154fe31cd4c8","version":539,"type":"text","properties":{"title":[["时间复杂度："],["⁍",[["e","O(n^2+m)"]]],["，n是点数，m是边数"]]},"created_time":1674969338638,"last_edited_time":1674969483298,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"88380cd5-24f4-4640-8620-dfe52a37cc20":{"role":"reader","value":{"id":"88380cd5-24f4-4640-8620-dfe52a37cc20","version":117,"type":"quote","properties":{"title":[["有关时间复杂度的计算可以参考这篇文章："],[" Dijkstra算法时间复杂度分析",[["a","https://blog.csdn.net/michealoven/article/details/114040136"]]]]},"created_time":1674969640375,"last_edited_time":1674971561305,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"7c2f8ef2-433e-4c92-923d-308d0dbafb9a":{"role":"reader","value":{"id":"7c2f8ef2-433e-4c92-923d-308d0dbafb9a","version":55,"type":"text","properties":{"title":[["适用场景：稠密图，即点少但边多的场景，因此可以用邻接矩阵来存储图"]]},"created_time":1674969382105,"last_edited_time":1674972072242,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"fe9d2211-d4d3-47ac-ada8-419f561785e9":{"role":"reader","value":{"id":"fe9d2211-d4d3-47ac-ada8-419f561785e9","version":72,"type":"sub_header","properties":{"title":[["堆优化版 dijkstra"]]},"created_time":1674971562430,"last_edited_time":1674971571197,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"8e645975-6098-4497-9c96-5a2a554c19b4":{"role":"reader","value":{"id":"8e645975-6098-4497-9c96-5a2a554c19b4","version":142,"type":"text","properties":{"title":[["在朴素版 dijkstra 中，下面的步骤："]]},"created_time":1674971571572,"last_edited_time":1674971592476,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"82fe1cb3-2eff-4380-ba25-ab263b364243":{"role":"reader","value":{"id":"82fe1cb3-2eff-4380-ba25-ab263b364243","version":34,"type":"code","properties":{"title":[["  // 在还未确定最短路的点中，寻找距离最小的点\n  int t = -1;\n  for (int j = 1; j \u003c= n; j++)\n      if (!st[j] \u0026\u0026 (t == -1 || dist[t] \u003e dist[j]))\n          t = j;"]],"language":[["C++"]]},"created_time":1674971593514,"last_edited_time":1674971622812,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"5368d392-54e8-4c66-9464-acb5dde07459":{"role":"reader","value":{"id":"5368d392-54e8-4c66-9464-acb5dde07459","version":307,"type":"text","properties":{"title":[["寻找距离最小的点，",[["b"]]],["这个操作可以用堆来优化。具体做法是小根堆来存储当前距离最小的点，其它步骤相同"]]},"created_time":1674971623451,"last_edited_time":1674971667466,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"cce910ad-bdda-4685-899e-eac434a5a07e":{"role":"reader","value":{"id":"cce910ad-bdda-4685-899e-eac434a5a07e","version":276,"type":"code","properties":{"title":[["typedef pair\u003cint, int\u003e PII;\nint n;                            // 点的数量\nint h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边, w[i] 是距离\nint dist[N];                      // 存储所有点到1号点的距离\nbool st[N];                       // 存储每个点的最短距离是否已确定\n\nint dijkstra()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    priority_queue\u003cPII, vector\u003cPII\u003e, greater\u003cPII\u003e\u003e heap;\n    heap.push({0, 1}); // first存储距离，second存储节点编号\n    while (heap.size())\n    {\n\t\t\t\t// 弹出距离最近的点，优化它的出边\n        auto t = heap.top();\n        heap.pop();\n        int ver = t.second, distance = t.first;\n        if (st[ver])\n            continue;\n\n        st[ver] = true;\n\t\t\t\t// 遍历t的所有出边\n        for (int i = h[ver]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] \u003e distance + w[i])\n            {\n                dist[j] = distance + w[i];\n                heap.push({dist[j], j});  // 如果能优化，则放入点\n            }\n        }\n    }\n    if (dist[n] == 0x3f3f3f3f)\n        return -1;\n    return dist[n];\n}"]],"language":[["C++"]]},"created_time":1674971668830,"last_edited_time":1674971734202,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"873667bd-7f04-44a5-a12a-db98e9eb05e9":{"role":"reader","value":{"id":"873667bd-7f04-44a5-a12a-db98e9eb05e9","version":694,"type":"text","properties":{"title":[["需要注意的是，堆里面允许冗余点存在，比如{4, 3}，{2, 3}，{7, 3}这几个组合是允许同时存在的。"]]},"created_time":1674971738335,"last_edited_time":1674971812633,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"ad31d361-98cc-4ffe-b84f-82a19c9c2089":{"role":"reader","value":{"id":"ad31d361-98cc-4ffe-b84f-82a19c9c2089","version":446,"type":"text","properties":{"title":[["st",[["c"]]],[" 的含义是点是否被处理过，因此只有在从堆中弹出的时候才标记 "],["st[t] = true",[["c"]]],[" "]]},"created_time":1674971812914,"last_edited_time":1674971844419,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"d92dba5b-7164-4d69-88f5-61a10025e55e":{"role":"reader","value":{"id":"d92dba5b-7164-4d69-88f5-61a10025e55e","version":67,"type":"text","properties":{"title":[["时间复杂度："],["⁍",[["e","O(nlogm)"]]]]},"created_time":1674971844722,"last_edited_time":1674972081195,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"305ca289-b4ac-4423-8cb3-41a5cc7ed7f8":{"role":"reader","value":{"id":"305ca289-b4ac-4423-8cb3-41a5cc7ed7f8","version":260,"type":"text","properties":{"title":[["适用场景：稀疏图，点多边少"]]},"created_time":1674972035523,"last_edited_time":1674972077985,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"41938f35-dc06-46d9-90c7-7f0a12521f06":{"role":"reader","value":{"id":"41938f35-dc06-46d9-90c7-7f0a12521f06","version":18,"type":"divider","created_time":1674972140854,"last_edited_time":1674972141391,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"fe3602f2-aa03-4822-aad5-e5016d22a911":{"role":"reader","value":{"id":"fe3602f2-aa03-4822-aad5-e5016d22a911","version":3,"type":"text","properties":{"title":[["一旦图中存在负权边，dijkstra 算法就失效了，只能使用 BF 算法或者 SPFA 算法求解"]]},"format":{"copied_from_pointer":{"id":"5f8bf1e3-434d-4fa7-bea4-cf64cc584462","table":"block","spaceId":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"created_time":1674972142110,"last_edited_time":1674972142114,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"copied_from":"5f8bf1e3-434d-4fa7-bea4-cf64cc584462","created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"8de2296e-4755-4ba4-8f9c-a3a7001a7ee8":{"role":"reader","value":{"id":"8de2296e-4755-4ba4-8f9c-a3a7001a7ee8","version":34,"type":"header","properties":{"title":[["BF 算法"]]},"created_time":1674972078853,"last_edited_time":1674972101754,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"45900b25-aa68-4ba2-ad99-16b43fe34d0c":{"role":"reader","value":{"id":"45900b25-aa68-4ba2-ad99-16b43fe34d0c","version":48,"type":"text","properties":{"title":[["思想："]]},"created_time":1674972193564,"last_edited_time":1674972216888,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"5ff1add4-7bc6-4c0b-9dd3-ed2805ba5cef":{"role":"reader","value":{"id":"5ff1add4-7bc6-4c0b-9dd3-ed2805ba5cef","version":385,"type":"text","properties":{"title":[["迭代 n 次，每次遍历所有边，尝试去更新dist数组。这样得到的dist数组就是最终结果了"]]},"created_time":1674972217132,"last_edited_time":1674972256102,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"7249a3ee-d7c4-4806-aa84-0c2a1d395d4a":{"role":"reader","value":{"id":"7249a3ee-d7c4-4806-aa84-0c2a1d395d4a","version":34,"type":"text","properties":{"title":[["伪代码："]]},"created_time":1674972144408,"last_edited_time":1674972164094,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"a36add07-0a13-4e12-8d58-cb3dbacd568c":{"role":"reader","value":{"id":"a36add07-0a13-4e12-8d58-cb3dbacd568c","version":60,"type":"code","properties":{"title":[["for 迭代n次:\n\tfor 所有边 a -\u003e b, 边权 w:\n\t\tdist[b] = min(dist[b], dist[a] + w); // 松弛操作"]],"language":[["C++"]]},"created_time":1674972166427,"last_edited_time":1674972182320,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"fc56b7e6-100a-41bc-a8fe-5ee64c59ef26":{"role":"reader","value":{"id":"fc56b7e6-100a-41bc-a8fe-5ee64c59ef26","version":31,"type":"text","properties":{"title":[["实现："]]},"created_time":1674972169049,"last_edited_time":1674972278719,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"69265b46-b98f-4b23-9459-4ead68111086":{"role":"reader","value":{"id":"69265b46-b98f-4b23-9459-4ead68111086","version":20,"type":"code","properties":{"title":[["int n, m;\nint dist[N];\n\n// 边，a表示出点，b表示入点，w表示边的权重\nstruct Edge\n{\n    int a, b, w;\n} edges[M];\n\nint bellman_ford()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，\n    // 由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。\n    for (int i = 0; i \u003c n; i++)\n    {\n        for (int j = 0; j \u003c m; j++)\n        {\n            int a = edges[j].a, b = edges[j].b, w = edges[j].w;\n            if (dist[b] \u003e dist[a] + w)\n                dist[b] = dist[a] + w;\n        }\n    }\n    if (dist[n] \u003e 0x3f3f3f3f / 2)\n        return -1;\n    return dist[n];\n}"]],"language":[["C++"]]},"created_time":1674972272404,"last_edited_time":1674972280115,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"59a84b8e-c45d-4775-a3e2-ff29f05e842f":{"role":"reader","value":{"id":"59a84b8e-c45d-4775-a3e2-ff29f05e842f","version":75,"type":"text","properties":{"title":[["时间复杂度： "],["⁍",[["e","O(nm)"]]]]},"created_time":1674972285208,"last_edited_time":1674972316527,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"4e335f48-d4b0-49e3-99d1-743b4c8165c0":{"role":"reader","value":{"id":"4e335f48-d4b0-49e3-99d1-743b4c8165c0","version":241,"type":"text","properties":{"title":[["适用场景：图中存在负权边"]]},"created_time":1674972293070,"last_edited_time":1674972313721,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"e1d32628-05a5-4666-a3c8-83d178e4e158":{"role":"reader","value":{"id":"e1d32628-05a5-4666-a3c8-83d178e4e158","version":66,"type":"header","properties":{"title":[["SPFA 算法"]]},"created_time":1674972317734,"last_edited_time":1674972333208,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"561c0d29-1bdc-414c-9c7e-81994356c387":{"role":"reader","value":{"id":"561c0d29-1bdc-414c-9c7e-81994356c387","version":304,"type":"text","properties":{"title":[["从 BF 算法中我们可以观察这个条件："]]},"created_time":1674972338276,"last_edited_time":1674972379768,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"8b79d122-ef32-47f8-bae7-74fcb4736e7f":{"role":"reader","value":{"id":"8b79d122-ef32-47f8-bae7-74fcb4736e7f","version":27,"type":"code","properties":{"title":[["if (dist[b] \u003e dist[a] + w)\n    dist[b] = dist[a] + w;"]],"language":[["C++"]]},"created_time":1674972369356,"last_edited_time":1674972374430,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"b0ec13cd-0b30-4c9e-a29b-bb4e186cce82":{"role":"reader","value":{"id":"b0ec13cd-0b30-4c9e-a29b-bb4e186cce82","version":249,"type":"text","properties":{"title":[["何时才能更新 dist[b] 呢？当然是只有 dist[a] 发生变动的时候才能更新了。"]]},"created_time":1674972380884,"last_edited_time":1674972403177,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"5ccbdfff-5f1f-4bb0-a3ea-7a13886abfa2":{"role":"reader","value":{"id":"5ccbdfff-5f1f-4bb0-a3ea-7a13886abfa2","version":616,"type":"text","properties":{"title":[["SPFA 的思想也很简单，当一个点被更新的时候，才去更新它的所有出边。"]]},"created_time":1674972403415,"last_edited_time":1674972452620,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"78c664a5-36b8-47e2-a565-77104cf28f04":{"role":"reader","value":{"id":"78c664a5-36b8-47e2-a565-77104cf28f04","version":5,"type":"text","properties":{"title":[["这样就避免每次都遍历所有边尝试去更新最短距离了。"]]},"created_time":1674972452617,"last_edited_time":1674972452620,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"e40b098a-c241-4ec3-ab0e-8553fa96004d":{"role":"reader","value":{"id":"e40b098a-c241-4ec3-ab0e-8553fa96004d","version":20,"type":"text","properties":{"title":[["代码："]]},"created_time":1674972453264,"last_edited_time":1674972454573,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"e0bda813-84d9-410d-9905-f980b5fa68af":{"role":"reader","value":{"id":"e0bda813-84d9-410d-9905-f980b5fa68af","version":41,"type":"code","properties":{"title":[["int n;                            // 总点数\nint h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边\nint dist[N];                      // 存储每个点到1号点的最短距离\nbool st[N];                       // 存储每个点是否在队列中\n\nint spfa()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    queue\u003cint\u003e q;\n    q.push(1);\n    st[1] = true;\n    while (q.size())\n    {\n        auto t = q.front();\n        q.pop();\n\n        st[t] = false;\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] \u003e dist[t] + w[i])\n            {\n                dist[j] = dist[t] + w[i];\n                if (!st[j])\n                {\n                    q.push(j);\n                    st[j] = true;\n                }\n            }\n        }\n    }\n    if (dist[n] == 0x3f3f3f3f)\n        return -1;\n    return dist[n];\n"]],"language":[["C++"]]},"created_time":1674972455574,"last_edited_time":1674972548492,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"481069a8-9264-486f-a0b0-c1eb86b1ae97":{"role":"reader","value":{"id":"481069a8-9264-486f-a0b0-c1eb86b1ae97","version":569,"type":"text","properties":{"title":[["需要注意的地方是："],["st",[["c"]]],[" 记录的是点是否存在队列中，所以在入队的时候要标记"],["st[j] = true",[["c"]]],[" ，而出队的时候要修改"],["st[j] = false",[["c"]]]]},"created_time":1674972423042,"last_edited_time":1674973395653,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"ec140ca2-c313-43ac-802d-35ca67157e80":{"role":"reader","value":{"id":"ec140ca2-c313-43ac-802d-35ca67157e80","version":119,"type":"text","properties":{"title":[["时间复杂度：一般 "],["⁍",[["e","O(n)"]]],["，最差 "],["⁍",[["e","O(nm)"]]]]},"created_time":1674972518671,"last_edited_time":1674972548492,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"857fb327-86bb-4f88-ac51-409122aae584":{"role":"reader","value":{"id":"857fb327-86bb-4f88-ac51-409122aae584","version":162,"type":"text","properties":{"title":[["适用场景：存在负权边"]]},"created_time":1674972531641,"last_edited_time":1674972566643,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"dfdc1164-ec52-4001-8bce-e8af894a1d4f":{"role":"reader","value":{"id":"dfdc1164-ec52-4001-8bce-e8af894a1d4f","version":137,"type":"header","properties":{"title":[["负权回路"]]},"created_time":1674972566839,"last_edited_time":1674973232957,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"f3168a7e-c789-4cce-9c4c-aded2c9fd01d":{"role":"reader","value":{"id":"f3168a7e-c789-4cce-9c4c-aded2c9fd01d","version":196,"type":"text","properties":{"title":[["首先介绍一个概念，叫做负权回路，如下图所示"]]},"created_time":1674972585379,"last_edited_time":1674972957222,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"35456df6-3219-4f62-a1dc-14bf4c45eea8":{"role":"reader","value":{"id":"35456df6-3219-4f62-a1dc-14bf4c45eea8","version":11,"type":"image","properties":{"size":[["52.6KB"]],"title":[["Untitled"]],"source":[["https://s3-us-west-2.amazonaws.com/secure.notion-static.com/844bb17e-a37b-4d92-b968-91b56af5972a/Untitled.png"]]},"format":{"block_width":982,"display_source":"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/844bb17e-a37b-4d92-b968-91b56af5972a/Untitled.png","block_full_width":false,"block_page_width":true,"block_aspect_ratio":0.5254582484725051,"block_preserve_scale":true},"created_time":1674973032645,"last_edited_time":1674973035816,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"file_ids":["844bb17e-a37b-4d92-b968-91b56af5972a"],"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"6207ea19-b452-42d3-96b3-5c60607c4c45":{"role":"reader","value":{"id":"6207ea19-b452-42d3-96b3-5c60607c4c45","version":109,"type":"text","properties":{"title":[["图中2，3，4组成了一个负权回路。"]]},"created_time":1674972579787,"last_edited_time":1674973055518,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"b10bad30-8a58-4162-bf08-4ff2c9f08b61":{"role":"reader","value":{"id":"b10bad30-8a58-4162-bf08-4ff2c9f08b61","version":491,"type":"text","properties":{"title":[["当负权回路处于源点和目标点的路径上时，必然无法求出最短路径。因为每经过一次负权回路，边权就-1。"]]},"created_time":1674973056093,"last_edited_time":1674973094185,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"10169151-a288-4e98-9c4e-cd3985e1bc57":{"role":"reader","value":{"id":"10169151-a288-4e98-9c4e-cd3985e1bc57","version":408,"type":"text","properties":{"title":[["对比BF算法和SPFA算法我们可以发现，上面这种情况发生的时候，BF算法迭代n次就停止，不会发生死循环，而SPFA会发生死循环。"]]},"created_time":1674973094571,"last_edited_time":1674973127256,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"9a12e3c1-7d71-4ea2-968d-fe5bac863641":{"role":"reader","value":{"id":"9a12e3c1-7d71-4ea2-968d-fe5bac863641","version":323,"type":"text","properties":{"title":[["对于这种情况，SPFA可以做一些改进，检测出是否有上面情况的存在。"]]},"created_time":1674973127438,"last_edited_time":1674973152314,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"716534c7-d995-40fa-abc2-6b70bb584a35":{"role":"reader","value":{"id":"716534c7-d995-40fa-abc2-6b70bb584a35","version":7,"type":"code","properties":{"title":[["int n;                            // 总点数\nint h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边\nint dist[N], cnt[N];              // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数\nbool st[N];                       // 存储每个点是否在队列中\n\n// 如果存在负环，则返回true，否则返回false。\nbool spfa()\n{\n    // 不需要初始化dist数组\n    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点\n    // 由抽屉原理一定有两个点相同，所以存在环。\n\n    queue\u003cint\u003e q;\n    for (int i = 1; i \u003c= n; i++)\n    {\n        q.push(i);\n        st[i] = true;\n    }\n\n    while (q.size())\n    {\n        auto t = q.front();\n        q.pop();\n\n        st[t] = false;\n\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] \u003e dist[t] + w[i])\n            {\n                dist[j] = dist[t] + w[i];\n                cnt[j] = cnt[t] + 1;\n                if (cnt[j] \u003e= n)\n                    return true; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环\n                if (!st[j])\n                {\n                    q.push(j);\n                    st[j] = true;\n                }\n            }\n        }\n    }\n\n    return false;\n}"]],"language":[["C++"]]},"created_time":1674973153841,"last_edited_time":1674973162095,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"9951eca8-52e0-4257-9a3e-28002e567712":{"role":"reader","value":{"id":"9951eca8-52e0-4257-9a3e-28002e567712","version":833,"type":"text","properties":{"title":[["具体做法是，使用"],["cnt",[["c"]]],["数组来记录经过的点数，如果到某个点经过点数≥n，那么根据抽屉原理，此时有n+1个点，但是最多图中有n个点，所以必然存在2个点相同，因此图中存在负权回路。"]]},"created_time":1674973166951,"last_edited_time":1674974575359,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"b427db4b-e4fd-46c7-bd0c-50d503ef6530":{"role":"reader","value":{"id":"b427db4b-e4fd-46c7-bd0c-50d503ef6530","version":18,"type":"divider","created_time":1674973228434,"last_edited_time":1674973239906,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"6f05c089-85fa-4a51-b9f8-e1b23ab856fe":{"role":"reader","value":{"id":"6f05c089-85fa-4a51-b9f8-e1b23ab856fe","version":166,"type":"header","properties":{"title":[["对比 SPFA 和堆优化 dijkstra"]]},"created_time":1674973239902,"last_edited_time":1674973259875,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"ce956d67-d109-4d6e-a96e-36e2e2b5016a":{"role":"reader","value":{"id":"ce956d67-d109-4d6e-a96e-36e2e2b5016a","version":7,"type":"column_list","content":["76f352c5-a968-4fe7-9460-6a7de6555eab","383288cb-bacb-4927-a505-65d9d6c3fbf2"],"created_time":1674973271660,"last_edited_time":1674973271663,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"76f352c5-a968-4fe7-9460-6a7de6555eab":{"role":"reader","value":{"id":"76f352c5-a968-4fe7-9460-6a7de6555eab","version":21,"type":"column","content":["a7103089-1e63-4d9b-af64-7fa4baad4ff3","3641bca7-3f19-4972-afb6-6950a7584cae","97f8dba5-f02b-4c62-978f-3dc5a8f57852","9221a0b4-0583-437c-95ff-f71df620d90c","6f9a83cf-af01-4ed4-8aa3-1a78be16ecf4","53ce08cb-947f-48a6-a056-49f2bb575aec"],"format":{"column_ratio":0.5},"created_time":1674973271659,"last_edited_time":1674973494993,"parent_id":"ce956d67-d109-4d6e-a96e-36e2e2b5016a","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"383288cb-bacb-4927-a505-65d9d6c3fbf2":{"role":"reader","value":{"id":"383288cb-bacb-4927-a505-65d9d6c3fbf2","version":24,"type":"column","content":["ceccc611-fb58-4652-8939-82069e74fd95","2e1d100b-45ee-4316-889b-8935ae471529","b89ca272-e05c-4e7b-8518-9b1211371084","17ff269b-bdde-4c47-9d64-5513064ac070","60f224da-99a0-4b98-a2b7-8329de8a0ce8","2f251fca-b61f-4585-805d-a309ef54f7d2"],"format":{"column_ratio":0.5},"created_time":1674973271661,"last_edited_time":1674973505320,"parent_id":"ce956d67-d109-4d6e-a96e-36e2e2b5016a","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"a7103089-1e63-4d9b-af64-7fa4baad4ff3":{"role":"reader","value":{"id":"a7103089-1e63-4d9b-af64-7fa4baad4ff3","version":102,"type":"text","properties":{"title":[["堆优化 dijkstra"]]},"created_time":1674973260676,"last_edited_time":1674973271663,"parent_id":"76f352c5-a968-4fe7-9460-6a7de6555eab","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"ceccc611-fb58-4652-8939-82069e74fd95":{"role":"reader","value":{"id":"ceccc611-fb58-4652-8939-82069e74fd95","version":19,"type":"text","properties":{"title":[["SPFA"]]},"created_time":1674973267575,"last_edited_time":1674973271663,"parent_id":"383288cb-bacb-4927-a505-65d9d6c3fbf2","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"3641bca7-3f19-4972-afb6-6950a7584cae":{"role":"reader","value":{"id":"3641bca7-3f19-4972-afb6-6950a7584cae","version":408,"type":"text","properties":{"title":[["思想：使用小根堆来存储最小距离的点，遍历它的所有出边，尝试优化 dist"]]},"created_time":1674973273367,"last_edited_time":1674973297824,"parent_id":"76f352c5-a968-4fe7-9460-6a7de6555eab","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"2e1d100b-45ee-4316-889b-8935ae471529":{"role":"reader","value":{"id":"2e1d100b-45ee-4316-889b-8935ae471529","version":253,"type":"text","properties":{"title":[["思想：使用队列来存储被更新的点，优化它的所有出边"]]},"created_time":1674973328102,"last_edited_time":1674973345083,"parent_id":"383288cb-bacb-4927-a505-65d9d6c3fbf2","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"97f8dba5-f02b-4c62-978f-3dc5a8f57852":{"role":"reader","value":{"id":"97f8dba5-f02b-4c62-978f-3dc5a8f57852","version":64,"type":"text","properties":{"title":[["时间复杂度：O(nlogm)"]]},"created_time":1674973298128,"last_edited_time":1674973304028,"parent_id":"76f352c5-a968-4fe7-9460-6a7de6555eab","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"b89ca272-e05c-4e7b-8518-9b1211371084":{"role":"reader","value":{"id":"b89ca272-e05c-4e7b-8518-9b1211371084","version":91,"type":"text","properties":{"title":[["时间复杂度：O(n)，最差O(nm)"]]},"created_time":1674973345277,"last_edited_time":1674973354411,"parent_id":"383288cb-bacb-4927-a505-65d9d6c3fbf2","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"9221a0b4-0583-437c-95ff-f71df620d90c":{"role":"reader","value":{"id":"9221a0b4-0583-437c-95ff-f71df620d90c","version":53,"type":"text","properties":{"title":[["核心代码："]]},"created_time":1674973304606,"last_edited_time":1674973325129,"parent_id":"76f352c5-a968-4fe7-9460-6a7de6555eab","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"17ff269b-bdde-4c47-9d64-5513064ac070":{"role":"reader","value":{"id":"17ff269b-bdde-4c47-9d64-5513064ac070","version":30,"type":"text","properties":{"title":[["核心代码："]]},"created_time":1674973354931,"last_edited_time":1674973356609,"parent_id":"383288cb-bacb-4927-a505-65d9d6c3fbf2","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"6f9a83cf-af01-4ed4-8aa3-1a78be16ecf4":{"role":"reader","value":{"id":"6f9a83cf-af01-4ed4-8aa3-1a78be16ecf4","version":56,"type":"code","properties":{"title":[["while (heap.size())\n{\n\t\t// 弹出距离最近的点，优化它的出边\n    auto t = heap.top();\n    heap.pop();\n    int ver = t.second, distance = t.first;\n    if (st[ver])\n        continue;\n\n    st[ver] = true;\n\t\t// 遍历t的所有出边\n    for (int i = h[ver]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (dist[j] \u003e distance + w[i])\n        {\n            dist[j] = distance + w[i];\n            heap.push({dist[j], j});  // 如果能优化，则放入点\n        }\n    }\n}"]],"language":[["C++"]]},"created_time":1674973308829,"last_edited_time":1674973408743,"parent_id":"76f352c5-a968-4fe7-9460-6a7de6555eab","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"60f224da-99a0-4b98-a2b7-8329de8a0ce8":{"role":"reader","value":{"id":"60f224da-99a0-4b98-a2b7-8329de8a0ce8","version":354,"type":"code","properties":{"title":[["while (q.size())\n{\n\t\t// 弹出被更新的点\n    auto t = q.front();\n    q.pop();\n\n    st[t] = false;\n\t\t// 遍历所有出边，尝试优化\n    for (int i = h[t]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (dist[j] \u003e dist[t] + w[i])\n        {\n            dist[j] = dist[t] + w[i];\n            if (!st[j])\n            {\n                q.push(j);\n                st[j] = true;\n            }\n        }\n    }\n}"]],"language":[["C++"]]},"created_time":1674973358046,"last_edited_time":1674973436135,"parent_id":"383288cb-bacb-4927-a505-65d9d6c3fbf2","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"53ce08cb-947f-48a6-a056-49f2bb575aec":{"role":"reader","value":{"id":"53ce08cb-947f-48a6-a056-49f2bb575aec","version":116,"type":"text","properties":{"title":[["st的作用：标记是否被处理过"]]},"created_time":1674973494993,"last_edited_time":1674973504433,"parent_id":"76f352c5-a968-4fe7-9460-6a7de6555eab","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"2f251fca-b61f-4585-805d-a309ef54f7d2":{"role":"reader","value":{"id":"2f251fca-b61f-4585-805d-a309ef54f7d2","version":194,"type":"text","properties":{"title":[["st的作用：标记是否存在队列中"]]},"created_time":1674973505319,"last_edited_time":1674973518223,"parent_id":"383288cb-bacb-4927-a505-65d9d6c3fbf2","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"574ef502-c94f-46c3-b291-aa9863a0b5f3":{"role":"reader","value":{"id":"574ef502-c94f-46c3-b291-aa9863a0b5f3","version":548,"type":"text","properties":{"title":[["可以发现上面两个版本的思想非常相似，区别仅仅在于："]]},"created_time":1674973272670,"last_edited_time":1674973476974,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"5a43c95b-159c-4f63-bd0c-4d02b551f349":{"role":"reader","value":{"id":"5a43c95b-159c-4f63-bd0c-4d02b551f349","version":163,"type":"text","properties":{"title":[["堆优化dijkstra使用小根堆来保证弹出的点是目前距离最小的点，而SPFA只需要获得被更新过的点即可。"]]},"created_time":1674973476970,"last_edited_time":1674973493703,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"cdb2a1ce-32a7-41d8-8c23-26410fe36e93":{"role":"reader","value":{"id":"cdb2a1ce-32a7-41d8-8c23-26410fe36e93","version":402,"type":"text","properties":{"title":[["一般我们都可以用 SPFA 来解决单源最短路径问题，只有被卡的时候，才考虑堆优化版 dijkstra。"]]},"created_time":1674973519059,"last_edited_time":1674973549313,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"0384a964-ce1b-497e-9ad9-4d76bc51fcb9":{"role":"reader","value":{"id":"0384a964-ce1b-497e-9ad9-4d76bc51fcb9","version":18,"type":"divider","created_time":1674973549562,"last_edited_time":1674973559490,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"fb182adb-d8d7-4a2c-9abc-b9aa44d4e9c8":{"role":"reader","value":{"id":"fb182adb-d8d7-4a2c-9abc-b9aa44d4e9c8","version":51,"type":"header","properties":{"title":[["Floyd 算法"]]},"created_time":1674973559487,"last_edited_time":1674973564292,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"5ac01c7c-b055-455c-ab9d-494b1e9fba0f":{"role":"reader","value":{"id":"5ac01c7c-b055-455c-ab9d-494b1e9fba0f","version":318,"type":"text","properties":{"title":[["如果是要求任意两个点之间的最短路径的话，就考虑用 floyd 算法了，这个算法很暴力："]]},"created_time":1674973564364,"last_edited_time":1674974816185,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"721bfef7-5635-497c-96f6-0cf9c21e47f4":{"role":"reader","value":{"id":"721bfef7-5635-497c-96f6-0cf9c21e47f4","version":7,"type":"code","properties":{"title":[["初始化：\n    for (int i = 1; i \u003c= n; i ++ )\n        for (int j = 1; j \u003c= n; j ++ )\n            if (i == j) d[i][j] = 0;\n            else d[i][j] = INF;\n\n// 算法结束后，d[a][b]表示a到b的最短距离\nvoid floyd()\n{\n    for (int k = 1; k \u003c= n; k ++ )\n        for (int i = 1; i \u003c= n; i ++ )\n            for (int j = 1; j \u003c= n; j ++ )\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n}"]],"language":[["C++"]]},"created_time":1674974817527,"last_edited_time":1674974817949,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"b5f91a43-36aa-4bae-aa8d-218a546cd474":{"role":"reader","value":{"id":"b5f91a43-36aa-4bae-aa8d-218a546cd474","version":50,"type":"text","properties":{"title":[["时间复杂度：O(n^3)"]]},"created_time":1674974819911,"last_edited_time":1674974829529,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"234dbb79-1188-43ec-a229-0621e0bc6865":{"role":"reader","value":{"id":"234dbb79-1188-43ec-a229-0621e0bc6865","version":295,"type":"text","properties":{"title":[["需要注意的是，先枚举中间点k，再枚举左右端点i和j"]]},"created_time":1674974829919,"last_edited_time":1674974851397,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"b9825e52-097b-495f-8250-51846560a004":{"role":"reader","value":{"id":"b9825e52-097b-495f-8250-51846560a004","version":33,"type":"header","properties":{"title":[["总结"]]},"created_time":1674976038582,"last_edited_time":1674976040649,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"14b0a409-5f72-4048-b2fc-15b2aed3ffba":{"role":"reader","value":{"id":"14b0a409-5f72-4048-b2fc-15b2aed3ffba","version":418,"type":"text","properties":{"title":[["单源最短路径：优先考虑SPFA，被卡再考虑堆优化版dijkstra"]]},"created_time":1674976040833,"last_edited_time":1674976062834,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"2322dc5c-2fe2-4726-a19f-2d204bf860e9":{"role":"reader","value":{"id":"2322dc5c-2fe2-4726-a19f-2d204bf860e9","version":81,"type":"text","properties":{"title":[["多源最短路径：Floyd"]]},"created_time":1674976063086,"last_edited_time":1674976069150,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"b0eebf59-3972-43c2-960a-1be9598a6341":{"role":"reader","value":{"id":"b0eebf59-3972-43c2-960a-1be9598a6341","version":4,"type":"header","properties":{"title":[["参考"]]},"created_time":1674974851737,"last_edited_time":1674976040833,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"07a2443e-56e4-4741-9696-de6a9af81778":{"role":"reader","value":{"id":"07a2443e-56e4-4741-9696-de6a9af81778","version":14,"type":"text","properties":{"title":[["\n",[["b"]]],["AcWing 算法基础课",[["a","https://www.acwing.com/activity/content/punch_the_clock/11/"]]]]},"created_time":1674976023412,"last_edited_time":1674976028750,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}},"96eff80c-a79f-4686-86ea-8767657e1196":{"role":"reader","value":{"id":"96eff80c-a79f-4686-86ea-8767657e1196","version":4,"type":"text","created_time":1674976015734,"last_edited_time":1674976015738,"parent_id":"cf1ae05a-dc05-49ed-934b-adf97088cd5c","parent_table":"block","alive":true,"created_by_table":"notion_user","created_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","last_edited_by_table":"notion_user","last_edited_by_id":"83b4963a-e71e-4bac-9a62-dabfcb042aec","space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}}},"collection":{"a3ce75fe-7085-406b-a33f-74958ef7ee13":{"role":"reader","value":{"id":"a3ce75fe-7085-406b-a33f-74958ef7ee13","version":20,"name":[["NOBELIUM Template"]],"schema":{"NX\\Q":{"name":"date","type":"date"},"`gQ~":{"name":"type","type":"select","options":[{"id":"5aff2f95-fd1e-489b-8840-bf10bc9519cb","color":"purple","value":"Post"},{"id":"374d2bc6-a144-4832-8ca4-474aaae0ea1f","color":"orange","value":"Page"}]},"d]hq":{"name":"slug","type":"text"},"sD^m":{"name":"tags","type":"multi_select","options":[{"id":"149b2bfe-eff9-4a8e-a509-740376958f01","color":"orange","value":"计算机网络"},{"id":"fbfb28ff-2898-4f5b-a8e9-f18499a0f3da","color":"default","value":"Go"},{"id":"a7a581b6-5d07-466e-b0c8-69b6752bf06e","color":"gray","value":"数据库"},{"id":"7352dc92-14af-4c61-a6e4-1abfed244c4c","color":"purple","value":"算法"}]},"wz|S":{"name":"summary","type":"text"},"title":{"name":"title","type":"title"},"f211bdc0-ee00-4186-9a7d-f68c055ec2ee":{"name":"status","type":"select","options":[{"id":"22460321-fea2-4c7c-b352-a674760780ac","color":"orange","value":"Idea"},{"id":"41d5f5c6-b53c-42bc-8e0f-fc9402048480","color":"yellow","value":"Draft"},{"id":"c7390b31-9fab-4e21-94ee-7e67ea077a97","color":"blue","value":"Revise"},{"id":"7abc61d4-b405-480d-b699-12588755fa65","color":"red","value":"Published"}]}},"icon":"🎟️","format":{"copied_from_pointer":{"id":"dbf0f671-8075-49b9-b238-61e7eb9a7270","table":"collection","spaceId":"ac4cb96d-c8f8-4040-9bb2-868d9fc7f526"},"collection_page_properties":[{"visible":false,"property":"NX\\Q"},{"visible":false,"property":"d]hq"},{"visible":false,"property":"f211bdc0-ee00-4186-9a7d-f68c055ec2ee"},{"visible":false,"property":"sD^m"},{"visible":false,"property":"wz|S"},{"visible":false,"property":"`gQ~"}]},"parent_id":"1d21f050-c8c4-41f3-9fd4-8ff7de49c962","parent_table":"block","alive":true,"file_ids":["6cf3dc36-2f98-4f0e-9679-1bdbb1485129","5520bd92-e709-4c0d-ad58-06923f23f7e9","624d393a-62e3-4464-a1bf-1c79ecd4fbda","d52f6766-3e32-4c3d-8529-46e1f214360f"],"copied_from":"dbf0f671-8075-49b9-b238-61e7eb9a7270","migrated":true,"space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}}},"space":{},"collection_view":{"876cf270-3f6b-4f1a-b6c8-5ffbd27ca40f":{"role":"reader","value":{"id":"876cf270-3f6b-4f1a-b6c8-5ffbd27ca40f","version":26,"type":"table","name":"Default view","format":{"table_wrap":false,"table_properties":[{"width":416,"visible":true,"property":"title"},{"width":186,"visible":true,"property":"d]hq"},{"width":211,"visible":true,"property":"NX\\Q"},{"width":147,"visible":true,"property":"wz|S"},{"width":222,"visible":true,"property":"sD^m"},{"width":124,"visible":true,"property":"f211bdc0-ee00-4186-9a7d-f68c055ec2ee"},{"width":100,"visible":true,"property":"`gQ~"},{"width":200,"visible":true,"property":"gY~W"},{"width":200,"visible":true,"property":"pzWp"},{"visible":true,"property":"B;[p"}]},"parent_id":"1d21f050-c8c4-41f3-9fd4-8ff7de49c962","parent_table":"block","alive":true,"page_sort":["b1e1d645-db95-42e5-8995-39a80eda6460","e8cd3732-dc1c-43ae-959a-a5a611ec098a","e876558d-e878-47f6-8c95-21be678990a5","5a971ded-d3c5-41be-bef9-ddfff48d43a2","8db8b240-e1c5-4dd7-bf74-72584d7a2ce0","daf94ca4-ec56-47a3-84ed-b1e2479acc4b","d1a2db9b-6820-421e-9b80-017ce7478587","67ea9f83-b9f6-416b-afcb-7c64f7533e6c","45939470-9819-47e8-b12b-999cfefa0aad","c60dc33d-8efb-44be-a863-7a87ad047932","fe4b8d5f-7c49-42c6-a7d5-1cb71c4f7e86","b7233a67-c367-4198-831e-f12089568d1f","4f3bf306-92c4-41b7-a43e-957129a1240a","6a789607-66cf-498e-9b32-eb3fa69a84f4","c9429034-dabd-4a25-8782-97f20c808a60","38c49fe2-37f8-4a7f-a99f-9edb9ddad4c2","474eb638-9f6b-46bf-8004-77668293f199","81d6dfab-69cb-43a0-aa04-e9725f0b67e1","7703d956-84db-46cd-b538-48eae1af68b5","9f937c73-dac9-4ed7-9b01-beefcb321f16","3cf9dcb9-e7db-406c-80ab-c65c11fbf906","5827ab53-e051-455b-b90a-3bdc20158c2c","fa7acd3b-dea9-4fb1-b859-5345f35163c6","696dfc48-62c3-494d-96d0-ec5fa84637e8","79df93cf-9b10-452e-bc62-f39e8cd2d124","9bb8e52d-c459-4528-b1b3-c2378207253a","5da038ef-f419-4a11-aa48-587b3787e040","b4a2c9d4-6a2c-49e6-988d-89a538dfe0f6","c374a479-5cc7-4c54-ba69-6a4d76dc25ad","d470fa67-0e7c-40d8-86ac-9b5a8be88dc8","986be38b-9780-4bb9-bdcd-4e361ddbd888","b7613f56-c2d4-4aae-b967-b7471ade86d0","e357d1fc-7466-4d6a-8d48-71b76ea97cdc","e1735855-4089-4af6-bd4d-0d59f7a76cb4","9b34581a-955a-4229-99d0-8f2a6d0e69ce","b4414811-0599-45cf-b047-fa95eac42d89","c28a8a01-911a-40a2-a607-d3af8cb24017","461d07ae-4b4a-49de-bdcb-341af1153201","3df59023-cb68-4a65-afd1-7f0b8c21cb57","0e3223d1-03df-40fb-90f9-cc8559d776b5","4f45b7d6-cd5b-46ab-b2a6-37ae20bf5f21","fa475a21-5f38-43d4-9a89-67c40b3129ae","97cbc634-fe3a-4b9b-9da6-ac4aaa94772f","8a0d34bc-7e8c-4a68-88a5-5276274f612a","623f8788-a20f-45fd-bb82-08935f59b44d","7ee398f0-450b-47cb-9b53-f5e7736590d2","eae9f077-591e-4841-903b-db395513c834","367d0f2a-0b10-4dbb-b53a-613152f124f9","398e2e28-3997-49bc-a138-0467d4da8531","8aaf4633-e879-44dc-82c8-3c9fb9d3a6f8","1eb5e5f2-8dc9-4ffc-b5e1-09b67be27a83","83465fb9-205b-41fc-83a6-424692ee0a0e","fb1d18d0-6403-4e8a-840e-134553748ff5","4407cb77-3838-4ba5-b474-f15222cd3dba","1880b0f2-e036-42d0-9550-0fb08a962397","d8d60bd6-33f6-458f-a7d6-209ef2fb05a1","29bf65ff-888b-4a76-a8dd-bf54f02c3864","bad1d4ae-fd4a-4671-ae94-dd53d94e0eae","0d59792d-db1c-4ae7-8d7c-4f013be40dcf","337dc259-2805-4b1c-a60f-1b3e6c7badb8","4b1b21a8-c278-4bc6-88f1-1a35d407f4d7","7946aba2-d6d0-45ef-8779-23fa15db8f2d","c18dbce6-9e8c-4f4b-b74a-0994e7c1bc3f","84aa87b7-39e7-493c-87b9-5cae4de95449","1446eadb-8c01-4295-be3a-ecf19361c143","fe8a7d94-e9ba-457d-8f19-10fe53e6ca3c","98a5a0b6-b07b-4065-a73f-2949ad28ac47","38e3e030-5423-4343-b944-083b96fd8656","7dc3700b-1183-4e44-b4bb-cb500ae0b363","975051d4-ebbc-4b3f-98cf-1a52e5e4761d","e5d98bee-b2d5-4b45-ab0b-b77da24aebe7","acac2668-1062-4e7a-b095-eda067da8413","179025c4-d8a8-4c47-b621-9fd6a6f3339b","d256e5ed-5eac-43bb-a32e-581774962c23","3531b347-b0c9-406a-97ec-dc1233b52619","3760aeb0-084a-4e6d-88da-54a3c0311402","9c40a253-b9e8-42cd-8a99-62aaa9789a5e","f3c75b97-fd39-40bc-9473-2beb74d837b1","4d9edb9d-6ecd-4f3c-b41a-395987d6a714","c00f43c1-0fd5-45ca-a8af-e65a0bd6c990","9179759d-2b61-41a8-964e-23719e022b2d","19ad7e3a-2736-4d60-9516-6fcda35ed534","fe12b6af-37a2-4eab-a32f-5379fe881886","3634923c-2faf-4a31-a356-6ce9830706fb","6d9c82b0-2b20-425f-a87b-c9b14752bf9d","b57ebe77-5397-4ae8-b342-d19e3554f49c","1009ed18-593a-4ae7-8b32-7c39733138b5","d1d27099-40f0-4c1d-9c3b-a62349291ed2","f3ac9402-f3e4-4dc6-ae57-03d81bfd4e03","c1a9215b-4b3e-4d97-be31-f5d28736a065","8c80a9e1-a9d5-4b96-9a84-26df209c9537","ed91e3f2-5735-4c46-97db-aec5e6c4f597","7364073f-b7c8-436c-a471-779c7775fbf8","0f0ad844-b657-47c1-a04a-61d01ed706c1","6e55a5aa-680a-439d-add1-56498538aa64","7367ec26-da0a-441e-81b4-ae21068b94cf","48636b1e-62eb-449d-80db-68ee12d3caa8","f1c7db1e-871a-4529-9ba8-cd04f43979da","49477ffa-3ecf-49a3-a12d-62bea76192fc","1e50a8aa-3628-4b23-bd39-af65962e7061","fd0f48e9-d102-4502-9d06-94f78405f07a","51e53e64-e6dd-4fd6-8062-5d4455f0a1cb","f4ec684b-e5f1-44e9-a8a7-aca27f7ca6f3","177fa228-9099-4dd5-8969-c67f9c78bd0c","d5ab0d7a-0123-473f-84d4-81740defb9b4","548f6d36-c509-4b79-9c4b-59f227c7f550","c0901673-4f5e-4e51-ad87-0217f2d33a0c","0787f8d6-dc99-47c6-946e-2b008814bebc","0ade5216-1103-486a-aff0-a709ff825b02","a2c4dd21-985c-497d-b421-c2d8a9ec0eeb","908a498c-f7e3-4668-8afd-f179a027b4d9","4945e5c3-033d-467c-a8b3-b1479c1fdf0a","854f4584-28d5-43bd-938e-88d0957c78e3","6a6574f8-d63d-4fed-99c5-38f3df0364ac","baa9bf33-a11f-4da5-80eb-7930448aaad1","586d7983-2a0e-47ee-b80c-2800696255da","cf1ae05a-dc05-49ed-934b-adf97088cd5c","8cec23d1-4808-4ca8-9562-c98a44fa659c","918008b0-231b-4552-b752-e1f3dc35cbfc","24f98f49-407b-4f0c-b90b-7cb436c0063d","5625b2fb-6c82-4130-b336-0ec9a19d28ef","be5d776a-0cae-4ad0-b823-fc7c1371aca9","951d4753-cc76-4e10-9427-bc1517d34a8c","e7f7db5d-3e80-4afb-a4a8-4863c5302031","14b6937e-c536-48c7-95f8-b71b569ebc4d","ed276d45-3e91-40f4-b3f7-559061948489","0001a0d6-5549-4fc5-955f-57c356d6e87e","31a25d19-9261-43ad-b43e-a31d39f64545","7f5ff12b-b543-473c-9e05-bfba5d7dabff","69fd45e6-5797-4294-8c16-f0ba0a91ad5c","01ffb8be-f877-42b4-ba13-92ad393a7e6c","060867a6-c2c6-4a7c-a282-403e4081d6e4","e8704a7f-e816-4458-ae8a-0f9bc9f144b5","bbb78d74-fe80-4da0-9585-a2ef20ab4d1a","e6582267-a054-41b3-80ab-fb860956d3c5","91edf54b-8f96-4f4f-a127-f0b6435a56eb","a2a7b7e4-7286-4510-8576-cc45b70de00a"],"query2":{"filter":{"operator":"and"},"aggregations":[{"property":"title","aggregator":"count"}]},"space_id":"e7bb21a8-53c5-4141-a2a6-9c3a436ecfe4"}}},"notion_user":{},"collection_query":{},"signed_urls":{"570427a1-44dd-40c2-8e3d-c16b095e4cd0":"https://s3.us-west-2.amazonaws.com/secure.notion-static.com/e045bf49-c643-450c-84cb-8d7e80f87827/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Content-Sha256=UNSIGNED-PAYLOAD\u0026X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230129%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20230129T095041Z\u0026X-Amz-Expires=86400\u0026X-Amz-Signature=5fc0447ba6764ada16799711df7dd794637d8e79c93367f988fd75bc011ee10b\u0026X-Amz-SignedHeaders=host\u0026x-id=GetObject","35456df6-3219-4f62-a1dc-14bf4c45eea8":"https://s3.us-west-2.amazonaws.com/secure.notion-static.com/844bb17e-a37b-4d92-b968-91b56af5972a/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Content-Sha256=UNSIGNED-PAYLOAD\u0026X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230129%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20230129T095041Z\u0026X-Amz-Expires=86400\u0026X-Amz-Signature=f86bdd02b405a7c487607204912c6f398ec59d020f03e928ecd4622795b4b43d\u0026X-Amz-SignedHeaders=host\u0026x-id=GetObject"}},"emailHash":"c8089598dc27a7944c95a8ed30867b78"},"__N_SSG":true},"page":"/[slug]","query":{"slug":"short-path-problem"},"buildId":"JKkGUEINve2JoC-CStCvR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>