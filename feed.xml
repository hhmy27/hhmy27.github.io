<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>hhmy 的博客</title>
        <link>https://hhmy27.github.io//</link>
        <description>test</description>
        <lastBuildDate>Fri, 16 Dec 2022 10:53:43 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh-CN</language>
        <copyright>All rights reserved 2022, hhmy</copyright>
        <item>
            <title><![CDATA[CS144 - lab 1]]></title>
            <link>https://hhmy27.github.io//cs144-lab1</link>
            <guid>https://hhmy27.github.io//cs144-lab1</guid>
            <pubDate>Tue, 29 Nov 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-24f98f49407b4f0cb90b7cb436c0063d"><div class="notion-viewport"></div><div class="notion-table-of-contents notion-gray notion-block-38685b58af934811933e64fc1cf959b5"><a href="#2464eaef513d4f4a9fc313e9ab3b8fc3" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">简介</span></a><a href="#36a7c264312a414ba64ccf59e5ed59c2" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">2 Getting started</span></a><a href="#5d78756550fb4194a54775abfad103cf" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">3 Putting substrings in sequence</span></a><a href="#2928d819d35f444baca10c678105fae0" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">3.1 What’s the “capacity”?</span></a><a href="#f6fb2e68f4234d3fa55f57415fe81488" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">分析和设计</span></a><a href="#32cb590933924546932c5a057b42a831" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">实验结果</span></a><a href="#86123e58279242d6a47ea320bda54488" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">一些容易忽略的点</span></a><a href="#70381c645a4346af856c36a7f362fb74" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">总结</span></a></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-2464eaef513d4f4a9fc313e9ab3b8fc3" data-id="2464eaef513d4f4a9fc313e9ab3b8fc3"><span><div id="2464eaef513d4f4a9fc313e9ab3b8fc3" class="notion-header-anchor"></div><a class="notion-hash-link" href="#2464eaef513d4f4a9fc313e9ab3b8fc3" title="简介"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">简介</span></span></h2><blockquote class="notion-quote notion-block-1494e91f6062435386e62c970c894ad8">本文只是学习笔记，文中不会公布代码，只是记录自己的实现思路，如果不符合约定或规范，请联系我删除。</blockquote><div class="notion-text notion-block-e767a0021ad5439680eb2b7d4096e743">本次lab 对应到 week 3。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-f0847288ba494a13bc593819d1ee98d3"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fac558c1f-e369-4f07-bfb1-37f60ed4474f%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D09932c96dc5203d77ac082c0fcd3dc59b1d7c891a2161b64a192d63ab2dd9275%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=f0847288-ba49-4a13-bc59-3819d1ee98d3&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-a1c6f2a3f209493dabaf44c9acc12b5b">week 3 的 slide 讲的都是包交换（packet switching）技术，这里记录一下基本概念：</div><ul class="notion-list notion-list-disc notion-block-72499b0e9ae64992bcc9e0f30d77a106"><li>包交换技术</li></ul><div class="notion-text notion-block-cf3a68444ee9445dac65db9936d269c5">数据从http ⇒ tcp ⇒ ip层层封装然后<b>交给路由器转发到目的地</b></div><ul class="notion-list notion-list-disc notion-block-cd99503c3c1c4c4abd6ead49eac77eb7"><li>Delay</li><ul class="notion-list notion-list-disc notion-block-cd99503c3c1c4c4abd6ead49eac77eb7"><div class="notion-text notion-block-7431d7fa247e46e68a8b3acaccfd535d">使用路由交换技术不可避免的延迟：</div><li>链接上固定的传播延迟。 <b>Propagation delay along the links (fixed)</b></li><li>数据打包的固定延迟。<b>Packetization delay to place packets onto links (fixed</b>)</li><li>路由器数据包缓冲区中的排队延迟. <b>Queueing delay in the packet buffers of the routers (variable)</b></li></ul></ul><ul class="notion-list notion-list-disc notion-block-ad161ae4fa6c4f6ba11db5171d3c2c23"><li>缓冲区</li></ul><div class="notion-text notion-block-3a86a832fbf049e8abc36fec4258b796">网络环境是有波动的，如下图：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-c14b123787b84cab9e226cb72b6d1e0c"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:720px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7fa5a5a6-678f-44dd-9479-9e0ebfbd4a24%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3De542e707730ed4f0e924aa467eda832bf68c06856f9cf605ba4984d10b5c6610%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=c14b1237-87b8-4cab-9e22-6cb72b6d1e0c&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-cdc7e31cefe0476db8907251323920e2">发送的bytes和时间的曲线可能会产生波动，为此缓冲区可以缓解这些波动带来的影响。缓冲区可以将部分数据缓存起来，避免丢失。</div><div class="notion-text notion-block-4893d7dee6e446d1825f6040fb9a0749">这次lab的任务是完成StreamReassembler部分</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-f016818982d2408ea1ac717011a4b0f9"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8d435ace-5442-4752-b834-e47d9a0b604e%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Dc83ea42544e465d8bf55302a21dd6f00214946d834b033d395c499d522cdc9dd%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=f0168189-82d2-408e-a1ac-717011a4b0f9&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-f105eca764db49b28ee2b6d9c1281942">同时说明了我们每个 lab 需要做的任务</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-496144abddf84510a2518bef166b2e81"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F422080c5-585d-48cf-8b70-127895829c42%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D8dd653f5f088e8f19229dc764aeb7ebc197082e5378bb068824ae69723973d85%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=496144ab-ddf8-4510-a251-8bef166b2e81&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-36a7c264312a414ba64ccf59e5ed59c2" data-id="36a7c264312a414ba64ccf59e5ed59c2"><span><div id="36a7c264312a414ba64ccf59e5ed59c2" class="notion-header-anchor"></div><a class="notion-hash-link" href="#36a7c264312a414ba64ccf59e5ed59c2" title="2 Getting started"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>2 Getting started</b></span></span></h2><div class="notion-text notion-block-ec300c7525814760a58f2172a7fd257d">这边要求我们合并远程的 lab1-startercode 代码再继续工作。</div><div class="notion-text notion-block-c3788d3c7b1d4c88861984be02255557">我一开始没搞清楚这个 lab 的 git 分支逻辑，然后尝试了几次才搞清楚。</div><div class="notion-text notion-block-1ba7334eb5614647a287841b038dcd16">这个 lab 的每一个分支都对应一个lab</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-1b779991610747f19280203ac0a68ca4"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:288px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Feb189974-c31e-49f5-9ce6-5af20c957f94%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Da6f262af71767f9f99b378b4e487ddd29709f89fdeff20aec46fe419c12894e7%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=1b779991-6107-47f1-9280-203ac0a68ca4&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-75e2ab1545ff43c689c79cc1205eff35">我们每完成一个分支，都要保存下来，然后在完成的工作基础上合并新的<code class="notion-inline-code">labx-startercode</code> 进行开发。</div><div class="notion-text notion-block-5f8e2cd6fb034359a41a99e1415b207a">比如说我自己的仓库有 master，我开了一个 lab0 的分支，然后完成了 lab0 的测试。</div><div class="notion-text notion-block-c1ed9310ae2f463299ccfe6ff526bd39">接着我从 lab0 checkout 出来一个 lab1 的分支，然后 <code class="notion-inline-code">merge lab1-startercode</code> 到这个新的 lab1 分支上，完成 lab1 的任务，以此类推</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-6f35cd418ebd4bcfbd95136a591fb379"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F675be5d9-92da-4959-b754-2a510f6dc36f%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Dbe856f286c1dd8ead3db1cc543fcacafc951510f45d59cbe6dd3058f725a52b3%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=6f35cd41-8ebd-4bcf-bd95-136a591fb379&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-7a2494f5242b4a04b1476f9a73f5cbc8">示意图大概就是这样</div><div class="notion-text notion-block-c9c53682c2454e2d82b255193bdad16c">当然这是我自己的 git 风格，你可以在原始的 master 上进行迭代开发，而我习惯每进行一个 lab 都创建一个新的分支</div><div class="notion-text notion-block-a6976469b5674e30be8b39b4f9ce9bae">ok，搞定之后我们看需求</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-5d78756550fb4194a54775abfad103cf" data-id="5d78756550fb4194a54775abfad103cf"><span><div id="5d78756550fb4194a54775abfad103cf" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5d78756550fb4194a54775abfad103cf" title="3 Putting substrings in sequence"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">3 Putting substrings in sequence</span></span></h2><div class="notion-text notion-block-1d12b2ba49e347139b1e5e0d53de2611">在 lab1 和 lab2 我们将要实现 TCP receiver，它能够接受数据报文并且将它们转换为可靠的字节流供应用程序从 socket 中读取数据。</div><div class="notion-text notion-block-0943ecfa83394e4ab9adf0726b81802b">TCP sender 将字节流分割为多个 segments，每个子串最大长度不超过 1460 bytes。网络是不稳定的，可能会产生乱序、丢失、重复提交等这些工作。receiver 必须要充足这些 segments 以实现可靠的字节流（reliable byte stream）</div><div class="notion-text notion-block-f325ec46b4ea44e0a6424c1957df00c1">本次 lab 的工作就是实现 <b>StreamReassmbler</b></div><ul class="notion-list notion-list-disc notion-block-9a7b111896924bc7970e905d0a2774d9"><li>接收 substrings，包括了组成 string 的 bytes，还有 string 在 stream 中 的唯一 index。这些数据可能是乱序的，需要我们组装起来</li></ul><ul class="notion-list notion-list-disc notion-block-b7c89a2033be41e8b213bc39f9a76341"><li>使用 ByteStream 作为输出，有序的把 bytes 写入到 ByteStream 中</li></ul><div class="notion-text notion-block-590bfd84e6db4b50afca15538f722fed">然后文档也给出了需要实现的接口，同时强调了 <b>StreamReassmbler </b>实现的是 TCP 的可靠性：从任意字节数据中恢复出原有的数据流，用此来对抗网络波动产生的丢失、复制等结果。</div><div class="notion-text notion-block-13dc1185f5ef4340aa0041cdf084695d">接口说明在<code class="notion-inline-code">stream_reassembler.hh</code> </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-2928d819d35f444baca10c678105fae0" data-id="2928d819d35f444baca10c678105fae0"><span><div id="2928d819d35f444baca10c678105fae0" class="notion-header-anchor"></div><a class="notion-hash-link" href="#2928d819d35f444baca10c678105fae0" title="3.1 What’s the “capacity”?"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">3.1 <b>What’s the “capacity”?</b></span></span></h3><div class="notion-text notion-block-7a8e2bad977b4d1eac6a33865c8cba9f">主要是定义了 capacity 的含义：</div><ul class="notion-list notion-list-disc notion-block-2209abe6d5da4a15a78ddf720472cd9d"><li>一方面是限制了 ByteStream 的大小</li></ul><ul class="notion-list notion-list-disc notion-block-3522a643c7904241b6e4761b54ea9ecc"><li>另一方面限制了从 substrings 中读取的最大 bytes 数</li></ul><div class="notion-text notion-block-3c725c1b070143aeb9a0a73440056fd4">比如下面这种图</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-8f96a543e8e74de28c7b58027d1ca647"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5643bc4a-1688-4992-94d3-b92d373525f2%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D87d67ae82f3f1e38dc7d5bc8268a92b44bb73d734f14e437cc161878d6d50da0%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=8f96a543-e8e7-4de2-8c7b-58027d1ca647&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-42a65f5438d641d0a91a1c11965e101d">蓝色部分指的是已经处理完的数据，绿色部分指的是在 ByteStream 中的数据，红色部分指的是还没有放入 ByteStream 的部分，后面的部分就是还没开始处理的数据</div><hr class="notion-hr notion-block-4db1f94e9f7046b6a6f986cc93d4652d"/><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-f6fb2e68f4234d3fa55f57415fe81488" data-id="f6fb2e68f4234d3fa55f57415fe81488"><span><div id="f6fb2e68f4234d3fa55f57415fe81488" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f6fb2e68f4234d3fa55f57415fe81488" title="分析和设计"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">分析和设计</span></span></h2><div class="notion-text notion-block-1415c3abb6a04722b42a6245c3bbccba">我们最终要设计的结构如下所示：</div><ul class="notion-list notion-list-disc notion-block-3ef352184e7849d9adb89a5899b8ea64"><li>有一个 buffer 帮助我们缓存不能立即放入 ByteStream 的数据</li></ul><ul class="notion-list notion-list-disc notion-block-eb5d8dd963e6425c9a9ce0e7610fc9e0"><li>一个 ByteStream 供读写</li></ul><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-2dc4970548544397812a94342a0dfa48"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4ec99f2d-fb4c-40dc-805b-e197e07ea7e3%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D2971ae616496a4cb151c01bddbbdefd67274e704f63e21c39a8f220d286ef9d5%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=2dc49705-4854-4397-812a-94342a0dfa48&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-ba8e027386524cbe89cc24cbca088566">特别的我们需要注意这种情况：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-ae40e67c049d4bf68c0051f969d937a6"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa97bdd9a-18fe-4972-b13a-7d11344caa68%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D9d848c8ce478fce9581abba8f5584e82a3a373afe0a0fad1acdef92c3c608f0d%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=ae40e67c-049d-4bf6-8c00-51f969d937a6&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-cfb3a9269f6846ca9d094251223d7efe">假设我们读入 5 和 6，那么后面的三个 bytes 也应该一并放入 ByteStream 中</div><div class="notion-text notion-block-bb706686401245be82ea31cca5e9d7bc">然后我们需要合并 buffer 中的 bytes，例如：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-4d0f392f1e5f429f850efed1a438f94e"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:654px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6e46f64a-9189-45f0-9d23-a3e076a7853d%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D0bede08a85d783b2ea1c57fb6cea5f28a4b81488fd52b0f0bf4974c8e9f474de%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=4d0f392f-1e5f-429f-850e-fed1a438f94e&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-f46abb36a1cb4f389dd8f58120329425">如果某次输入中带有10、11，例如 index = 7，data = “aaaa”，那么 7 ~ 12 的数据应该立即合并 </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-32cb590933924546932c5a057b42a831" data-id="32cb590933924546932c5a057b42a831"><span><div id="32cb590933924546932c5a057b42a831" class="notion-header-anchor"></div><a class="notion-hash-link" href="#32cb590933924546932c5a057b42a831" title="实验结果"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">实验结果</span></span></h2><div class="notion-text notion-block-3c70c6a916134d1fb81251c0a174c7f0"><b>第一次尝试</b></div><div class="notion-text notion-block-090101710872419881e2775351b898e4">第一个版本，用 set 来标记出现过的 index，用 map 来作为缓冲区，每次<code class="notion-inline-code">push_substring</code>的时候都先往 map 里面放，然后再尝试从 map 里面取 byte 放到 ByteStream 里面</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-3110489d12c441b6856c17429559b2c4"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fab6ed6db-ff2c-456a-b4a5-6d5b4e88a893%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D700cf8f693965cdc2d28be51dd1b41ce9d200b0818e841c44e2af45b69bb2e22%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=3110489d-12c4-41b6-856c-17429559b2c4&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-d8a9dd2590e742f7bc7183c195e427bb">虽然通过了本地测试，但是性能比较糟糕。</div><div class="notion-text notion-block-2bb26587bcc848bf8023a2d213a6243f">首先是按照 byte 插入 buffer 性能太低了，然后用 set 标记使用过的 index 是没有必要的，因为最终表示的字节流是一致的，我当时写的时候没有注意到这一点</div><div class="notion-text notion-block-d4be93c78a3a44daafbaa4e47f78f4ea"><b>第二次尝试</b></div><div class="notion-text notion-block-e6a09b3630024e17ac4fcdffb8eddda3">经过第一次尝试，现在问题清晰很多了，问题本质就是一个算法问题：</div><div class="notion-text notion-block-de2d26d89fe94f1f93b1942a11751e5a">对于一大段的 bytes，有多个切片（线段），切片之间可能重叠，每次输入会提供一个切片和起点，对于能够立即写入的切片，应该马上写入到 ByteStream 中，不能写入的切片应该暂存，但是需要丢弃容量之外的 bytes。</div><div class="notion-text notion-block-2af8702f3fe14a218d9fbeddfeafcb78">显然我们从线段的角度考虑更优，这里的线段可能会重叠、乱序、重复，但是它们表示的 bytes 都是<b>一致</b>的，这个性质很重要。</div><div class="notion-text notion-block-c1c6736c4ff645ecb4d19f7e77794429">对于这个角度，我最先想到用堆来处理，每次都把一个 node: &lt;index, slice&gt; 放置到堆中，然后尝试将堆顶写入到 ByteSteam 中。但是用堆经过若干次插入后可能会变得很冗余，也就是线段重叠的部分会很多，这是不符合设计的（lab1 的 FAQs 也有说明）。</div><div class="notion-text notion-block-395f1d45c7bf41d483616b984ac1d420">于是可以在堆上进一步尝试，我们根据 node 的 index 作为第一索引，存放到一个有序的数据结构中，我们对这个数据结构的要求是：node 之间没有重叠的部分。</div><div class="notion-text notion-block-15e66d2bc0fc42c08e8bee34dc7e7195">那么在 <code class="notion-inline-code">push_substring</code> 的时候，对于当前的 node，我们可以检查它前后的 node 是否能合并，如果能合并则消除重叠部分，直到不能合并为止。这样能够保证数据结构中的 node 都是无重叠的。显然用二叉排序树能够很好的满足我们的要求，还可以用二分来加快查找过程。在 cpp 里面，set 的底层是红黑树，使用起来很方便。</div><div class="notion-text notion-block-08bf70fac87a4053aa5c78c036b8518f">这个核心数据结构想明白之后，接下来的实现就简单了。</div><div class="notion-text notion-block-ba3ba3bc670947178cdd4d08720b2688"><code class="notion-inline-code">push_substring</code>的流程</div><ol start="1" class="notion-list notion-list-numbered notion-block-17d9352e30804dcab8acf581bd0413b4"><li><b>检查是否越界</b></li><ol class="notion-list notion-list-numbered notion-block-17d9352e30804dcab8acf581bd0413b4"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-a46a23f26d96450d869aa1909e954a42"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:432px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F639b4d70-a38c-4ecd-ba99-a4054f794689%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Def3f07f4589f33211262eed19962861bedad06e13791111a2122cfd4665dc69e%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=a46a23f2-6d96-450d-869a-a1909e954a42&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-ccdd77bfd67d4175b9c1f92238e64755">假设 recv_index_ 是期望接收的第一个 index，而 last_store_index_ 是最后不能接收的字符（index = 0，cap = 8 时，last_store_index_ = 8）</div><div class="notion-text notion-block-b9bda57951514598861aa0a15891f877">那么从图中来看，我们需要丢弃 1 和 5 两种情况</div></ol></ol><ol start="2" class="notion-list notion-list-numbered notion-block-34245907fb6e472abab98e52e9be6f28"><li><b>裁剪线段</b></li><ol class="notion-list notion-list-numbered notion-block-34245907fb6e472abab98e52e9be6f28"><div class="notion-text notion-block-c868384ce1954f04a2c91e0398b6d919">根据上图，2 和 4 都需要裁剪出处于区间的部分，3不用裁剪</div><div class="notion-text notion-block-8e6b2ccd48c547fdaf26a57efdab0d92">特别的，4 需要我们进行 eof 的判断，如果 4 是 eof 的，那么此时这个 eof 指令是无效的，因为最后的字符被裁剪掉了</div><div class="notion-text notion-block-1c991e9a897b4ac3b7d68b88c17d2b3b">另外我们还需要考虑一种完全覆盖区间的情况，即 2 + 3 + 4，这中情况即需要裁剪头部，也需要裁剪尾部，因此我们不能用<code class="notion-inline-code"> if … else … </code> 进行处理</div></ol></ol><ol start="3" class="notion-list notion-list-numbered notion-block-9af50f63abdf414e842f9a578da509a7"><li><b>在树中合并</b></li><ol class="notion-list notion-list-numbered notion-block-9af50f63abdf414e842f9a578da509a7"><div class="notion-text notion-block-c19cc13c493f4c2192ab61f2aec6d278">由于最终指向的 bytes 是<b>一致</b>的，我们处理起来的难度大大降低了</div><div class="notion-text notion-block-1da6676e8b544f02aeb99ecaaa2b678a">现在我们得到了经过裁剪后的 node，我们想要把它插入到树中，保持树中 node 无重叠的性质，那么就需要我们对树的 node 进行合并。</div><div class="notion-text notion-block-a4045a44b82e4d4ab8c253521f6ee01a">先是<span class="notion-inline-underscore">向后合并</span></div><div class="notion-text notion-block-2b1394627de14971918bcd761f1849d1">我们根据lower_bound，找到结构中对应的下一个 node，判断两个 node 的位置关系</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-5d95961eecb148e6b1496d58fec8a176"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6b0dd19f-81ef-4fa3-b574-405d29cfada9%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Df288357f4ee208a08cdad81f691c0db9266dd6a015fa312d76e97ce6675294e8%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=5d95961e-ecb1-48e6-b149-6d58fec8a176&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-9a2d9f9eb6c94b859f6af21c9ca9c496">由上图我们可以总结出三种类型的位置关系，分别是重叠、不重叠、覆盖</div><li>case 1，如果不重叠，退出向后合并</li><li>case 3，如果覆盖，把被覆盖的线段移除，因为当前线段能够表示被覆盖的线段了，继续向后合并</li><li>case 2，如果重叠，那么合并两条线段，移除下一条线段，继续向后合并</li><div class="notion-text notion-block-5aca1b0969224717871d75396aaf9474">向后合并完毕后，考虑<span class="notion-inline-underscore">向前合并</span></div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-82efe1eadd5f4e9bacee20cfce1fd0ea"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff4ac74d5-f942-4cde-bf40-b3d3123e68ca%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D2a7bb0371389205789de3c60423a6a1fc5c9b529ce796b73545119607b03910d%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=82efe1ea-dd5f-4e9b-acee-20cfce1fd0ea&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-04ef57f9f96143ee8d67a70d1333782c">情况也是一样的</div><div class="notion-text notion-block-ad901e06be9b4cb4879a63c3c2711b91">那么经过最终的前后合并，树中的 node 都是无重叠的了</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-ab916ff859ba45669e4216fae2b0bfe5"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa706dbbe-5a9f-48e6-b167-e491d890c16a%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D59053824de62a9bbd9edd8e9d8dbb7165e01504d4433a603a5627ae331c91ca2%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=ab916ff8-59ba-4566-9e42-16fae2b0bfe5&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure></ol></ol><ol start="4" class="notion-list notion-list-numbered notion-block-7bf202a2d5d341b7bf35415092cc03bb"><li>尝试写入 ByteStream</li><ol class="notion-list notion-list-numbered notion-block-7bf202a2d5d341b7bf35415092cc03bb"><div class="notion-text notion-block-1ff70bc0beb047c2b16601beb3a80ebc">当我们树中第一个 node 的 index，恰好等于 recv_index_ 的时候，就能进行写入了</div></ol></ol><ol start="5" class="notion-list notion-list-numbered notion-block-2dd80ecd1fc947558a2b2368a22fa6a7"><li>eof 的处理</li><ol class="notion-list notion-list-numbered notion-block-2dd80ecd1fc947558a2b2368a22fa6a7"><div class="notion-text notion-block-6ccb6e2ccfa742c59cfb5d4581ce36b9">我们先考虑一下 eof 什么时候是有效的，当且仅当 eof = true 且 最后一个字符被读入的时候就是有效的。那么回到最原始的这张图</div></ol></ol><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-ae351a62e5af42e094d12168085e2b85"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:432px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F639b4d70-a38c-4ecd-ba99-a4054f794689%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Def3f07f4589f33211262eed19962861bedad06e13791111a2122cfd4665dc69e%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=ae351a62-e5af-42e0-94d1-2168085e2b85&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-f2bb1526c4004087afcccc51ffb9543b">对于 2 和 3，它们的 eof 都是有效的，对于 4 和 5，它们的 eof 都是无效的，因为最后一个字符被丢弃了，而对于 1 呢，测试用例并没有体现，我也把它视为无效的情况了。</div><div class="notion-text notion-block-ddbb3ede3de840dc957043724cdc45bd">最终通过了测试，满足了 lab 1 的 0.5 s 性能需求</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-d0f80dde68394e5185b0e042c9779093"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb1826731-6b64-4784-86e5-7a93f69aeb16%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D9c9ae156bd23693eb3a57dbdaad65abb5932581dafd9a5e88280cbea2d0c913f%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=d0f80dde-6839-4e51-85b0-e042c9779093&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-86123e58279242d6a47ea320bda54488" data-id="86123e58279242d6a47ea320bda54488"><span><div id="86123e58279242d6a47ea320bda54488" class="notion-header-anchor"></div><a class="notion-hash-link" href="#86123e58279242d6a47ea320bda54488" title="一些容易忽略的点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">一些容易忽略的点</span></span></h2><div class="notion-text notion-block-5d8cb5b264c84ed49bb5a67aca3fdab3">一定要认真看 3.2 FAQs</div><ul class="notion-list notion-list-disc notion-block-b7a738f948c142fd85c978778dd88754"><li>切片表示的最终的 bytes 是一致的</li></ul><div class="notion-text notion-block-0b077300d1314936b5b380952a0d13f8">在 3.2 FAQs 中提到了</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-ebd9629687eb4023a7f5bf7eb9c38b74"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbe83fba7-6f5f-4c8e-aca9-40a2026b4797%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D731d1a6949b1e05bde60de762a5878570a0a097fe6bc6b73aa896ea43bc831cb%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=ebd96296-87eb-4023-a7f5-bf7eb9c38b74&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><ul class="notion-list notion-list-disc notion-block-77316f0f769344e59296447d966230ea"><li>buffer 中的最好不要存储重叠的子串</li></ul><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-08d94e185652479bae9b082d0f4dc154"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9facd4b5-4ace-48d0-9a97-b6b6b5c3c9f6%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D573a7f56731ac57df34077501911d25098d5b43b8bef60746b5ee2568cb20f2d%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=08d94e18-5652-479b-ae9b-082d0f4dc154&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><ul class="notion-list notion-list-disc notion-block-f3ceb975da7b4ba3b0dfd979314a39f6"><li>注意计算 first unassembled 和 first unacceptable</li></ul><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-a2822dc2866c4ce18b5557a03e02afb6"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3d02df14-3489-43e6-99d4-ac75f4f08f14%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105339Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Df3440b978362cc4cf272dd8149dbc7847a01c67bd4f651bbe12b8b2187c4b2db%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=a2822dc2-866c-4ce1-8b55-57a03e02afb6&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><ul class="notion-list notion-list-disc notion-block-fbe357bb5a3043d4bdaf1afc82f6bb91"><li>有些不确定的地方，看测试用例确定应该怎么处理</li></ul><div class="notion-text notion-block-eb3826b21d204061abe77fcbead46837">如果还不能确定，就自己约定一个一致的风格好了</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-70381c645a4346af856c36a7f362fb74" data-id="70381c645a4346af856c36a7f362fb74"><span><div id="70381c645a4346af856c36a7f362fb74" class="notion-header-anchor"></div><a class="notion-hash-link" href="#70381c645a4346af856c36a7f362fb74" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h2><div class="notion-text notion-block-ce3bbdfe2150423690b5f4dd7967b7ee">其实这个 lab1 总结出来后就是一个算法问题了，比较考验学生的算法能力。</div><div class="notion-text notion-block-b1481780a1f0456abc032415c3d2a193">整个<code class="notion-inline-code">StreamReassembler</code>实现的功能更能很像上计网课的时候讲到的滑动窗口，没想到是这种数据结构实现的。</div><div class="notion-text notion-block-d15b71d5e3224722a8da35f356c7b319"><b>debug</b></div><div class="notion-text notion-block-6e9c812d262a4ae1a22c14aad3aa2730">coding 途中我遇到了不稳定复现的 bug，而且由于没有好用的调试工具（或者说自己暂时没学会如何更好地调试 cpp），导致 debug 非常困难
不过好在最终成功 debug 了，下面是我的一些心得：</div><ul class="notion-list notion-list-disc notion-block-da424da1585c414f8e29380322f7896e"><li>计算机不会骗人，不要怀着“我的代码没问题啊”这种心态去 debug，不然自己很容易崩溃</li></ul><ul class="notion-list notion-list-disc notion-block-ee6a996b3e8e4ebda98faebee9eed0ab"><li>高效的 debug 工具非常重要，能帮你节省很多时间</li><ul class="notion-list notion-list-disc notion-block-ee6a996b3e8e4ebda98faebee9eed0ab"><li>尽量让自己的工作自动化，能够节省很多时间</li></ul></ul><ul class="notion-list notion-list-disc notion-block-0b2f6e5fdb6044c58a12db6cacebc4d4"><li>想办法弄到导致 bug 的数据，如果没办法弄到，观察日志分析走到哪一步导致不符合预期的结果，然后根据调用链跟进</li></ul><div class="notion-blank notion-block-7363e8255a774012b432db2b084971ed"> </div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Go channel 小结]]></title>
            <link>https://hhmy27.github.io//go-channel</link>
            <guid>https://hhmy27.github.io//go-channel</guid>
            <pubDate>Tue, 29 Nov 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-5625b2fb6c824130b3360ec9a19d28ef"><div class="notion-viewport"></div><div class="notion-table-of-contents notion-gray notion-block-dd19b74c09914037add791435eeeb4e3"><a href="#cb6912ad9f904db489bd7e660c6d6558" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">简介</span></a><a href="#35b8e4af272c49669ae1944bc4de8d66" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">初始化</span></a><a href="#4a044f168f98418fbf4b554d9f7ab691" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">channel 的使用</span></a><a href="#e689bcabb635420f97b72ece1c8e620c" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">遍历</span></a><a href="#0492324d62704c528055fc03f3e5e583" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">select</span></a><a href="#d23480cc11e94cdc85fe812a45f69bb3" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">通道的限制</span></a><a href="#39e8470d5ffc43eb80fe8855cb185f5c" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">通道的关闭和异常</span></a><a href="#622603a1a46c4a239ae1760fb6bd08d0" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">源码分析</span></a><a href="#440692534dd5466d976e286b6f96ecb6" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">Ref</span></a></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-cb6912ad9f904db489bd7e660c6d6558" data-id="cb6912ad9f904db489bd7e660c6d6558"><span><div id="cb6912ad9f904db489bd7e660c6d6558" class="notion-header-anchor"></div><a class="notion-hash-link" href="#cb6912ad9f904db489bd7e660c6d6558" title="简介"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">简介</span></span></h2><blockquote class="notion-quote notion-block-ce4eedd60c1f4a258125b344b2c2f0eb">使用通信(channel)来共享内存，而不是通过共享内存来通信</blockquote><div class="notion-text notion-block-e5619cb1c99e4a62b667ebd4c97d8351">channel 可以用于实现一个生产者消费者模型，用于生产者和消费者之间共享数据</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-92cab5571b7f440084483908167acc2e"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2a1fa1f5-d64f-45f5-9d9f-b2c513e17cfa%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Dbc0836886a12cd5235080afa0070065f1ff158bde42b8eb60c08c2c350df4445%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=92cab557-1b7f-4400-8448-3908167acc2e&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-4e2ee7852ec442008f67aa758f989d28">日常使用中，我们可以用来做 goruntine 的同步，channel 使用简单效果可靠，下面来看看如何 channel 吧</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-35b8e4af272c49669ae1944bc4de8d66" data-id="35b8e4af272c49669ae1944bc4de8d66"><span><div id="35b8e4af272c49669ae1944bc4de8d66" class="notion-header-anchor"></div><a class="notion-hash-link" href="#35b8e4af272c49669ae1944bc4de8d66" title="初始化"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">初始化</span></span></h2><div class="notion-text notion-block-a4d9ba7ebf6a4fb29e12ad16851e12e8">使用 make 来初始化一个 channel，channel 支持多种类型元素</div><blockquote class="notion-quote notion-block-fc8fe9c06c004178b327bcdf536e751a">除了 channel 以外，make 还可以用来初始化 slice、map</blockquote><pre class="notion-code language-go"><code class="language-go"><span class="token literal-property property">ch1</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan int<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// 初始化一个大小为 3 的 channel</span>
<span class="token literal-property property">ch2</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan int<span class="token punctuation">)</span>    <span class="token comment">// 初始化一个无缓冲的 channel</span></code></pre><div class="notion-text notion-block-a8736c6747af415280b2001410f585c7">channel 根据我们初始化的大小分为有缓冲 channel 和无缓冲 channel</div><div class="notion-text notion-block-6d594fd267944fef9035e0c52a132e21"><b>有缓冲 channel</b></div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-a43517fcb3e5480b96a47777591c41a0"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F61dd0dd3-79a3-4e44-ab24-68b8d43fe1e3%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D689c0607e97d999adeeb7b3eeb82d99b88b5e08c46564a0234751d36e0ac4ad5%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=a43517fc-b3e5-480b-96a4-7777591c41a0&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-5f69223dad1c40cb851291adf56f471d">这种 channel，就相当于生产者消费者模型里面的缓冲队列，在这里我们初始化了大小为 3 的队列。</div><div class="notion-text notion-block-2abc01eabeff4837aa9f60d39e95bd6c">这种有缓冲队列的最大特点是<b>异步</b>，生产者和消费者之间不必同步执行。但是也会引起阻塞：</div><ul class="notion-list notion-list-disc notion-block-bb6cc21bf9dc4fe3ab0322d5e9d2904f"><li>队列满时生产者阻塞</li></ul><ul class="notion-list notion-list-disc notion-block-32396addcdd04f598601b3aac4502c36"><li>队列空时消费者阻塞</li></ul><div class="notion-text notion-block-5d84710d30c444ca825821f42e34bbae">队列未满且存有一定数据的时候，生产者和消费者可以各司其职的完成存取。</div><div class="notion-text notion-block-fdb654979f114d6f8a172fd3b738b01c">举一个生活中的例子，有缓冲的 channel 相当于信箱，信箱未满的时候邮差直接把信件放到信箱里面就行了，而我们可以随时去检查信箱取出信件。（这里其实不太准确，日常生活中我们检查如果空信箱的话直接走掉了，但是程序中如果 channel 是空的话等待的 goroutine 是会被阻塞的，举这个例子只是为了突出异步的特点。）</div><div class="notion-text notion-block-380d3e0e52c04bee9382c2354ef223e1"><b>无缓冲 channel</b></div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-44e648a9d4dc498f8a8097db361ffe1a"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd027bf46-2c07-42db-ba57-240f594948dd%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D27354350b66cc94b39bc40a2cc0af69ad8e3b2193a41ee2a9d04ceaff527d1ca%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=44e648a9-d4dc-498f-8a80-97db361ffe1a&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-8f3f9877e0b44bdf923b5065e9416867">这种情况的消费者和生产者是<b>同步</b>的，同步指的是要求双方都准备好才能进行下一步。生产者生产数据后阻塞到数据被取走，而消费者获取数据之前也是阻塞在尝试获取的状态。下面这张图更加形象：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-9a4ab4a1efca4fc0902bc183aef7d896"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fba418f76-0195-47b0-8dd9-fd8a06aae594%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D1e2b0876abf533093a68449b1890f207d6031430d072f057d5c806d437085238%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=9a4ab4a1-efca-4fc0-902b-c183aef7d896&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-45f909403949498e8384d121798fd069">还是信箱的例子，无缓冲的 channel 相当于没有信箱了，快递员和收件人必须同时准备好才能结束发件和收件的动作。</div><div class="notion-text notion-block-dc744ef06b2d437bac047642b49e26ce">开发中如果我们使用无缓冲 channel，务必要小心死锁的情况</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestChannel</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">ch2</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan int<span class="token punctuation">)</span>
	ch2 <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token number">1</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">-</span>ch2<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-961b3d1a6e284f99a480aed4f4563523">这种情况运行后是会发生死锁的</div><div class="notion-text notion-block-18a4ad0ef7754adbb3fc72d31582973e"><code class="notion-inline-code">fatal error: all goroutines are asleep - deadlock!</code></div><div class="notion-text notion-block-97867ef1368a43f590e5b7e1d18b10e1">正确的写法是使用 goroutine 提前准备好接收：</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestChannel</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">ch2</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan int<span class="token punctuation">)</span>
	go <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">-</span>ch2<span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	ch2 <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token number">1</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-2c8f97e2ffdd45578cb3b7535467a8fb">另外需要注意的是，我们需要提前准备好接收，不然还是会死锁</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestChannel</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">ch2</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan int<span class="token punctuation">)</span>
	ch2 <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token number">1</span> <span class="token comment">// 提前发送, deadlock</span>
	go <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">-</span>ch2<span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-4a044f168f98418fbf4b554d9f7ab691" data-id="4a044f168f98418fbf4b554d9f7ab691"><span><div id="4a044f168f98418fbf4b554d9f7ab691" class="notion-header-anchor"></div><a class="notion-hash-link" href="#4a044f168f98418fbf4b554d9f7ab691" title="channel 的使用"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">channel 的使用</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-e689bcabb635420f97b72ece1c8e620c" data-id="e689bcabb635420f97b72ece1c8e620c"><span><div id="e689bcabb635420f97b72ece1c8e620c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e689bcabb635420f97b72ece1c8e620c" title="遍历"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">遍历</span></span></h3><div class="notion-text notion-block-de05ae49d51945769c8d1550b84d41e2">遍历有两种方式</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestFor</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">ch1</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan int<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token literal-property property">i</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		ch1 <span class="token operator">&lt;</span><span class="token operator">-</span> i
	<span class="token punctuation">}</span>
	
	<span class="token comment">// 方式一, 用 for 取出所有元素，建议使用</span>
	<span class="token keyword">for</span> <span class="token literal-property property">i</span> <span class="token operator">:</span><span class="token operator">=</span> range ch1 <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span>

	<span class="token comment">// 方式二</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		i<span class="token punctuation">,</span> <span class="token literal-property property">ok</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token operator">-</span>ch1 <span class="token comment">// 通道关闭后再取值ok=false</span>
		<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-469132cd1c194e39b399b0447f476f7a">推荐使用方式一，简单又清晰</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-0492324d62704c528055fc03f3e5e583" data-id="0492324d62704c528055fc03f3e5e583"><span><div id="0492324d62704c528055fc03f3e5e583" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0492324d62704c528055fc03f3e5e583" title="select"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">select</span></span></h3><div class="notion-text notion-block-c22c2f735f5e478b9ba8f2acfd3b3e9f">搭配 select 是的我们在遍历 channel 的时候可以进行选择性操作，例如下面的例子：</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token parameter">c<span class="token punctuation">,</span> quit chan int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	x<span class="token punctuation">,</span> <span class="token literal-property property">y</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		select <span class="token punctuation">{</span>
		<span class="token keyword">case</span> c <span class="token operator">&lt;</span><span class="token operator">-</span> x<span class="token operator">:</span>
			x<span class="token punctuation">,</span> y <span class="token operator">=</span> y<span class="token punctuation">,</span> x<span class="token operator">+</span>y
		<span class="token keyword">case</span> <span class="token operator">&lt;</span><span class="token operator">-</span>quit<span class="token operator">:</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"quit"</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

func <span class="token function">TestSelect</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">c</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan int<span class="token punctuation">)</span>
	<span class="token literal-property property">quit</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan int<span class="token punctuation">)</span>
	go <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token literal-property property">i</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">-</span>c<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		quit <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token number">0</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">fibonacci</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> quit<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">//0</span>
<span class="token comment">//1</span>
<span class="token comment">//1</span>
<span class="token comment">//2</span>
<span class="token comment">//3</span>
<span class="token comment">//5</span>
<span class="token comment">//8</span>
<span class="token comment">//13</span>
<span class="token comment">//21</span>
<span class="token comment">//34</span>
<span class="token comment">//quit</span></code></pre><div class="notion-text notion-block-88beb74ed9d944e1915986187917f143">上面的例子中，我们启动了一个 goruntine，读取 c 中前 10 个元素，然后我们调用 fibonacci，它执行了一个<code class="notion-inline-code">for … select</code> 的操作，第一个 select 不断往 c 中写入，第二个 select 从 quit 中读取，一旦从 quit 中获取到元素后，就退出循环</div><div class="notion-text notion-block-233c6537e560437d96072e67d917955c">而在外部，我们成功获取到了 fibonacci 数，可以看到 select 的使用和 Go 简单易用且强大的并发能力。</div><div class="notion-text notion-block-58e243fcc9944d4c8a83b6c1e12bbb5c"><b>进阶：超时 channel</b></div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestTimeout</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">c1</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan string<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	go <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
		c1 <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token string">"result 1"</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	select <span class="token punctuation">{</span>
	<span class="token keyword">case</span> <span class="token literal-property property">res</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token operator">-</span>c1<span class="token operator">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;</span><span class="token operator">-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"timeout 1"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// timeout 1</span>

func <span class="token function">After</span><span class="token punctuation">(</span>d Duration<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">-</span>chan Time <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">NewTimer</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token constant">C</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-2a7cc26a56ab4fc8870be61fc147abbf">我们通过计时器和 select，可以完成定时任务，比如说上面的代码，我们调用After获取到一个 <code class="notion-inline-code">&lt;-chan</code>，触发了相应的 case，终止了 select</div><div class="notion-text notion-block-4d8ce04055f24abc989e1c647275093e">上面的思想可以扩展到在某时刻 or 某条件下做相应操作的功能</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-d23480cc11e94cdc85fe812a45f69bb3" data-id="d23480cc11e94cdc85fe812a45f69bb3"><span><div id="d23480cc11e94cdc85fe812a45f69bb3" class="notion-header-anchor"></div><a class="notion-hash-link" href="#d23480cc11e94cdc85fe812a45f69bb3" title="通道的限制"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">通道的限制</span></span></h3><div class="notion-text notion-block-1459375836c241f68f8a81c5c8760bd1">有的时候我们需要限制通道的读写，那么我们可以提前声明通道的类型，这种通道称为单向通道，特点是限制了写入或者读取的操作：</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">op</span><span class="token punctuation">(</span><span class="token parameter">writer <span class="token operator">&lt;</span><span class="token operator">-</span>chan int<span class="token punctuation">,</span> reader chan<span class="token operator">&lt;</span><span class="token operator">-</span> int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> <span class="token literal-property property">data</span> <span class="token operator">:</span><span class="token operator">=</span> range writer<span class="token punctuation">{</span>
		reader <span class="token operator">&lt;</span><span class="token operator">-</span> data
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-39e8470d5ffc43eb80fe8855cb185f5c" data-id="39e8470d5ffc43eb80fe8855cb185f5c"><span><div id="39e8470d5ffc43eb80fe8855cb185f5c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#39e8470d5ffc43eb80fe8855cb185f5c" title="通道的关闭和异常"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">通道的关闭和异常</span></span></h3><div class="notion-text notion-block-754dbdf4a16d4d23bd5f2b4e09e5f662">使用 <code class="notion-inline-code">close()</code> 函数可以关闭一个通道，如果我们确认通道不再读写，那么记得及时关闭</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestClose</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">ch</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan int<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
	defer <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// do something ... </span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-a65b2800db9c4690a6344fa549dfc998">这里我们会好奇，对已经关闭的通道读写会有什么影响？这里也是面试会经常问到的，我们自己实验一下看看会有什么结果：</div><div class="notion-text notion-block-a52aa8009cca42798470355890c98700">首先我们根据缓冲类型分为无缓冲 channel 和有缓冲 channel 实验：</div><div class="notion-text notion-block-f4183c6fe51f4112bac609371615add2"><b>无缓冲 channel</b></div><div class="notion-row notion-block-482846820b2f467b8a87004db28426b9"><div class="notion-column notion-block-56a2995d4b9b4f6eb5b44c41d460db3a" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><pre class="notion-code language-go"><code class="language-go"><span class="token comment">// 无缓冲 channel，读</span>
func <span class="token function">TestClose</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">ch</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan int<span class="token punctuation">)</span>
	<span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">-</span>ch<span class="token punctuation">)</span> <span class="token comment">// 0</span>
<span class="token punctuation">}</span></code></pre></div><div class="notion-spacer"></div><div class="notion-column notion-block-5f891c8c3709428e8e629de8aa7e2154" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><pre class="notion-code language-go"><code class="language-go"><span class="token comment">// 无缓冲 channel，写</span>
func <span class="token function">TestClose</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">ch</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan int<span class="token punctuation">)</span>
	<span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
	ch <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token number">0</span> <span class="token comment">// panic: send on closed channel</span>
<span class="token punctuation">}</span></code></pre></div><div class="notion-spacer"></div></div><div class="notion-text notion-block-2414047a16f84d1d87324cfa2093150f">读会读取到零值，而写会 panic</div><div class="notion-text notion-block-ca4a6aaeada9412ebe0d3b2456ae0f9e"><b>有缓冲 channel</b></div><div class="notion-row notion-block-c5359ba4597a48cb8f90967cb8768eb8"><div class="notion-column notion-block-63796a71c330484598470a9a17ec9bf0" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><pre class="notion-code language-go"><code class="language-go"><span class="token comment">// 有缓冲 channel, 无写入值， 读</span>
func <span class="token function">TestClose</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">ch</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan int<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
	<span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">-</span>ch<span class="token punctuation">)</span> <span class="token comment">// 0</span>
<span class="token punctuation">}</span></code></pre><pre class="notion-code language-go"><code class="language-go"><span class="token comment">// 有缓冲 channel，有写入值，读</span>
func <span class="token function">TestClose</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">ch</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan int<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token literal-property property">i</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		ch <span class="token operator">&lt;</span><span class="token operator">-</span> i
	<span class="token punctuation">}</span>
	<span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token literal-property property">i</span> <span class="token operator">:</span><span class="token operator">=</span> range ch <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">// 输出 1 到 10</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">-</span>ch<span class="token punctuation">)</span> <span class="token comment">// 输出 0</span>
<span class="token punctuation">}</span></code></pre></div><div class="notion-spacer"></div><div class="notion-column notion-block-6119b0057a2944299f87954ba3b4936e" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><pre class="notion-code language-go"><code class="language-go"><span class="token comment">// 有缓冲 channel, 写</span>
func <span class="token function">TestClose</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">ch</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan int<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
	<span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
	ch <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token number">1</span> <span class="token comment">// panic: send on closed channel</span>
<span class="token punctuation">}</span></code></pre><div class="notion-blank notion-block-b35dd4ee17ac44f0bb6ba0943e02bd04"> </div></div><div class="notion-spacer"></div></div><div class="notion-text notion-block-3aedddba0b634916b8e71d052ea588cd">可以看到有缓冲 channel 的行为读取的时候，如果有预留值则读取预留值，没有则读取到零值，写同样会 panic</div><div class="notion-text notion-block-19fc853abf2b49b6974c7a677ab120cc">而我们再次 <code class="notion-inline-code">close</code> 的话，不管有无缓冲，都会提示我们 <code class="notion-inline-code">panic: close of closed channel</code></div><hr class="notion-hr notion-block-19a81de2bb1c491a9fba710295929068"/><div class="notion-text notion-block-add7e5761b164d66818f3d70036f47c4">现在我们可以总结了，从<b>已经关闭的 channel 里面操作</b>：</div><table class="notion-simple-table notion-block-109195cb8a184779a37ceeca2dfb70d4"><tbody><tr class="notion-simple-table-row notion-block-3ad7502180d84b50ba63d24470bff4a2"><td class="" style="width:120px"><div class="notion-simple-table-cell">操作 / channel 类型 </div></td><td class="" style="width:259px"><div class="notion-simple-table-cell">有缓冲 channel</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell"> 无缓冲 channel</div></td></tr><tr class="notion-simple-table-row notion-block-7d8c016612644344b6f0ec1d7c697978"><td class="" style="width:120px"><div class="notion-simple-table-cell">读</div></td><td class="" style="width:259px"><div class="notion-simple-table-cell">如果有预留值则返回，否则返回零值</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">返回零值</div></td></tr><tr class="notion-simple-table-row notion-block-9b11f047a9e248febe3275f6fdc1b19f"><td class="" style="width:120px"><div class="notion-simple-table-cell">写</div></td><td class="" style="width:259px"><div class="notion-simple-table-cell">panic: send on closed channel</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">panic: send on closed channel</div></td></tr><tr class="notion-simple-table-row notion-block-d26e341e46664381b3bd7325468d3f67"><td class="" style="width:120px"><div class="notion-simple-table-cell">再次 close</div></td><td class="" style="width:259px"><div class="notion-simple-table-cell">panic: close of closed channel</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">panic: close of closed channel</div></td></tr></tbody></table><div class="notion-text notion-block-71e15345b1614f6ba5efed9edfc95326">如果是 nil 的 channel 呢？</div><div class="notion-text notion-block-d91d5fb32b7d43debb5adb3425e9bd64">我们依次尝试读，写，close，发现都是 panic</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestClose</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">ch</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan int<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	ch <span class="token operator">=</span> nil
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">-</span>ch<span class="token punctuation">)</span> <span class="token comment">// fatal error: all goroutines are asleep - deadlock!</span>
	ch <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token number">1</span>           <span class="token comment">// fatal error: all goroutines are asleep - deadlock!</span>
	<span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>         <span class="token comment">// panic: close of nil channel</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-a363db3c40f742d69be12ed63b01d3ae">那么我们可以进一步总结：</div><table class="notion-simple-table notion-block-267dffec23e14e60b740c75de855dcd7"><tbody><tr class="notion-simple-table-row notion-block-cdc41da1b92f43bebd8f20b9f9c17f8f"><td class="" style="width:120px"><div class="notion-simple-table-cell">操作 / channel 类型 </div></td><td class="" style="width:250px"><div class="notion-simple-table-cell">有缓冲 channel</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell"> 无缓冲 channel</div></td><td class="" style="width:176.65625px"><div class="notion-simple-table-cell">nil chahnel</div></td></tr><tr class="notion-simple-table-row notion-block-3ecf29a2b824408d8a217fdbdfcb8825"><td class="" style="width:120px"><div class="notion-simple-table-cell">读</div></td><td class="" style="width:250px"><div class="notion-simple-table-cell">如果有预留值则返回，否则返回零值</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">返回零值</div></td><td class="" style="width:176.65625px"><div class="notion-simple-table-cell">死锁</div></td></tr><tr class="notion-simple-table-row notion-block-9b8371880b674042877faf62895a324b"><td class="" style="width:120px"><div class="notion-simple-table-cell">写</div></td><td class="" style="width:250px"><div class="notion-simple-table-cell">panic: send on closed channel</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">panic: send on closed channel</div></td><td class="" style="width:176.65625px"><div class="notion-simple-table-cell">死锁</div></td></tr><tr class="notion-simple-table-row notion-block-e0b652bd4731433a915a5e0372548a83"><td class="" style="width:120px"><div class="notion-simple-table-cell">再次 close</div></td><td class="" style="width:250px"><div class="notion-simple-table-cell">panic: close of closed channel</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">panic: close of closed channel</div></td><td class="" style="width:176.65625px"><div class="notion-simple-table-cell">panic: close of closed channel</div></td></tr></tbody></table><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-622603a1a46c4a239ae1760fb6bd08d0" data-id="622603a1a46c4a239ae1760fb6bd08d0"><span><div id="622603a1a46c4a239ae1760fb6bd08d0" class="notion-header-anchor"></div><a class="notion-hash-link" href="#622603a1a46c4a239ae1760fb6bd08d0" title="源码分析"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">源码分析</span></span></h2><div class="notion-text notion-block-57fb93d7f8f14bfbab446ada92d20d00"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://juejin.cn/post/6844904016254599176#heading-7">深入理解Golang之channel - 掘金 (juejin.cn)</a> 这篇文章分析得非常好，我先学习一下，后面再补充</div><div class="notion-blank notion-block-b633944242254ba8bfa2710ecae7af7f"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-440692534dd5466d976e286b6f96ecb6" data-id="440692534dd5466d976e286b6f96ecb6"><span><div id="440692534dd5466d976e286b6f96ecb6" class="notion-header-anchor"></div><a class="notion-hash-link" href="#440692534dd5466d976e286b6f96ecb6" title="Ref"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Ref</span></span></h2><div class="notion-text notion-block-fe55236221884162af647bf3dac9111d"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.runoob.com/w3cnote/go-channel-intro.html">Go Channel 详解 | 菜鸟教程 (runoob.com)</a></div><div class="notion-text notion-block-6ed978b6d07448abaf6da7890a16d68d"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://juejin.cn/post/6844904016254599176">深入理解Golang之channel - 掘金 (juejin.cn)</a></div><div class="notion-text notion-block-5fc6669f3a6646f5857f5621952e4067"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/channel.html">Channel · Go语言中文文档 (topgoer.com)</a></div><div class="notion-blank notion-block-4e64a4e46e5d47fe9f0cb748b33eec96"> </div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CS144 - lab 0]]></title>
            <link>https://hhmy27.github.io//cs144-lab0</link>
            <guid>https://hhmy27.github.io//cs144-lab0</guid>
            <pubDate>Fri, 25 Nov 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-be5d776a0cae4ad0b823fc7c1371aca9"><div class="notion-viewport"></div><div class="notion-table-of-contents notion-gray notion-block-97df9679a8d845ad8e0ebb16a292fb70"><a href="#ae1dc021a21345e0bed60baee7865bde" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">简介</span></a><a href="#0c3623c8d57548bf9f9a6796e8249a4f" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">环境</span></a><a href="#d99bc0ac3fe04a4e987a554bdb795a49" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">2 Networking by hand</span></a><a href="#a08b82fedaf742aab6cc0bde9df8fe73" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">2.1 Fetch a Web page</span></a><a href="#e856d35b7afc4748930b42456af20817" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">2.2 Send yourself an email</span></a><a href="#91f05b08390441c49630832ed6090f59" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">2.3 Listening and connecting</span></a><a href="#cd07ecd1bea0458abf3e5d841b0499c3" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">3 Writing a network program using an OS stream socket</span></a><a href="#7c38f02103cd45228e6391d24bac2716" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">3.1 Let’s get started —— fetching and building the starter code</span></a><a href="#f621f1ea80af457cbeabdb3bde02ca76" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">3.2 Modern C++: mostly safe but still fast and low-level</span></a><a href="#8a1ff620a6004d1dbe79f79838152c30" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">3.3 Reading the Sponge documentation</span></a><a href="#70760acfe73247eba35b2f8b4d43317d" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">3.4 Writing webget</span></a><a href="#e33b9c73e52d49129eeda444d5ea0c81" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">4 An in-memory reliable byte stream</span></a><a href="#85d3de1c1fd84f4bb5dc6596c13551b9" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">总结</span></a></div><div class="notion-blank notion-block-fa76a2033eec43d98745333f06cfc67a"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-ae1dc021a21345e0bed60baee7865bde" data-id="ae1dc021a21345e0bed60baee7865bde"><span><div id="ae1dc021a21345e0bed60baee7865bde" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ae1dc021a21345e0bed60baee7865bde" title="简介"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">简介</span></span></h2><blockquote class="notion-quote notion-block-dc7f08255e3a4ad4ab49ac8adb447a37">本文只是学习笔记，文中不会公布代码，只会发表自己的实现思路，如果不符合约定或规范，请联系我删除。</blockquote><div class="notion-text notion-block-ee6f62a0795e47dea3a3fa297d2ec454"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://cs144.github.io/">CS 144: Introduction to Computer Networking</a></div><div class="notion-text notion-block-15d9353a3ad44b3cbbb0ee3b0400ddc3">我跟的是 Fall 2021 的课程</div><div class="notion-text notion-block-9ddc6a4768264a579d5c83766926ece2">本次 lab 对应 week 1，阅读资料都是一些基本的网络概念，这里就不介绍了，感兴趣可以自己翻阅一下</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-49289c9e0a38410c8a849c155a758228"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8b6c78a1-1a99-4731-96ed-a254a6489f67%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D8f72771f436a2cbe4304ae891476b85ccf7f2b2e04a50ee58e7d0eb73f3303d6%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=49289c9e-0a38-410c-8a84-9c155a758228&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-0c3623c8d57548bf9f9a6796e8249a4f" data-id="0c3623c8d57548bf9f9a6796e8249a4f"><span><div id="0c3623c8d57548bf9f9a6796e8249a4f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0c3623c8d57548bf9f9a6796e8249a4f" title="环境"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">环境</span></span></h2><div class="notion-text notion-block-51e956a1018a4415a16f090962f196b5">我的是 m1pro 的 mbp，用 pd 开了一个虚拟机，然后用 vscode ssh 链接进行 coding</div><div class="notion-text notion-block-f0b6f16f669e43dba740df7594770b4c">首先是安装环境</div><pre class="notion-code language-bash"><code class="language-bash">apt<span class="token operator">-</span><span class="token keyword">get</span> install g<span class="token operator">++</span> git clang<span class="token operator">-</span>tidy clang<span class="token operator">-</span>format libpcap<span class="token operator">-</span>dev \
    iptables mininet tcpdump telnet wireshark socat netcat<span class="token operator">-</span>openbsd \
    doxygen graphviz</code></pre><div class="notion-text notion-block-50931b8196374820a98fa0ac08bc2013">下面就可以愉快的学习了</div><div class="notion-file notion-block-f58b6c3b60664e5a9243cf597cb7488d"><a target="_blank" rel="noopener noreferrer" class="notion-file-link" href="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/e9dbe224-eae9-4a79-978b-6887bc2e51c0/lab0.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221216%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221216T105340Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=d71619134e1b68039fe0b75d0f3d4416d2757739192e059defa3b1e418114a8a&amp;X-Amz-SignedHeaders=host&amp;x-id=GetObject"><svg class="notion-file-icon" viewBox="0 0 30 30"><path d="M22,8v12c0,3.866-3.134,7-7,7s-7-3.134-7-7V8c0-2.762,2.238-5,5-5s5,2.238,5,5v12c0,1.657-1.343,3-3,3s-3-1.343-3-3V8h-2v12c0,2.762,2.238,5,5,5s5-2.238,5-5V8c0-3.866-3.134-7-7-7S6,4.134,6,8v12c0,4.971,4.029,9,9,9s9-4.029,9-9V8H22z"></path></svg><div class="notion-file-info"><div class="notion-file-title">lab0.pdf</div><div class="notion-file-size">207.5KB</div></div></a></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-d99bc0ac3fe04a4e987a554bdb795a49" data-id="d99bc0ac3fe04a4e987a554bdb795a49"><span><div id="d99bc0ac3fe04a4e987a554bdb795a49" class="notion-header-anchor"></div><a class="notion-hash-link" href="#d99bc0ac3fe04a4e987a554bdb795a49" title="2 Networking by hand"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">2 Networking by hand</span></span></h2><div class="notion-text notion-block-1310c862caed4045854f918f1c43e43f">finish two tasks:</div><ul class="notion-list notion-list-disc notion-block-dcc1e690b2f04fb3b0644ebf46888561"><li>retrieving a web page</li></ul><ul class="notion-list notion-list-disc notion-block-79136bb9f92b4920878800be0dcf6f5c"><li>sending an email message</li></ul><div class="notion-text notion-block-9016fd5bf98348348951e6d034de9d56">这些任务依赖于一个叫做 <em>reliable bidirectional byte stream </em>的网络抽象</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-a08b82fedaf742aab6cc0bde9df8fe73" data-id="a08b82fedaf742aab6cc0bde9df8fe73"><span><div id="a08b82fedaf742aab6cc0bde9df8fe73" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a08b82fedaf742aab6cc0bde9df8fe73" title="2.1 Fetch a Web page"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">2.1 Fetch a Web page</span></span></h3><div class="notion-text notion-block-06a354682f06436599579c1bf828f9c7">两个操作：</div><ul class="notion-list notion-list-disc notion-block-d76fbcead99145f0ade4650a5a92135e"><li>在浏览器中访问 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="http://cs144.keithw.org/hello">http://cs144.keithw.org/hello</a>，并观察结果</li></ul><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-636ad1ade8dd4bd18f519f36f249bfee"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:432px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9c87e26d-167d-4b77-8b8b-7ad03b6a1601%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Dec1082eced9fbe5a7f408319a2f859db9328381994b95764083f7c4b20b8772a%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=636ad1ad-e8dd-4bd1-8f51-9f36f249bfee&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><ul class="notion-list notion-list-disc notion-block-81a9ab5873594cfdac036372eac50fa7"><li>输入<code class="notion-inline-code">$ telnet </code><code class="notion-inline-code"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="http://cs144.keithw.org">cs144.keithw.org</a></code><code class="notion-inline-code"> http</code></li></ul><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-0ff582c4bb0448d09c981485f1ee4fc1"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F55a7034b-6ac6-4e82-afe2-40d734305f2e%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D2d8e01e3feb6f4080e6c8898a84e3aece77f9f20c1afcd8b2f02d47a28bb43e6%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=0ff582c4-bb04-48d0-9c98-1485f1ee4fc1&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-d7bc2b80b5294bc9b407e0f163540389">等待链接建立后，输入以下命令并观察结果</div><pre class="notion-code language-bash"><code class="language-bash"><span class="token constant">GET</span> <span class="token operator">/</span>hello <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
<span class="token literal-property property">Host</span><span class="token operator">:</span> cs144<span class="token punctuation">.</span>keithw<span class="token punctuation">.</span>org
<span class="token literal-property property">Connection</span><span class="token operator">:</span> close
</code></pre><div class="notion-text notion-block-8ca02ecda1984513b0d1c6cc27f6b459">我们请求命令的含义分别是：</div><ul class="notion-list notion-list-disc notion-block-56547ab0758243ceb7bb73ae78ae7edc"><li><code class="notion-inline-code">GET /hello HTTP/1.1</code>，告诉 server 我们想要访问的 URL 路径，这里是 <code class="notion-inline-code">/hello</code></li></ul><div class="notion-text notion-block-1e5e2e64145b457d8fb22f708f59fde1">也就是我们的请求行</div><ul class="notion-list notion-list-disc notion-block-3cec229df1954cfdae4b12deffdd2f96"><li><code class="notion-inline-code">Host: cs144.keithw.org</code>，告诉 server 我们想要访问的 host，指的是 <code class="notion-inline-code">http://</code> 到 <code class="notion-inline-code">/hello</code> 中间的数据</li></ul><div class="notion-text notion-block-f4529d71e6e741dead0b82ed29d47a58">完整的路径是 <code class="notion-inline-code">http://cs144.keithw.org/hello</code></div><ul class="notion-list notion-list-disc notion-block-f2c66fe1763b4934a72c614819b79d43"><li><code class="notion-inline-code">Connection: close</code>，告诉 server，一旦返回结果就可以立即关闭</li></ul><div class="notion-text notion-block-ba415729a4574ca19d8087dc4d676c55">像这种 <code class="notion-inline-code">K:V</code> 型的数据就是请求头啦</div><div class="notion-blank notion-block-05f2654b882b439295d72ffac9cd93a6"> </div><div class="notion-text notion-block-962e8074b60146dbb5a5272686cd796e">输入后得到结果，cool</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-77361b9fef5144b0a0d2a28c51b340cb"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2213ade9-cfd1-410d-9e9e-7449fce11e43%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D9a1f76cdfb7efc7c50b0336e6bcedfadd119c0b753b0f9439a738e3119773eb6%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=77361b9f-ef51-44b0-a0d2-a28c51b340cb&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-16e6905c6657481f88b4ac292130e712">这里有一个任务</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-4a8b71bb9b4b4aa69593ef5e0476f89b"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb7c62a66-b7b5-4df2-80d6-a6314c8f16ce%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D91af0ad23c5c5ed5405b3f38c94e8cc26f6270135223277c81e60c8e43af4585%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=4a8b71bb-9b4b-4aa6-9593-ef5e0476f89b&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-923fe8c7526748b0a670459b096e9daf">就是按照上面的流程走一遍，我不知道SUNet ID在哪里获取，我自己随便打了一个</div><pre class="notion-code language-bash"><code class="language-bash"><span class="token constant">GET</span> <span class="token operator">/</span>lab0<span class="token operator">/</span><span class="token number">1808</span> <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
<span class="token literal-property property">Host</span><span class="token operator">:</span> cs144<span class="token punctuation">.</span>keithw<span class="token punctuation">.</span>org
<span class="token literal-property property">Connection</span><span class="token operator">:</span> close
</code></pre><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-ffcc41e630e547ac9d29c107eab42cfc"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fababc708-3b84-4040-af2e-3adc7d474ae6%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D30fa4586ede8fe0494e41715f9872f38273f803f276560c23b41b7a6c4ea62a5%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=ffcc41e6-30e5-47ac-9d29-c107eab42cfc&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-28e9854180044e97bd7ce368dbc47153">注意看header里面的字段，确实有一个997480的值返回</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-e856d35b7afc4748930b42456af20817" data-id="e856d35b7afc4748930b42456af20817"><span><div id="e856d35b7afc4748930b42456af20817" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e856d35b7afc4748930b42456af20817" title="2.2 Send yourself an email"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">2.2 Send yourself an email</span></span></h3><div class="notion-text notion-block-bdc0d9bb58f543688ff0b0a14413531b">用 smtp（Simple Mail Transfer Protocol）协议给自己发一封邮件 </div><div class="notion-text notion-block-f5019c6113eb45e0bee4f1c5e350e41e">这个环节需要用 standford 的网络环境才能完成，跳过了</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-91f05b08390441c49630832ed6090f59" data-id="91f05b08390441c49630832ed6090f59"><span><div id="91f05b08390441c49630832ed6090f59" class="notion-header-anchor"></div><a class="notion-hash-link" href="#91f05b08390441c49630832ed6090f59" title="2.3 Listening and connecting"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">2.3 Listening and connecting</span></span></h3><div class="notion-text notion-block-81bf4bf3f3044abb834d5e40cf8cefb1">下面用 <code class="notion-inline-code">netcat</code> 和 <code class="notion-inline-code">telnet</code> 来做一个双向通信</div><ol start="1" class="notion-list notion-list-numbered notion-block-26ed021c3e7e45bf8c801f410bd39c52"><li>用 <code class="notion-inline-code">netcat -v -l -p 9090</code> 来监听 9090 端口</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-d6278978a8924cc4a79784b0ce15d868"><li>在另一个 terminal，用 <code class="notion-inline-code">telnet localhost 9090</code> 来链接 9090 端口</li></ol><div class="notion-text notion-block-8aaa2a64dd514475ac23df2f75cff980">然后你会发现它们可以双向通信了</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-b42d4051f93846c6ace19ef2016a5da2"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ffdac4559-5c91-47fa-a8a8-157514d30fea%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D14c5c2495a293a4e185d120b99143c406b0f5ebc02a10e27161861ef3711aa1f%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=b42d4051-f938-46c6-ace1-9ef2016a5da2&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-a0ef389869fe432eaf91357c60a5f206"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-cd07ecd1bea0458abf3e5d841b0499c3" data-id="cd07ecd1bea0458abf3e5d841b0499c3"><span><div id="cd07ecd1bea0458abf3e5d841b0499c3" class="notion-header-anchor"></div><a class="notion-hash-link" href="#cd07ecd1bea0458abf3e5d841b0499c3" title="3 Writing a network program using an OS stream socket"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">3 Writing a network program using an OS stream socket</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-7c38f02103cd45228e6391d24bac2716" data-id="7c38f02103cd45228e6391d24bac2716"><span><div id="7c38f02103cd45228e6391d24bac2716" class="notion-header-anchor"></div><a class="notion-hash-link" href="#7c38f02103cd45228e6391d24bac2716" title="3.1 Let’s get started —— fetching and building the starter code"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">3.1 Let’s get started —— fetching and building the starter code</span></span></h3><div class="notion-text notion-block-31506cfefd3b4ab89dd541caf5d1c982">运行 <code class="notion-inline-code">git clone </code><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/cs144/sponge"><code class="notion-inline-code">https://github.com/cs144/sponge</code></a> 下载lab的源代码</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-664242ffb495431088307b8ae0746ae4"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0c370b02-98b7-4674-bfe9-6efb4a3a4d5c%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Dfc588acdec0ea266d2b0aa07e6ae2f6b3247665e30e23f11b9b771fb16a4a6e6%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=664242ff-b495-4310-8830-7b8ae0746ae4&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-f0739b2671b14e1a923cdb6098576467">文档里面的准备工作写得很详细，我自己没有遇到问题，可以直接进入3.2了</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-f621f1ea80af457cbeabdb3bde02ca76" data-id="f621f1ea80af457cbeabdb3bde02ca76"><span><div id="f621f1ea80af457cbeabdb3bde02ca76" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f621f1ea80af457cbeabdb3bde02ca76" title="3.2 Modern C++: mostly safe but still fast and low-level"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">3.2 Modern C++: mostly safe but still fast and low-level</span></span></h3><div class="notion-text notion-block-0c915438078f43689ac813f38d290438">又到了喜闻乐见的 C++ 环节，课程用的是 C++ 11，课程提出了一些要求：</div><ul class="notion-list notion-list-disc notion-block-ceca1dac81104f5096ae501aa4431654"><li>尽量避免使用成对操作，比如说 malloc/free, new/delete，因为后面的操作可能会因为异常或者提前退出而不能正确执行</li></ul><ul class="notion-list notion-list-disc notion-block-4fbef21576344427ba1b2e550b3d147d"><li>Resource acquisition is initializatio（RAII）风格</li><ul class="notion-list notion-list-disc notion-block-4fbef21576344427ba1b2e550b3d147d"><div class="notion-text notion-block-f0412b1e46fa408fbe8984f78213933c"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://zhuanlan.zhihu.com/p/34660259">c++经验之谈一：RAII原理介绍 - 知乎 (zhihu.com)</a></div><div class="notion-text notion-block-d53f77d893d4437a8444e26cfca40638">具体分为四步</div><ol start="1" class="notion-list notion-list-numbered notion-block-c2a9848d60a549cf8fe29a3e7b778b59"><li>设计一个类封装资源</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-4ffb2a082ee94a4fb12f63ac30731bb2"><li>在构造函数中初始化</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-5d5866b92fab499fb7a2b2ae43823b67"><li>在析构函数中执行销毁操作</li></ol><ol start="4" class="notion-list notion-list-numbered notion-block-8e87c3ccbd4d423ba7d85f0efeb52a4b"><li>使用的时候声明一个该对象的类（而不要使用new）</li></ol></ul></ul><div class="notion-text notion-block-838453be4bbc4308a80f43386d6afb1e">下面还有一些规范，这里就不翻译了：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-26fe59c29c6c4f63ba6d8721acd36af8"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F38e0de57-e4f9-4a66-b6cd-58439a902a83%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D9c443a6d2fe98faa9bc85527f00818ff71e06ca09583f6b0c5a8603d049bf94b%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=26fe59c2-9c6c-4f63-ba6d-8721acd36af8&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-8a1ff620a6004d1dbe79f79838152c30" data-id="8a1ff620a6004d1dbe79f79838152c30"><span><div id="8a1ff620a6004d1dbe79f79838152c30" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8a1ff620a6004d1dbe79f79838152c30" title="3.3 Reading the Sponge documentation"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">3.3 Reading the Sponge documentation</span></span></h3><div class="notion-text notion-block-4297f6b33e4f4c999f2d473f718f9ae6">ok，然后这边给了几个文档读</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-dd96c8d9e9084da5a97057b6c6dba4ed"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff7f11050-eacc-4ab2-9b7d-47f3d44febd0%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D22fa7b404923ef65053123cbd3c08613d75ecc285020911c81f99271e5e182ee%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=dd96c8d9-e908-4da5-a970-57b6c6dba4ed&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-18f65db8cba9486dbd641d3d09f43ab8">这里给了官方文档说明，主要是四个类要我们阅读</div><ul class="notion-list notion-list-disc notion-block-6aef36f121dd4c72b87e8b7da60b49dd"><li>FileDescriptor ⇒ Socket ⇒ TCPSocket</li></ul><ul class="notion-list notion-list-disc notion-block-6e2296ea18ad4c199e78b9eac15ed670"><li>Address 是 Socket 需要绑定的地址类</li></ul><ul class="notion-list notion-list-disc notion-block-43a92273bcdb49f89b0fa099fc1c040b"><li>然后看这个 libsponge/util 里面有源码</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-70760acfe73247eba35b2f8b4d43317d" data-id="70760acfe73247eba35b2f8b4d43317d"><span><div id="70760acfe73247eba35b2f8b4d43317d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#70760acfe73247eba35b2f8b4d43317d" title="3.4 Writing webget"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">3.4 Writing webget</span></span></h3><div class="notion-text notion-block-d64fe132a5df47ada8911b45e671b8f4">接下来就可以愉快的写代码了，第一个任务呢只给了我们一个函数，要求我们补全它的功能。</div><div class="notion-text notion-block-4cac6aa5dfdb4060942cf840f1485364">注释写得很详细，同时这里文档也给出了一些提示</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-3d75892e23424de4b57d2cbcd750c206"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa8aa3674-c024-49c0-98ef-1471494dfe53%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D7eefa9dea02b7ab8622cefa9e949e7f74a0fa3c76c1264df8729e04188044709%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=3d75892e-2342-4de4-b57d-2cbcd750c206&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-cdc5a19991824b3f9555e8943bfd37b1">怎么做的我们先看注释</div><pre class="notion-code language-c++"><code class="language-c++"><span class="token keyword">void</span> <span class="token function">get_URL</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">const</span> string <span class="token operator">&amp;</span>host<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Your code here.</span>

    <span class="token comment">// You will need to connect to the "http" service on</span>
    <span class="token comment">// the computer whose name is in the "host" string,</span>
    <span class="token comment">// then request the URL path given in the "path" string.</span>
    
    <span class="token comment">// Then you'll need to print out everything the server sends back,</span>
    <span class="token comment">// (not just one call to read() -- everything) until you reach</span>
    <span class="token comment">// the "eof" (end of file).</span>
    
    <span class="token comment">// cerr &lt;&lt; "Function called: get_URL(" &lt;&lt; host &lt;&lt; ", " &lt;&lt; path &lt;&lt; ").\n";</span>
    <span class="token comment">// cerr &lt;&lt; "Warning: get_URL() has not been implemented yet.\n";</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-89749aada39f42cb8bd243160dd1e55f">首先注释要求我们去链接 <code class="notion-inline-code">http</code> service，那么自然我们需要绑定<code class="notion-inline-code">Address</code>，看一下它里面的构造函数。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-4e3efcca7d654c17aec8c97ea919a58e"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:336px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Faa9c1998-a9ff-4a0f-840b-ef0b18f589ed%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Dd2951a51a605f1d56fc45092c1184d3fd748e4d94dc9baa27aff8c807b68127a%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=4e3efcca-7d65-4c17-aec8-c97ea919a58e&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-483160f12b394588b7bcd1fe41b21eb6">这个看起来符合我们的要求，这里也给了提示，<code class="notion-inline-code">http</code>是80端口，另外</div><blockquote class="notion-quote notion-block-0da8719b53584cda90711836c7b8d0ac"><code class="notion-inline-code">/etc/services</code> 文件包含网络服务和它们映射端口的列表。详细介绍可以看：
<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://zh.wikipedia.org/zh-tw/Services_(%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)">Services (網路服務設定檔) - 維基百科，自由的百科全書 (wikipedia.org)</a>
<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://linux.cn/article-10460-1.html">技术|理解 Linux 中的 /etc/services 文件</a></blockquote><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-b4333e4c17a94dd286fa7f455a457417"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3f7a7983-c6ed-4146-ae50-cb09050f67f9%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D3060c248192f3cb7f7a8e4df46f1796ac884151c57cb599bede7908d3a95f632%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=b4333e4c-17a9-4dd2-86fa-7f455a457417&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-481b0c73df894830abdbe80b8fdafe26">我们看看里面的说明，果然http是绑定到了80端口，而https绑定了443接口，根据协议还分为基于tcp的https和基于udp的https（也就是HTTP/3）</div><div class="notion-text notion-block-6b4d6d4790dd40078c2e4a5a805609a0">那么我们简单地使用<code class="notion-inline-code">Address addr(host, &quot;http&quot;);</code> 获取一个地址，回头继续看文档，还提示了我们用TCPSocket，经过一番摸索之后终于理解了这个get_URL的含义：</div><ul class="notion-list notion-list-disc notion-block-f21c07b5bf2248b199b6fa5f43fdd824"><li>用TCPSocket链接指定的host，然后写入相应的请求，并打印返回值</li></ul><div class="notion-text notion-block-8f9569829031486e88bb5a3ad9cc154d">通过测试了：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-97d27156437a4b5c9bcdd48861ac4430"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa24d4858-8685-486f-8d6c-fdefdecc441e%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D1af400b9d011a2cea9a271e9ab3955b958989c1ab7f0bc23c08db9c2b2926202%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=97d27156-437a-4b5c-9bcd-d48861ac4430&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-92b6fefa48ee4c6f9945b2e374e1ccb0">内容其实就是开始的时候，让我们手写HTTP请求获取结果一样，这里写了一个GET的请求，还有请求头说明host和connection的方式</div><div class="notion-text notion-block-ade1e1e5d37642e5b4dae4b2a57205c3">比如我们用写好的函数，测试<code class="notion-inline-code"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="http://cs144.keithw.org/">cs144.keithw.org</a></code><code class="notion-inline-code"> /hello</code> ，也能够得到正确的结果</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-44f0e0b1310d4fbfa9a9adbc97275362"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb2d8f2cd-b6a1-4483-94f3-ff307329c2d5%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D53ee2279eaf2f8ac0dd086f84c8c6b81740db9bf0e9d26607de0cdd75179d169%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=44f0e0b1-310d-4fbf-a9a9-adbc97275362&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-e33b9c73e52d49129eeda444d5ea0c81" data-id="e33b9c73e52d49129eeda444d5ea0c81"><span><div id="e33b9c73e52d49129eeda444d5ea0c81" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e33b9c73e52d49129eeda444d5ea0c81" title="4 An in-memory reliable byte stream"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">4 An in-memory reliable byte stream</span></span></h2><div class="notion-text notion-block-ea574969866e4585bd5f95ab885e8c07">接下来要我们实现一个<b>An in-memory reliable byte stream</b>，特点：</div><ul class="notion-list notion-list-disc notion-block-c7cdbc11f5db40cca55990b34404b25c"><li>长度限制writer写入的数量，但是并不限制整个传输的信号量。</li></ul><ul class="notion-list notion-list-disc notion-block-851c5764dec4444f9b574094785494ea"><li>当writer写入到limit的时候就不能再写了，只有reader取出数据才能继续写，就像生产者和消费者模型一样。</li></ul><div class="notion-text notion-block-c8e93b67b57e4b94a6c4636faaccad46">writer的接口：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-31856b532e4e4b2cb7f7b0823febc7bb"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbffc4db6-2955-4816-ac89-b05abfe0571f%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3De613216ab01e11b72d0e67ddd569d1c7d5d3a4ecc8bc610fcb3a3e1a6c928171%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=31856b53-2e4e-4b2c-b7f7-b0823febc7bb&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-4da3d432f9514a6fa4563ea32a754f10">reader的接口：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-2d78f41f506f42ff86edfd61027f29ba"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbc3608bb-8082-442e-bb67-a97aa244fc2a%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Daad2c6eb548e7fa831cf11f5214be4a8bfec8629fea15f0ac3de3f534e13480c%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=2d78f41f-506f-42ff-86ed-fd61027f29ba&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-c4c1bcbacc894732b9a85531ff838dc6">实现的地方在<code class="notion-inline-code">libsponge/byte stream.hh</code> and <code class="notion-inline-code">libsponge/byte_stream.cc</code></div><div class="notion-text notion-block-fcc61d5150e3402089a6da9bd4ff9791">想了一下，这个需求双端队列应该很好写，write往队首写，reader向队尾取，队列的size提前给定了</div><div class="notion-text notion-block-373f6115986347d28a133b6679f13361">注意到文档没有给出边界情况怎么处理：</div><ul class="notion-list notion-list-disc notion-block-98f5426df9ce4c8db02457a97f5ba80b"><li>reader想要读取的字符长度超过了队列的大小，应该怎么处理，直接报错还是直接读取尽可能大的字符？</li></ul><ul class="notion-list notion-list-disc notion-block-f5c9e98ea4584933954cdce740dbd61e"><li>我写入的字符串大于队列大小，应该丢弃多余的字符，还是保存下来再写入？</li></ul><div class="notion-text notion-block-e68d044b0789463bb6c42af65e6514f8">文档开头也说了，本次课程的实验部分的需求不会写得很详细，需要我们自己摸索然后设计一个解决方案，这是因为以后工作的时候遇到很多需求都是很模糊的，这么做是为了提前训练学生的设计能力。</div><div class="notion-text notion-block-e5a1858f86514a289406918ac6100276">想了一下，这是一个经典的生产者消费者问题，用双端队列能够很好的满足我们的需求</div><ul class="notion-list notion-list-disc notion-block-bd567afd34e54cfdb3c5e0eda8074752"><li>writer在队头写，reader取队尾</li></ul><ul class="notion-list notion-list-disc notion-block-a680270c019f4d83a2d7681f95e33011"><li>限制最大存储容量cap，通过队列元素个数和cap计算得到剩余可以写入的元素个数</li></ul><div class="notion-text notion-block-29b638d5ba234cdfa28d6bdbad196ca0">除此之外有几个要注意的地方</div><ul class="notion-list notion-list-disc notion-block-606b89f2a9b144c697e1f166e2feadcd"><li>eof 表示 reader 是否读取结束，状态由队列当前元素个数和 writer 是否写入结束共同决定</li></ul><ul class="notion-list notion-list-disc notion-block-697ee25a8ab040ffb8c17eb3af2d202e"><li>pop_output 同样也要计算读取个数</li></ul><div class="notion-text notion-block-ae77b2e01b8d42b6b3cc32a803fbc593">搞清楚之后实现还是很简短的，跑了一下，都通过了</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-f8b3c50c7a58455b9431c7cf45eabe09"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F990a66f2-bcd6-449b-bbe6-581ebdaf9cbb%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D69b20727039b5747416265bf6a3722ea4559214c4287694e2d6bd3312fbae11a%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=f8b3c50c-7a58-455b-9431-c7cf45eabe09&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-3487073b81334c139a0a6e1d36c936a9"><b>debug技巧</b></div><div class="notion-text notion-block-528326ead71f4aa082f9ae3ec42ff7c7">测试文件位于tests文件夹中，点进去能直接看到测试用例和预期结果，每个测试用例还会提示你完成了多少命令，在哪一个命令出错了，通过这种方式可能节省很多debug的时间。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-3dcdb3d1c15f48e1b6e699662c88e7d1"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:240px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdcb4ff32-20a2-46a6-845c-4eccb438c30c%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105340Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Ddab820ecc809d46558bb5bd9a776038b9774ab20810ab6c1ee4e7daf174ecb19%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=3dcdb3d1-c15f-48e1-b6e6-99662c88e7d1&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-85d3de1c1fd84f4bb5dc6596c13551b9" data-id="85d3de1c1fd84f4bb5dc6596c13551b9"><span><div id="85d3de1c1fd84f4bb5dc6596c13551b9" class="notion-header-anchor"></div><a class="notion-hash-link" href="#85d3de1c1fd84f4bb5dc6596c13551b9" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h2><div class="notion-text notion-block-6bd26e07b0d94c388a3f4956271a19fb">lab0 整体上是一个热身运动</div><ul class="notion-list notion-list-disc notion-block-b39c16754a67444caf2e94a9a50514ad"><li>通过 linux 自带的指令体验了一下 http 请求</li></ul><ul class="notion-list notion-list-disc notion-block-7c002475081340cbbab685718ace4535"><li>要求我们自己实现一个简单的 get_URL 函数去发送请求并获取结果，涉及到 Socket 和网络通信的基本知识</li></ul><ul class="notion-list notion-list-disc notion-block-f564d510ce3349148f183ec6b4413737"><li>最后的 An in-memory reliable byte stream 要求我们实现了一个生产者消费者模型，还是比较有意思的</li></ul><div class="notion-blank notion-block-82530730a1ee4f759803df91abb5a566"> </div><div class="notion-blank notion-block-6139e1700ab5438e829adf7354ef54dd"> </div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[TCP的重传机制、滑动窗口、流量控制、拥塞控制]]></title>
            <link>https://hhmy27.github.io//tcp</link>
            <guid>https://hhmy27.github.io//tcp</guid>
            <pubDate>Tue, 22 Nov 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-951d4753cc764e109427bc1517d34a8c"><div class="notion-viewport"></div><div class="notion-table-of-contents notion-gray notion-block-e0e84d9a375c4f659a81f2dc28ad6f1f"><a href="#b183366868dd422697e0614ce1b707ff" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">简介</span></a><a href="#f64b28fe5e2345c09fc4f2390363bbae" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">重传机制</span></a><a href="#9345229724ff48f1b52e608964263aa9" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">超时重传</span></a><a href="#a41ce7b2122a440ea4491859e5d5268b" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">快速重传</span></a><a href="#6f66d4dd768e432d83a6a1809e58a65b" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">SACK方法</span></a><a href="#5e309e36bb5a4b6ca01dfb34d0ecdd1a" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">DSACK方法</span></a><a href="#f3eac9c1d0cb4d34a82ddd4c665a3119" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">滑动窗口</span></a><a href="#f394c3d0528c4e30836db1cf1aade706" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">流量控制</span></a><a href="#57969268dcf540f9bb7da5f89e2111aa" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">拥塞控制</span></a><a href="#b48ae3199de640a8b2c8a3334bc577e2" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">什么是拥塞窗口</span></a><a href="#78bcaa7caf5847078769d9f323a7391f" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">慢启动</span></a><a href="#b37f6e42076f4322b1a2e3272bcca9a3" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">拥塞避免</span></a><a href="#f7415be02917493f9b9cfd0443e8e41c" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">拥塞发生算法</span></a><a href="#97028e27aa3d4ba9b41099c57cfa23a1" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">快速恢复</span></a><a href="#874fef272d30445fbc0e722e59292e20" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">Ref</span></a></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-b183366868dd422697e0614ce1b707ff" data-id="b183366868dd422697e0614ce1b707ff"><span><div id="b183366868dd422697e0614ce1b707ff" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b183366868dd422697e0614ce1b707ff" title="简介"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">简介</span></span></h2><blockquote class="notion-quote notion-block-34afd03e7abf44db8e2a7b47d01ccf61">本文是阅读<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding (xiaolincoding.com)</a>的笔记，想要了解更多细节请看原文</blockquote><div class="notion-text notion-block-749bcda685c84055bc9fc189084fcafd">先说结论</div><ul class="notion-list notion-list-disc notion-block-a0928fb281c04069ad8e330963bb5c90"><li>流量控制：针对发送方和接收方速度不匹配的问题，限制发送方的速度，是端对端的场景</li></ul><ul class="notion-list notion-list-disc notion-block-59300179550746edac988d8e8e5643b1"><li>拥塞控制：根据整个网络环境来调整发送速度，避免引起网络拥塞导致传输质量下降，是针对整个网络环境而言的</li></ul><div class="notion-text notion-block-7bb65b7add1f4a859a4dda84d322394c">为了更详细的介绍这两种控制机制，我们先引入重传和滑动窗口这两个概念。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-f64b28fe5e2345c09fc4f2390363bbae" data-id="f64b28fe5e2345c09fc4f2390363bbae"><span><div id="f64b28fe5e2345c09fc4f2390363bbae" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f64b28fe5e2345c09fc4f2390363bbae" title="重传机制"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">重传机制</span></span></h2><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-507902508909484db483f7c6ba54892a"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F71a8f7c0-1b8d-4e77-88db-56364a4037df%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D000e70a8bb55b8db930badf344b1b916b888bd84aaaccef984d2f1d7a6c6e935%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=50790250-8909-484d-b483-f7c6ba54892a&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><blockquote class="notion-quote notion-block-2ef7aadcb74846fab90ae664cf97380a">针对网络环境不稳定，可能会出现丢包情况设计的补偿机制。一共有四种：超时重传，快速重传，SACK方法，D-SACK方法</blockquote><div class="notion-text notion-block-27019a6a2c5845b9ba8251201338164a">首先说我们为什么需要重传？理想状态下的网络环境不会丢失，发送方发送一个，接收方就返回一个ACK确认消息。但是实际情况下，发送方的消息和接收方的ACK都有可能会丢失，如果不做重传补偿的话，丢失的数据是无法正常交付的。</div><div class="notion-text notion-block-3f79b2c488c040faa491b782d7992094">针对这种情况，TCP设计了重传机制，一共有四种重传机制：</div><ul class="notion-list notion-list-disc notion-block-23ee905e7e624a5a98bc64a5a465159f"><li>超时重传：设计一个时间间隔</li></ul><ul class="notion-list notion-list-disc notion-block-126b78b6ddf0425fa4c48821dd92aed0"><li>快速重传：重复3次ACK就重传</li></ul><ul class="notion-list notion-list-disc notion-block-f9ec8086ad7b4f3e8e605ead9587280e"><li>SACK 方法：通过额外信息告知发送方如何重传</li></ul><ul class="notion-list notion-list-disc notion-block-671b97f5a0bb4b3e926bd75360df41d8"><li>Duplicate SACK：告知发送方丢失包的原因</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-9345229724ff48f1b52e608964263aa9" data-id="9345229724ff48f1b52e608964263aa9"><span><div id="9345229724ff48f1b52e608964263aa9" class="notion-header-anchor"></div><a class="notion-hash-link" href="#9345229724ff48f1b52e608964263aa9" title="超时重传"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">超时重传</span></span></h3><div class="notion-text notion-block-0a34a8722be74483b704273658a90aa0">核心思想就是设置一个定时器，如果一定时间内发送方没有接收到ACK，那么就视为数据包丢失，需要进行重传。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-ca9aca596f144673ad10259cf45401f6"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F40b0315e-7141-40c1-b83a-744687b9ccac%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D3dbb98fe57eb86757b50fd4856cd807276df6fe1b87fea851f53b0f5606d6d60%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=ca9aca59-6f14-4673-ad10-259cf45401f6&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-3cc5d76c3f32456ea60ce7b2011c5a0e">那么现在问题的难点在于怎么定义这个超时时间：</div><ul class="notion-list notion-list-disc notion-block-cc6744d2056a47e68b3c8d19eb1e2253"><li>如果RT0过小的时候，可能会频繁传输已经接受到的数据</li></ul><ul class="notion-list notion-list-disc notion-block-cd818c71fff24395b0aa4bb73d0c01f3"><li>如果RT0过大，接收方会迟迟收不到丢失的数据包</li></ul><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-36d549c84df24a2195e005c9e4c46b40"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb83a4c93-86f5-4234-9fd9-5e51309df2d1%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D16df07781131d0b191f724973f03391bf2856dcc6b44b3658e63f12b6c9fd4ba%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=36d549c8-4df2-4a21-95e0-05c9e4c46b40&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-1ed901bd3d694285b134546c99696ade">为此TCP引入了<code class="notion-inline-code">RTT( Round-Trip Time 往返时延)</code>的概念，RTT指的是数据发送时刻到收到确认时刻的差值，也就是接收ACK时间-发送时间。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-dec043dd8cac438d9436ba6396ae4253"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F37fa9b0d-bbf9-4a5d-80a2-068d2a5a7b80%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D78b6e7212a99874cc6ddfef589ddca5957ff4e546ef0374d748dcec6b0130e08%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=dec043dd-8cac-438d-9436-ba6396ae4253&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-84a0dcb069204aa993d05957a8f59314">超时重传时间是<code class="notion-inline-code">RT0（Retransmission Timeout）</code> ，我们应该把RT0设置为略大于RTT。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-c38562ec6ce74420b7367999b462098b"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:617px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F641888fd-331c-4ce2-8b9e-d73bc35e5d14%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D70409f27e235e028d20851c420430606b2a24b070157c94f60445753db6b57aa%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=c38562ec-6ce7-4420-b736-7999b462098b&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-d0fc40221dd7404596c03e5d6c328ff1">网络环境是不断变化的，RTT也是动态的，RTT的计算方法有很多，可以看这篇文章的介绍：<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0">4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding (xiaolincoding.com)</a></div><div class="notion-text notion-block-a63a573e9b354d13b7ee309b02d4b491">超时重传的缺陷就是要设定这些超参数，快速重传设计思想不依赖于这些超参数。不过我们应该了解到重传机制并不是互斥的，我们可以在超时重传的基础上搭配快速重传。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-a41ce7b2122a440ea4491859e5d5268b" data-id="a41ce7b2122a440ea4491859e5d5268b"><span><div id="a41ce7b2122a440ea4491859e5d5268b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a41ce7b2122a440ea4491859e5d5268b" title="快速重传"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">快速重传</span></span></h3><div class="notion-text notion-block-103e201497b64657abb55e9464abce6a">快速重传的核心思想很简单：<b>收到三次重复的ACK就进行重传</b></div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-26c61e62c81445b7bffcd00ae2af54ae"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:647px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb1bebcc0-1b32-43e7-ba8d-09562ebcaa67%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D5fb8a4375c7b48141256dffe89cef03f69b4d7aa1dd329e8256a54704b615d6a%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=26c61e62-c814-45b7-bffc-d00ae2af54ae&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-b56e4f4a18fc4e58baa21f15ce94c29d">比如上面的例子，发送方在发送了Seq3、4、5的时候累计收到了3次ACK2的信号，那么就会重发Seq2。</div><div class="notion-text notion-block-8811bcedf2a943ddbab6056fcf86b52f">但其实这里还有一个问题，就是<b>发送方应该重传所有包，还是单个包</b>？</div><ul class="notion-list notion-list-disc notion-block-f1c44ac7c8f547199a2a704d140b8590"><li>重传单个包：重传效率很低，如果ACK3也发生丢失，那么接下来收到3个ACK3，才能重传</li></ul><ul class="notion-list notion-list-disc notion-block-0aa86bbb450148368f8aeb508ae4d245"><li>重传所有包：如果没有发生丢失，会发送大量的重复数据，导致资源浪费</li></ul><div class="notion-text notion-block-8636692f206c4908a605188890939bba">我们可以看出来这里问题的关键点在于，发送方不知道哪些包发生了丢失，因此无法很好的选择重传的范围。因此设计了SACK选项，让接收方告诉发送方应该重传哪些包。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-6f66d4dd768e432d83a6a1809e58a65b" data-id="6f66d4dd768e432d83a6a1809e58a65b"><span><div id="6f66d4dd768e432d83a6a1809e58a65b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6f66d4dd768e432d83a6a1809e58a65b" title="SACK方法"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">SACK方法</span></span></h3><div class="notion-text notion-block-5167730d99794ea1bf6ff0a04a551304">SACK是TCP的一个选项，也就是头部字段里面的一个值，用来告知发送方真正接受的包。要使用SACK，两个设备都必须同时支持SACK。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-ffbc1f3dfa9d4854bee6fae2003402ff"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff51888a6-b04f-4331-803d-03b4a083a106%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Db6b85369977d336571c842a95ed4d62aa2f9ef491870859505fab5025309d54d%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=ffbc1f3d-fa9d-4854-bee6-fae2003402ff&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-dab83a5579f2437c8eaf1e5e77a3bd34">上面这张图，在200~299的时候发送了丢失，接收方重传了3次ACK 200，此时接收方知道了200数据包发送丢失。而SACK返回了 300~500，这表示接收方已经接受了300~500的数据包。那么发送方此时根据ACK和SACK的值，重传200～299的数据包即可</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-5e309e36bb5a4b6ca01dfb34d0ecdd1a" data-id="5e309e36bb5a4b6ca01dfb34d0ecdd1a"><span><div id="5e309e36bb5a4b6ca01dfb34d0ecdd1a" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5e309e36bb5a4b6ca01dfb34d0ecdd1a" title="DSACK方法"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">DSACK方法</span></span></h3><div class="notion-text notion-block-01f83ff2ee17475ea1feeb4fcf1ad327">D-SACK即Duplicate SACK，它可以告知发送方哪些数据被重复接受了。</div><div class="notion-text notion-block-0ef442dff0fe412a8ba45d0589409247">下面用两个例子来说明D-SACK的作用</div><div class="notion-text notion-block-1a780314f64841b48fe4fb3db74915c8"><b>例子1 ACK丢包</b></div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-0c554c5f49b5477b87982c7f670349e7"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa0cd0960-f406-431a-8285-bd2bb4a2aa9c%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Db8757c004024760c3010739a09fa1d1ba446cb0bb7155a556d13b89a85e22b10%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=0c554c5f-49b5-477b-8798-2c7f670349e7&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-f35a664c45984d93ac60eaafff54b2ce">如果ACK号&gt;SACK号，那么就表示这是一个D-SACK包。上面是ACK丢失的情况，此时出发超时重传，重发3000~3499的数据包，后续收到了ACK=4000，表示此时4000之前的数据都被收到了，同时SACK=3000~3500，那么表示3000~3500的数据包被重复接受了，发送方就会得知：<b>是ACK丢失了</b></div><div class="notion-text notion-block-2d03a3b0b42c4dc39ad3b4b2bf1708e9"><b>例子2 网络延时</b></div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-302be0fae00f4ea191660bd12aae0339"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0dc5ece1-935f-4ba0-b89a-e1427dfae4bf%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D5778ba862ecede54d679204a5c52368c2dbb7a5a0db9f16f557929ebf604819c%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=302be0fa-e00f-4ea1-9166-0bd12aae0339&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-4e7bd2379a3241b380eb213db0f8ba70">这个例子中，ACK没有丢失，同时重发了三次，而1000~1499因为网络延迟没有到达，于是接收方重发了1000~1499。</div><div class="notion-text notion-block-4d3d67a2f0144d34852c011ab8eb4091">后续接收方收到延时的数据后会重发一个ACK=3000，SACK=1000~1500，那么接收方就知道了重传的原因是：<b>网络延时</b></div><div class="notion-text notion-block-59150f896d6940128f10fb3b89779c25">我们可以通过上面两个例子得知D-SACK的好处：</div><ul class="notion-list notion-list-disc notion-block-54329299181e45ee953cc498068e4af8"><li>可以让发送方知道重传的原因</li></ul><ul class="notion-list notion-list-disc notion-block-ba9b4c2362904b1a918ebc1de321f204"><li>可以知道哪些数据是被重复接收的。</li></ul><div class="notion-text notion-block-aedcb58daeb146efa8f327e617d4d3f9">而D-SACK和SACK的判断依据在于：</div><div class="notion-text notion-block-790b1f640132465cacc84520135c5226">如果ACK&gt;SACK，那么SACK就是一个D-SACK包，其中的数据是重复接收的</div><div class="notion-text notion-block-c99a18c899ee4ad7883e7abd4d8de819">如果ACK&lt;SACK，那么SACK就是表示已经接收的数据。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-f3eac9c1d0cb4d34a82ddd4c665a3119" data-id="f3eac9c1d0cb4d34a82ddd4c665a3119"><span><div id="f3eac9c1d0cb4d34a82ddd4c665a3119" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f3eac9c1d0cb4d34a82ddd4c665a3119" title="滑动窗口"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">滑动窗口</span></span></h2><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-b9059df6ff5141be97f04997e7645578"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8a2ddda7-46de-41a3-8de4-46a221ef174b%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D7f90ad54d9fa54f7d5753bd8bdcf9e1343cd979eeca4d85d4542a07f30da8661%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=b9059df6-ff51-41be-97f0-4997e7645578&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-e1a5ea0b88a24e939d8ac7ba520baa96"><b>提高通信效率</b></div><div class="notion-text notion-block-25272d5dd80b4bb9b648a1981de4c25d">上面介绍的通信模式都是发送方发送一个包，接收方返回一个ACK。放到现实生活中就是A说一句话，B要等A说完再说话，就这样轮流交替。这种通信模式效率太低下了</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-05db9914360f49c6ba053c202cca44d6"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:480px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fcb054a56-3bde-4d3a-a0d6-10224a11acb3%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D74d9f56ec9770116191a3ccd5cc551e143cbcc5425c4f7cfaf02b6b1795d70d8%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=05db9914-360f-49c6-ba05-3c202cca44d6&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-1b83fe7b442e40069220774e3e23749e">为了解决这个问题，TCP引入了<b>窗口</b>的概念，窗口可以支持批量发送数据，<b>窗口大小</b>指的就是<b>可以继续发送数据的最大值</b>。</div><div class="notion-text notion-block-7b2b0aa4b71c45babe1672caf0729254">窗口的底层实际上是操作系统为网络通信开辟的一个缓存空间，发送主机在等到ACK之前，必须在缓冲区中保存发送过的数据，如果收到了ACK，那么就可以清除这些旧数据。</div><div class="notion-text notion-block-0838f1f6c5d848408b97795fa3f1dabe">假设窗口大小为3，那么发送方可以连续发送3个包，如果中途有ACK丢失，可以根据最新的ACK来选择重发的数据。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-4c3f9bcb194f4c6689815bacec8aebc2"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2a8c03a8-645e-4265-a9f3-b0c95b9f88f4%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D8ae85fd15ec31f29646f18c4056b75d14acb5128347f0d475725be4bf3364ba9%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=4c3f9bcb-194f-4c66-8981-5bacec8aebc2&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-1b261ea0e79043bcbfbd68012908981f">比如说上图中，ACK 600丢失了，但是最新返回的是ACK 700，这表示700之前的数据都被接收了，600不需要重发就可以继续进行发送。</div><blockquote class="notion-quote notion-block-5649ecd51f14425786e53ca8aa1eab1d">在HTTP1.1中，开启管道后也是类似的通信方式，每次都可以发送一批数据</blockquote><div class="notion-text notion-block-1ef85d0649ba4326ac730d71cf11bf2e"><b>窗口大小由哪一方决定？</b></div><div class="notion-text notion-block-ce93295d17a540b0a87d50a2ac03a05d">发送速度和消费速度可能会不一致，我们应该考虑消费速度，避免接收方处理不过来。</div><div class="notion-text notion-block-f32afdb72a5e49cdb2505f26126705c8">TCP头里面有一个字段叫做<code class="notion-inline-code">Window</code> ，也就是窗口大小，一般是以接收方的窗口大小决定的。</div><div class="notion-text notion-block-f2635396659441318c8832dc63a82b05"><b>发送方的滑动窗口</b></div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-c96199930cde4a7c892dd50a1df807ef"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F49889321-d15b-4891-9111-b13423648fa1%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D4b8eda750b52278740873411bd68ad1b460f0e43ac493c82c0ae56043a22d16a%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=c9619993-0cde-4a7c-892d-d50a1df807ef&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-4aa0219674814592b103fdbf015f4f9b">发送方的滑动窗口可以分为四个部分：</div><ul class="notion-list notion-list-disc notion-block-141d25814cee4a0698e613c7e3127175"><li>已经发送且收到ACK的数据</li></ul><ul class="notion-list notion-list-disc notion-block-a2819766385e4aaaadd55fee7168a1d8"><li><b>发送窗口</b>：已经发送但未收到ACK的数据</li></ul><ul class="notion-list notion-list-disc notion-block-919fb2d8c0964262ac3a6e5f6a3caa66"><li><b>可用窗口</b>：未发送但是可以发送的数据</li></ul><ul class="notion-list notion-list-disc notion-block-5ba0d23196474b2b849395e8be472ea2"><li>未发送且超过接收方处理范围的数据</li></ul><div class="notion-text notion-block-91a6860973a243f0a148994b74270151">当发送方全部发送数据后，可用窗口就为0，发送窗口就是整个窗口大小了</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-94e7d1fea059401aad4d8750c0bb63f7"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F02d3f17a-ff2a-470d-b0a9-4c9474727b9b%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Dd6247a55fd89f92f47e6aab785bfb54c94fe6225c7a469782d1fea82847e5a79%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=94e7d1fe-a059-401a-ad4d-8750c0bb63f7&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-blank notion-block-a66d113d95284d8e8c8d5bdd9e67ae96"> </div><div class="notion-text notion-block-3abea9ec9b214dc6b149700660e4f34a">如果此时收到37的ACK，那么就可以往后移动窗口了</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-c708db8d18af4fcf808eda7f0bd598b3"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F796a38c6-32ac-4ad5-a8dc-f82f7a1b464e%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D3bcb4f8c7fca813e1f12259d1736076becdd6e2fba6cfdf555038b6668aedca5%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=c708db8d-18af-4fcf-808e-da7f0bd598b3&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-c9eadedddd0e45a0b5a8eba34d3af334">注意发送方的滑动窗口移动依据是<b>ACK号</b></div><div class="notion-text notion-block-ac2932c22d9442e6820fde48d361254a"><b>发送方的窗口表达</b></div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-75f4cf9b188d40f58002ff92e6a62e74"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F15236f2b-27b6-447c-9e41-80dc8e796608%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Db767e849adab601b943af7d2d4941d4f29f0bd0884dac78939ba66f5430fa61f%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=75f4cf9b-188d-40f5-8002-ff92e6a62e74&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-blank notion-block-843c725ceb18496e9f5edfd3fe03a897"> </div><ul class="notion-list notion-list-disc notion-block-0f4ac931060340808f86c4e25aee573f"><li><code class="notion-inline-code">SND.WND</code>：表示发送窗口的大小（大小是由接收方指定的）；</li></ul><ul class="notion-list notion-list-disc notion-block-90389ba3118d405d900882ff4e73f0cc"><li><code class="notion-inline-code">SND.UNA</code>（<em>Send Unacknoleged</em>）：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</li></ul><ul class="notion-list notion-list-disc notion-block-dd74b5bb09214584bde65c05862fe0c3"><li><code class="notion-inline-code">SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</li></ul><ul class="notion-list notion-list-disc notion-block-90d89b2de37e434fa1fdbdc3adeddc2c"><li>指向 #4 的第一个字节是个相对指针，它需要 <code class="notion-inline-code">SND.UNA</code> 指针加上 <code class="notion-inline-code">SND.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li></ul><div class="notion-text notion-block-53f42715d5d04974956c54c5c2ae7a01">那么可用窗口大小的计算就可以是：</div><div class="notion-text notion-block-f51f12a7ea5141e4a0e4708b29c2f9fe"><span class="notion-red_background">可用窗口大小 = SND.WND -（SND.NXT - SND.UNA）</span></div><div class="notion-text notion-block-61721dd591934cbf94a93be49c5e3da5"><b>接收方的滑动窗口</b></div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-3466e124c3ed46aebd05715de7a066f6"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc7c27898-a57b-461a-a034-4b7eee1f96d4%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Dc038839301ea5103693724754e2928a5bba7bee332386725c6c472ab16a99027%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=3466e124-c3ed-46ae-bd05-715de7a066f6&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><ul class="notion-list notion-list-disc notion-block-e30de54611ff4f00853d87895bb2ba45"><li><code class="notion-inline-code">RCV.WND</code>：表示接收窗口的大小，它会通告给发送方。</li></ul><ul class="notion-list notion-list-disc notion-block-e38642fb491e4fd3bd7d8e66590c3758"><li><code class="notion-inline-code">RCV.NXT</code>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</li></ul><ul class="notion-list notion-list-disc notion-block-ec69962f4953419992e16ed20d81bf22"><li>指向 #4 的第一个字节是个相对指针，它需要 <code class="notion-inline-code">RCV.NXT</code> 指针加上 <code class="notion-inline-code">RCV.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li></ul><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-f394c3d0528c4e30836db1cf1aade706" data-id="f394c3d0528c4e30836db1cf1aade706"><span><div id="f394c3d0528c4e30836db1cf1aade706" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f394c3d0528c4e30836db1cf1aade706" title="流量控制"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">流量控制</span></span></h2><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-89043d034b58406bbc796985cc8faef3"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F977f3a00-5d9c-41fc-8b54-5b3f31947801%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Df93e91bbaa6e46cc928901c26cc0f20f5ab219b628b06074417a248afe1b04e9%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=89043d03-4b58-406b-bc79-6985cc8faef3&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-d6f9fcf0ad0d4f0c8bf10dc21f723a41">流量控制指的是端对端通信时，协调发送方的发送速度和接收方的处理速度，避免接收方处理不过来。TCP使用流量控制让发送方根据接收方的实际接受能力控制发送数据量。</div><div class="notion-text notion-block-41090323da5a4199a3d57e7370682b8c">假设接收方的可用窗口大小是400，那么这个值会在建立连接的时候告诉发送方，同时在通信过程中不断告知当前接收方的可用窗口大小<code class="notion-inline-code">rwnd</code>，发送方会根据这个大小发送数据。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-b284920d46764852b24becfd7fb44112"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbd03514d-1645-4f82-8da7-15926664367b%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D6b607268581d9cfbc9539b3659d90289de82f174a5b9a42daf3247c975e7db9f%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=b284920d-4676-4852-b24b-ecfd7fb44112&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-71b150058d954402b28156dd9d0b45d1">简述一下就是返回的信息里面带有接收方的可用窗口大小，让发送方避免发出处理范围之外的数据。</div><div class="notion-text notion-block-d2b1e8c6660c472b93ddc7ab22f50df9">另外这里有一个额外的知识点，那就是滑动窗口的大小依赖于缓冲区大小，如果操作系统调小了缓冲区大小，那么就会引起滑动窗口的收缩。而这个事件的发生顺序是要<b>先收缩滑动窗口，再调小缓冲区</b></div><div class="notion-text notion-block-7d588aa21cb24680b1f60a17b1419a25">否则的话可能还没来得及读取滑动窗口内的数据，就已经被限制读取范围了，导致部分数据永远读取不到了。</div><div class="notion-text notion-block-097b03c236f34b588d21a1261beb4baf"><b>窗口关闭</b></div><div class="notion-text notion-block-a54e1f28d2834780878465faaa162301">窗口关闭指的是接收方告知发送方可用窗口大小为0，此时发送方只有等待接收方告诉他可用窗口增加后才能发送数据。那么这里可能就有一个问题：非0窗口通知丢失。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-35a7e8d7c463406b885b6d3db5072a5d"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F662e7b61-6210-441f-a796-3c4b7742f3ae%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D6068a17a6dbb982c1b345395829c7d9098f082daa62bf062047ce72853f5f414%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=35a7e8d7-c463-406b-885b-6d3db5072a5d&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-ad3f747b0752478ca6bd09d02a44c683">如果非0窗口丢失了，那么就会出现循环等待的现象。</div><div class="notion-text notion-block-ac571f657c764de5bb6dd6fad4f2c8db">解决这个问题其实很简单，发送方收到0窗口通知后，就会开启一个计时器，一段时间后会发送一个<b>探测报文</b>，要求对方给出当前的可用窗口大小，那么这样就能避免死锁的现象了。</div><div class="notion-text notion-block-7baa552c7f8241f4aadbd4a9d5f3fe17"><b>糊涂窗口综合症</b></div><div class="notion-text notion-block-ac9a765478014b0bafa53e100c89bf08">就是接收方处理不过来，导致每次可用窗口大小都是几个字节，而发送方收到大小后就发送几个字节数据，这样的开销其实是很大的。</div><div class="notion-text notion-block-1cc550edc6774377a72cc25de253ea5d">这个问题现象产生于：</div><ul class="notion-list notion-list-disc notion-block-31dc83c48220400283b1a1b5cd10a539"><li>接收方告诉小窗口给发送方</li></ul><ul class="notion-list notion-list-disc notion-block-068463d370df4d22832df5567ab84bfa"><li>发送方可以发送小数据</li></ul><div class="notion-text notion-block-18531586ee4a4ef0bb9f0909e0cf8b6a">解决这个问题只需要把这两个现象处理掉就好了</div><ul class="notion-list notion-list-disc notion-block-8495646699cc49af8dc1a97ff1e1eaa5"><li>接收方不告知小窗口</li></ul><ul class="notion-list notion-list-disc notion-block-13dcaa53599844a2bda2977085af9d68"><li>发送方等待一批数据后再发送</li></ul><blockquote class="notion-quote notion-block-57d9d6ca87d0463ab13556d6d0a21a65">怎么让接收方不通告小窗口呢？</blockquote><div class="notion-text notion-block-a5bb0ac4ba8d465faf735bac9a6e8103">接收方通常的策略如下:</div><div class="notion-text notion-block-97d04442e5d24afe8a27b5a8ad416a54">当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 <code class="notion-inline-code">0</code>，也就阻止了发送方再发数据过来。</div><div class="notion-text notion-block-526c71bed8c84bcc8df9e276779037db">等到接收方处理了一些数据后，窗口大小 &gt;= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</div><blockquote class="notion-quote notion-block-2c52658df99e4e5ca3a2dc36bdf30e96">怎么让发送方避免发送小数据呢？</blockquote><div class="notion-text notion-block-88045983170f4d0e857f333aa4a93e5f">发送方通常的策略如下:</div><div class="notion-text notion-block-984958dd7dc642b28325ffa9bd175c34">使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才可以发送数据：</div><ul class="notion-list notion-list-disc notion-block-24e37a05dd4f49d4aa4f60abace5867b"><li>条件一：要等到窗口大小 &gt;= <code class="notion-inline-code">MSS</code> 并且 数据大小 &gt;= <code class="notion-inline-code">MSS</code>；</li></ul><ul class="notion-list notion-list-disc notion-block-dc0669502dcf48c3a613c49ed657115b"><li>条件二：收到之前发送数据的 <code class="notion-inline-code">ack</code> 回包；</li></ul><div class="notion-text notion-block-2c05b6e73d404307a8645efba71b4a82">只要上面两个条件都不满足，发送方一直在囤积数据，直到满足上面的发送条件。</div><div class="notion-text notion-block-c0c337a67210435c9db21226b05804c5">Nagle 伪代码如下：</div><pre class="notion-code language-go"><code class="language-go"><span class="token keyword">if</span> 有数据要发送 <span class="token punctuation">{</span>
    <span class="token keyword">if</span> 可用窗口大小 <span class="token operator">>=</span> <span class="token constant">MSS</span> and 可发送的数据 <span class="token operator">>=</span> <span class="token constant">MSS</span> <span class="token punctuation">{</span>
    	立刻发送<span class="token constant">MSS</span>大小的数据
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> 有未确认的数据 <span class="token punctuation">{</span>
            将数据放入缓存等待接收<span class="token constant">ACK</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            立刻发送数据
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-4c8ec648eca6475aa24026be8a020f78">注意，如果接收方不能满足「不通告小窗口给发送方」，那么即使开了 Nagle 算法，也无法避免糊涂窗口综合症，因为如果对端 ACK 回复很快的话（达到 Nagle 算法的条件二），Nagle 算法就不会拼接太多的数据包，这种情况下依然会有小数据包的传输，网络总体的利用率依然很低。</div><div class="notion-text notion-block-79fd21e556404f1986e9beb47f335981">所以，<b>接收方得满足「不通告小窗口给发送方」+ 发送方开启 Nagle 算法，才能避免糊涂窗口综合症</b>。</div><div class="notion-text notion-block-459992772e08419fa47525d00cc36c0e">另外，Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。</div><div class="notion-text notion-block-f52c8a63c21e4334b55251d20054d9ae">可以在 Socket 设置 <code class="notion-inline-code">TCP_NODELAY</code> 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）</div><div class="notion-text notion-block-682cdc40e8af4579bb7f0763933da257"><code class="notion-inline-code">setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&amp;value, sizeof(int));</code></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-57969268dcf540f9bb7da5f89e2111aa" data-id="57969268dcf540f9bb7da5f89e2111aa"><span><div id="57969268dcf540f9bb7da5f89e2111aa" class="notion-header-anchor"></div><a class="notion-hash-link" href="#57969268dcf540f9bb7da5f89e2111aa" title="拥塞控制"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">拥塞控制</span></span></h2><div class="notion-blank notion-block-eeb9718466484e54a3fbde1c96d93301"> </div><div class="notion-text notion-block-afaeec7627364a6eaf797123e8fdf891">前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</div><div class="notion-text notion-block-299277b209354fe88741c39173d9294e">一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。</div><div class="notion-text notion-block-9377b229087f47959c090c6ec84ac517"><b>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....</b></div><div class="notion-text notion-block-98ebfd3e30474aa8a9e41ef2f9c34a67">所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</div><div class="notion-text notion-block-472b2802d72743c68e601de7ebad101d">于是，就有了<b>拥塞控制</b>，控制的目的就是<b>避免「发送方」的数据填满整个网络。</b></div><div class="notion-text notion-block-790e0a6943fd492cb5da03d5e7d1727b">为了在「发送方」调节所要发送数据的量，定义了一个叫做「<b>拥塞窗口</b>」的概念。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-b48ae3199de640a8b2c8a3334bc577e2" data-id="b48ae3199de640a8b2c8a3334bc577e2"><span><div id="b48ae3199de640a8b2c8a3334bc577e2" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b48ae3199de640a8b2c8a3334bc577e2" title="什么是拥塞窗口"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">什么是拥塞窗口</span></span></h3><div class="notion-text notion-block-51cf397a0a1646d3889d9a5ae02c0bc4">TCP中一共有三种窗口：</div><ul class="notion-list notion-list-disc notion-block-e67fae02ef6e4e24b85a9b971b701160"><li>rwnd：接收窗口</li></ul><ul class="notion-list notion-list-disc notion-block-0f87cda949b74cc49cfeb432dd712b66"><li>swnd：发送窗口</li></ul><ul class="notion-list notion-list-disc notion-block-c974b4e79b3346968e3a958254559e15"><li>cwnd：拥塞窗口</li></ul><div class="notion-text notion-block-32cfe85dd0b046388ef38cdc0bbf92a1"><b>拥塞窗口 cwnd</b>是<b>发送方</b>维护的一个的状态变量，它会根据<b>网络的拥塞程度动态变化的</b>。</div><div class="notion-text notion-block-1b7ddf3ab90e4ebf8a8c819d2112854f">我们在前面提到过发送窗口 <code class="notion-inline-code">swnd</code> 和接收窗口 <code class="notion-inline-code">rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</div><div class="notion-text notion-block-437e0e56b0554df2b6b8c60bcf963ead">拥塞窗口 <code class="notion-inline-code">cwnd</code> 变化的规则：</div><ul class="notion-list notion-list-disc notion-block-99629183379540e7b96a0680043d674c"><li>只要网络中没有出现拥塞，<code class="notion-inline-code">cwnd</code> 就会增大；</li></ul><ul class="notion-list notion-list-disc notion-block-24c32a0cf35a4d84bd9d5b23fe828f92"><li>但网络中出现了拥塞，<code class="notion-inline-code">cwnd</code> 就减少；</li></ul><div class="notion-text notion-block-8be24be7f2404f56b4dd9f4031656103"><span class="notion-yellow_background">那么怎么知道当前网络是否出现了拥塞呢？</span></div><div class="notion-text notion-block-246f1683b106410096f7901508cd344f">其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<b>发生了超时重传，就会认为网络出现了拥塞。</b></div><div class="notion-text notion-block-bca67e3315af403a8ff7460c41bf5bed"><span class="notion-yellow_background">拥塞控制有哪些控制算法？</span></div><div class="notion-text notion-block-d6bfda36061042cda250b267dc93117e">拥塞控制主要是四个算法：</div><ul class="notion-list notion-list-disc notion-block-086dd2394a884f409d303f30f416d239"><li>慢启动</li></ul><ul class="notion-list notion-list-disc notion-block-2b9da106e9ba46ce8db0921c145a299c"><li>拥塞避免</li></ul><ul class="notion-list notion-list-disc notion-block-9c42ea7479b64a87958eeaee1d786e1e"><li>拥塞发生</li></ul><ul class="notion-list notion-list-disc notion-block-1052ec37119f43b498d3b7dbac83ea09"><li>快速恢复</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-78bcaa7caf5847078769d9f323a7391f" data-id="78bcaa7caf5847078769d9f323a7391f"><span><div id="78bcaa7caf5847078769d9f323a7391f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#78bcaa7caf5847078769d9f323a7391f" title="慢启动"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">慢启动</span></span></h3><div class="notion-text notion-block-a3737bdbaff14fad8993467d4331e8e0">慢启动的核心思想是控制一开始发送方的发送速度，不要一上来速度就拉满。</div><div class="notion-text notion-block-c2a4f462ab2c468680ebc4a6d7cd17fd">规则：当发送方每接受一个ACK，拥塞窗口cwnd的大小就会加1</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-736742f198534d3fbf4c9ac5617d1c12"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1f8bbd60-210b-4891-894f-10775abb247f%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D9ebf5eac7f0eab9c89659dad8b63281240bf43d9028f596ad294e6d7ecffc068%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=736742f1-9853-4d3f-bf4c-9ac5617d1c12&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-f6a1af6afd484504bf9f250d2948adeb">每个ACK都使得cwnd大小加1，而cwnd变大的同时还能发送多个数据包，因此它的增长速度就是指数性的增长。</div><div class="notion-text notion-block-f8aacec1eca94af6873efe1696e42744">但是cwnd并不是无限增长的，有一个叫做慢启动门限 <code class="notion-inline-code">ssthresh (slow start threshold</code>) 状态变量</div><ul class="notion-list notion-list-disc notion-block-6835e74b47054e33817dfc0351931353"><li>当cwnd &lt; ssthresh，使用慢启动算法</li></ul><ul class="notion-list notion-list-disc notion-block-60cf7f4f4c594ece94b76d61d3d6974e"><li>当cwnd ≥ ssthresh，使用拥塞避免算法</li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-b37f6e42076f4322b1a2e3272bcca9a3" data-id="b37f6e42076f4322b1a2e3272bcca9a3"><span><div id="b37f6e42076f4322b1a2e3272bcca9a3" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b37f6e42076f4322b1a2e3272bcca9a3" title="拥塞避免"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">拥塞避免</span></span></h3><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-0a79a897393a45609c230fb337243690"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F863a108b-cb4c-46a0-b046-81ca6a23aea8%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Da8aac97fd37874adec5f193d5919200cd980a5656da9b566bec829d35f07dcd0%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=0a79a897-393a-4560-9c23-0fb337243690&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-a43e1284c77f49ea90cf41d5b0adeb38">前面说道，当拥塞窗口 <code class="notion-inline-code">cwnd</code> 「超过」慢启动门限 <code class="notion-inline-code">ssthresh</code> 就会进入拥塞避免算法。</div><div class="notion-text notion-block-d5b0a19a62c14e9a8422cfabc6f79a19">一般来说 <code class="notion-inline-code">ssthresh</code> 的大小是 <code class="notion-inline-code">65535</code> 字节。</div><div class="notion-text notion-block-a5906fd98b114e8fa3698a8045b69390">那么进入拥塞避免算法后，它的规则是：<b>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</b></div><div class="notion-text notion-block-4593186cdb23412d9b8be785749f5f80">接上前面的慢启动的栗子，现假定 <code class="notion-inline-code">ssthresh</code> 为 <code class="notion-inline-code">8</code>：</div><ul class="notion-list notion-list-disc notion-block-2ed93c891ee1483eb3efcba06271f94b"><li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 <code class="notion-inline-code">MSS</code> 大小的数据，变成了<b>线性增长。</b></li></ul><div class="notion-text notion-block-054ab90f9c464c32a1fb9736c198ea18">拥塞避免算法的变化过程如下图：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-43af1140967c4a2e9a1ff601efb5f356"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb45ef61b-54f7-4324-9c7f-7f20cad46c6b%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D1619a3a782e06a6bd14a3ab3424ddda88bb7eb9bd41053a23c41c6ac698b0f24%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=43af1140-967c-4a2e-9a1f-f601efb5f356&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-4ec3fd624f854e278538f35f7fb136dd">也就是说一旦cwnd越过了阈值，那么就会变成线性增长</div><div class="notion-text notion-block-0c4dcb3f6a9b4b66abbfd8052b53d69f">所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</div><div class="notion-text notion-block-aec4d95fa9f440baaaf5bd58c22952f0">就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</div><div class="notion-text notion-block-1388e3eb28864e9eb02801421a7225cd">当触发了重传机制，也就进入了「<b>拥塞发生算法</b>」。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-f7415be02917493f9b9cfd0443e8e41c" data-id="f7415be02917493f9b9cfd0443e8e41c"><span><div id="f7415be02917493f9b9cfd0443e8e41c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f7415be02917493f9b9cfd0443e8e41c" title="拥塞发生算法"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">拥塞发生算法</span></span></h3><div class="notion-text notion-block-829326cd99b146c189108a4a8b5e1bb2">我们之前介绍了两种重传机制，分别是：</div><ul class="notion-list notion-list-disc notion-block-607eecd7a0ed43f080860aec2153000d"><li>超时重传</li></ul><ul class="notion-list notion-list-disc notion-block-d142a83205714d16a534817942ac0e7f"><li>快速重传</li></ul><div class="notion-text notion-block-f717d6d4558c49c1a34145b812a68442">根据重传机制不同，拥塞发生算法也会不同。</div><div class="notion-text notion-block-06d78042b8c149e1a259b3324e150c2f"><b>发生超时重传的拥塞算法</b></div><div class="notion-text notion-block-4194ea0b82734115a33c2976d76f8bf0">当发生了「超时重传」，则就会使用拥塞发生算法。</div><div class="notion-text notion-block-8cdd6d53aba540399f276e48a0af83df">这个时候，ssthresh 和 cwnd 的值会发生变化：</div><ul class="notion-list notion-list-disc notion-block-7c8cc86a0e7d4c8a866c6b4a26eb03cd"><li><code class="notion-inline-code">ssthresh</code> 设为 <code class="notion-inline-code">cwnd/2</code>，</li></ul><ul class="notion-list notion-list-disc notion-block-97cfc71807524dd6a9e264f98e4cdd0d"><li><code class="notion-inline-code">cwnd</code> 重置为 <code class="notion-inline-code">1</code> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</li></ul><div class="notion-text notion-block-eb07cdc6576c434c96ad75c873ed5cd6"><span class="notion-yellow_background">怎么查看系统的cwnd初始值？</span></div><div class="notion-text notion-block-5364abc7005a40a180821a13c4c88baf">Linux 针对每一个 TCP 连接的 cwnd 初始化值是 10，也就是 10 个 MSS，我们可以用 ss -nli 命令查看每一个 TCP 连接的 cwnd 初始化值，如下图</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-32eb20f3d0d443f3a1225c05636973b3"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe04caa44-63ab-4981-9f02-cbbe366b0f8f%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D94d700dd3c8afd755591cbd57a01bc2b8291ddb849c17fdebd85adc7498a20a1%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=32eb20f3-d0d4-43f3-a122-5c05636973b3&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-4ccd8704330642a892e8bc6263d0b078">拥塞发生算法的变化如下图：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-d62c01d6f0004d10bb88046976edf4d5"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbd4240a0-bc30-461e-ad3d-8b7cba2951ec%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D303a7317bcdb6c42e526c6b7a7640483b11a1c305051eddda8ce401559eb848e%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=d62c01d6-f000-4d10-bb88-046976edf4d5&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-79c43aaec73e44799137412dea032884">接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。</div><div class="notion-text notion-block-e5f22886a78642f4b4092b9dcf3c48c7">但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</div><div class="notion-text notion-block-b7b63e2adbd14825a2759680cce824d0"><b>发生快速重传的拥塞发生算法</b></div><div class="notion-text notion-block-978965722cc64a2ca5d5d0b7a4fa59d4">还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</div><div class="notion-text notion-block-a129f65233c0464bab53a9dbd4bf5083">TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <code class="notion-inline-code">ssthresh</code> 和 <code class="notion-inline-code">cwnd</code> 变化如下：</div><ul class="notion-list notion-list-disc notion-block-ab75d6f8ca5143fc9e9d497f648105c2"><li><code class="notion-inline-code">cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li></ul><ul class="notion-list notion-list-disc notion-block-3d3338cbf47f402f81b5d4d8aae9d6ec"><li><code class="notion-inline-code">ssthresh = cwnd</code>;</li></ul><ul class="notion-list notion-list-disc notion-block-a58b9ccc933d4e36ac306decd5665a99"><li><b>进入快速恢复算法</b></li></ul><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-97028e27aa3d4ba9b41099c57cfa23a1" data-id="97028e27aa3d4ba9b41099c57cfa23a1"><span><div id="97028e27aa3d4ba9b41099c57cfa23a1" class="notion-header-anchor"></div><a class="notion-hash-link" href="#97028e27aa3d4ba9b41099c57cfa23a1" title="快速恢复"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">快速恢复</span></span></h3><div class="notion-text notion-block-ecafa4786a194e4b9b3cf5d88bb9f0d7">快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code class="notion-inline-code">RTO</code> 超时那么强烈。</div><div class="notion-text notion-block-0954483aa2e24e688b2eb0e82f327bb4">正如前面所说，进入快速恢复之前，<code class="notion-inline-code">cwnd</code> 和 <code class="notion-inline-code">ssthresh</code> 已被更新了：</div><ul class="notion-list notion-list-disc notion-block-c7a27e5352174524bd05b1769a2c8425"><li><code class="notion-inline-code">cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li></ul><ul class="notion-list notion-list-disc notion-block-8ce1629d423f4d7bbc45717ea27dc39e"><li><code class="notion-inline-code">ssthresh = cwnd</code>;</li></ul><div class="notion-text notion-block-dd170cb906f748c8aab88a233c628a40">然后，进入快速恢复算法如下：</div><ul class="notion-list notion-list-disc notion-block-c0cb1ee53a7c4c419a34b10193f11ac9"><li>拥塞窗口 <code class="notion-inline-code">cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li></ul><ul class="notion-list notion-list-disc notion-block-3081b6751dc2464f86c126e69cc7902e"><li>重传丢失的数据包；</li></ul><ul class="notion-list notion-list-disc notion-block-9b4dd01c300f4e96b61ca8196a60e81c"><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li></ul><ul class="notion-list notion-list-disc notion-block-5cf2bdd7d8e7435e8d03afb3c4f35a33"><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><div class="notion-text notion-block-b814fb1cb4aa426597ad86beb043f5d0">也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-ac728d7c5a3842b6a5de0688cc41f7da"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdf302fba-21b0-41ee-b0a0-542a3da54b70%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105341Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D3a715be76ea60e59013cea027eaacca325d4c5486269a9a34ec4f43acf9eee2f%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=ac728d7c-5a38-42b6-a5de-0688cc41f7da&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-5bba1988e4644774a2a9e360014ed58d">很多人问题，快速恢复算法过程中，为什么收到新的数据后，cwnd 设置回了 ssthresh ？</div><ol start="1" class="notion-list notion-list-numbered notion-block-3bb73c10a60e40ab91ab6f8e7c6fc4b1"><li>在快速恢复的过程中，首先 ssthresh = cwnd/2，然后 cwnd = ssthresh + 3，表示网络可能出现了阻塞，所以需要减小 cwnd 以避免，加 3 代表快速重传时已经确认接收到了 3 个重复的数据包；</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-6ca27fc6ca224950bc8cc625bab3c996"><li>随后继续重传丢失的数据包，如果再收到重复的 ACK，那么 cwnd 增加 1。加 1 代表每个收到的重复的 ACK 包，都已经离开了网络。这个过程的目的是尽快将丢失的数据包发给目标。</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-44259fad313443cdab59492610fafcd4"><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，恢复过程结束。</li></ol><div class="notion-text notion-block-455b074b0ead43ada31d98c31af343e8"><b>首先，快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低 cwnd 来减缓拥塞，所以必然会出现 cwnd 从大到小的改变。</b></div><div class="notion-text notion-block-4302b9194dfe42649fb1b56cee61c3de"><b>其次，过程2（cwnd逐渐加1）的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题（三次相同的 ACK 导致的快速重传），所以这一过程中 cwnd 反而是逐渐增大的。</b></div><div class="notion-text notion-block-fe5f0879ecee4336ab43366020f8138e"><span class="notion-yellow_background">总结：</span></div><ul class="notion-list notion-list-disc notion-block-b7a5aa7457c74268a95c8ac76ff93b96"><li>首先减半cwnd，然后将阈值设置为减半后的cwnd</li></ul><ul class="notion-list notion-list-disc notion-block-eda707fa712a4967a6bec0a37e6bdf1e"><li>进入恢复阶段，此时的目标是将数据包尽可能的重传给对方，cwnd += 3表示之前接收了3个相同的ACK，然后进入线性增长</li></ul><ul class="notion-list notion-list-disc notion-block-b5172fbf5902494296b7882a37c3f9eb"><li>如果收到新的ACK，表示恢复阶段结束，将cwnd设置回阈值，避免拥塞</li></ul><div class="notion-blank notion-block-0447e7d387644a6ab1ff333157f489e1"> </div><div class="notion-blank notion-block-2b508539f113452fac6149805dca28e6"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-874fef272d30445fbc0e722e59292e20" data-id="874fef272d30445fbc0e722e59292e20"><span><div id="874fef272d30445fbc0e722e59292e20" class="notion-header-anchor"></div><a class="notion-hash-link" href="#874fef272d30445fbc0e722e59292e20" title="Ref"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Ref</span></span></h2><div class="notion-text notion-block-2f9599a8b3ea402dbb37965dc19fd2c9"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://juejin.cn/post/7080339555995369503">【计算机网络】TCP的流量控制和拥塞控制 - 掘金 (juejin.cn)</a></div><div class="notion-text notion-block-ade79624e7b7459ab13940b14279c2df"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.zhihu.com/question/38749788">流量控制与拥塞控制的区别。为什么要把流量控制与拥塞控制分为两个名词？ - 知乎 (zhihu.com)</a></div><div class="notion-text notion-block-9ee0f12195874f97ade8845bb1918d95"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0">4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding (xiaolincoding.com)</a></div><div class="notion-text notion-block-35bfa4a49f1b40918663922f66b7f7f2"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://blog.csdn.net/wdscq1234/article/details/52503315"> TCP-IP详解：SACK选项（Selective Acknowledgment）_CQ小子的博客-CSDN博客</a></div><div class="notion-blank notion-block-811c6228f41b41a3a0d8c72c8ca30e16"> </div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Mutex实现]]></title>
            <link>https://hhmy27.github.io//mutex</link>
            <guid>https://hhmy27.github.io//mutex</guid>
            <pubDate>Tue, 22 Nov 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-e7f7db5d3e804afba4a84863c5302031"><div class="notion-viewport"></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-04c905526f5847d698f2d2cb225568f5" data-id="04c905526f5847d698f2d2cb225568f5"><span><div id="04c905526f5847d698f2d2cb225568f5" class="notion-header-anchor"></div><a class="notion-hash-link" href="#04c905526f5847d698f2d2cb225568f5" title="初代mutex"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">初代mutex</span></span></h2><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-c7c47b041c694ac2979cf12c9735d48a"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1d57b8cd-39e8-491f-98d8-b58d4d173842%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105342Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D9a21e6436b63e9ab3d7700ea96f306918aadb15242bcf98ea719e8095a7ec515%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=c7c47b04-1c69-4ac2-979c-f12c9735d48a&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-eb6d7a9b0bf24e45b9553103990728be">特点：</div><ul class="notion-list notion-list-disc notion-block-8df29c2fee32404cbb9b9db5333c3de4"><li>只有key和sema两个变量，利用CAS从左值</li></ul><ul class="notion-list notion-list-disc notion-block-2e232adefe2d4b2aba7f7726820e303b"><li>key：表示持有锁和等待锁的数量</li></ul><ul class="notion-list notion-list-disc notion-block-da9995aeffe6443195a2dda6b2b36b36"><li>sema：等待者队列使用的信号量</li></ul><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-93767f90a23c428aad6bc2e7e1fb89ca"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F089431dc-95ae-47ea-a360-feb9284f2379%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105342Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D613c865f09ea63234d5afaf9ea166a2d6c1e27571be51a4bc4d900bdb16b88ad%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=93767f90-a23c-428a-ad6b-c2e7e1fb89ca&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-f0c9fa92ac46476eaf7ece2e0393f610">逻辑还是一样的：</div><ul class="notion-list notion-list-disc notion-block-2479f8de639744d7a6beda58b7363231"><li>Lock，尝试加锁，使用cas对key操作，如果结果为1，表示持有成功，否则阻塞等待sema</li></ul><ul class="notion-list notion-list-disc notion-block-87770a7c56d0418da3706811c54c91cd"><li>Unlock，解锁，对key操作，如果为0，则没有等待者可以直接返回，否则唤醒sema的等待者</li></ul><div class="notion-text notion-block-b384572855cf4441b18d74e59f498bbf">注意：</div><ul class="notion-list notion-list-disc notion-block-3a229490f59e41f288232ac29581feec"><li>Unlock没有对调用者做检查，不是锁的持有者也可以释放锁。因此我们一般使用defer来进行优化调用</li><ul class="notion-list notion-list-disc notion-block-3a229490f59e41f288232ac29581feec"><pre class="notion-code language-go"><code class="language-go">mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
defer mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></ul></ul><div class="notion-blank notion-block-56c98aac4c9a46e2bce8a2847092248a"> </div><div class="notion-text notion-block-3b098aa79076440396a73e904d6a0a41">这个版本的实现遗留了一个问题，请求锁的goroutine会排队等待获取互斥锁，也就是公平锁，我们先实现一个非公平锁，让正在占用CPU时间片的goroutine先获取到锁，这样能够避免做上下文的切换</div><div class="notion-blank notion-block-ded130c1c43c43dc87dd39a94ee16fbe"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-290a37c1e6a04c20afea447a9c34f362" data-id="290a37c1e6a04c20afea447a9c34f362"><span><div id="290a37c1e6a04c20afea447a9c34f362" class="notion-header-anchor"></div><a class="notion-hash-link" href="#290a37c1e6a04c20afea447a9c34f362" title="非公平锁"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">非公平锁</span></span></h2><div class="notion-text notion-block-229a5945de6748d8a6310b0d8a013d52">做了一次调整</div><pre class="notion-code language-go"><code class="language-go">type Mutex struct <span class="token punctuation">{</span>
        state int32
        sema  uint32
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> <span class="token punctuation">(</span>
        mutexLocked <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> iota <span class="token comment">// mutex is locked</span>
        mutexWoken
        mutexWaiterShift <span class="token operator">=</span> iota
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-f04df2739e7746c983ed0031299f88d0"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9c456516-c885-4335-8d79-cd694989abf7%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105342Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D3595ebac9d6a91004da986a8f8fff17ff3a4ab682a0101076d480da386517186%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=f04df273-9e77-46c9-83ed-0031299f88d0&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-d589b2f1563a4409a9bfdfb6fdb8e5aa">这里state是一个复合型的字段，包含了多个信息，和java线程池表示状态的实现很类似</div><ul class="notion-list notion-list-disc notion-block-ca214425388a409a9eb86b40983d47a0"><li>第一位（低位）表示锁是否被持有</li></ul><ul class="notion-list notion-list-disc notion-block-6eb0a24601ef437189ff700ad293c899"><li>第二位表示是否有唤醒的goroutine</li></ul><ul class="notion-list notion-list-disc notion-block-73219887125148a2ba940b897cdd1bbd"><li>第三位表示等待此锁的goroutine</li></ul><div class="notion-text notion-block-03dc36a09e254ad79810fcaf73ed0028">加锁方法变复杂了</div><pre class="notion-code language-go"><code class="language-go"><span class="token function">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Mutex<span class="token punctuation">)</span> <span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Fast path: 幸运case，能够直接获取到锁</span>
        <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapInt32</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mutexLocked</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">}</span>
        <span class="token literal-property property">awoke</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token boolean">false</span>
        <span class="token keyword">for</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">old</span> <span class="token operator">:</span><span class="token operator">=</span> m<span class="token punctuation">.</span>state
            <span class="token keyword">new</span> <span class="token operator">:</span><span class="token operator">=</span> old <span class="token operator">|</span> mutexLocked <span class="token comment">// 新状态加锁</span>
            <span class="token keyword">if</span> old<span class="token operator">&amp;</span>mutexLocked <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
                <span class="token keyword">new</span> <span class="token operator">=</span> old <span class="token operator">+</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span>mutexWaiterShift <span class="token comment">//等待者数量加一</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> awoke <span class="token punctuation">{</span>
                <span class="token comment">// goroutine是被唤醒的，</span>
                <span class="token comment">// 新状态清除唤醒标志</span>
                <span class="token keyword">new</span> <span class="token operator">&amp;</span><span class="token operator">^=</span> mutexWoken
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapInt32</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> old<span class="token punctuation">,</span> <span class="token keyword">new</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//设置新状态</span>
                <span class="token keyword">if</span> old<span class="token operator">&amp;</span>mutexLocked <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span> <span class="token comment">// 锁原状态未加锁</span>
                    <span class="token keyword">break</span>
                <span class="token punctuation">}</span>
                runtime<span class="token punctuation">.</span><span class="token function">Semacquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>sema<span class="token punctuation">)</span> <span class="token comment">// 请求信号量</span>
                awoke <span class="token operator">=</span> <span class="token boolean">true</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span></code></pre><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-613f5493053a42ffb024acdfae5b3d15" data-id="613f5493053a42ffb024acdfae5b3d15"><span><div id="613f5493053a42ffb024acdfae5b3d15" class="notion-header-anchor"></div><a class="notion-hash-link" href="#613f5493053a42ffb024acdfae5b3d15" title="自旋版本"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">自旋版本</span></span></h2><div class="notion-blank notion-block-6d730068ae51489aa1ef6fcc32d49f59"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-03fb9424a57846039fdb1bdc86b9d178" data-id="03fb9424a57846039fdb1bdc86b9d178"><span><div id="03fb9424a57846039fdb1bdc86b9d178" class="notion-header-anchor"></div><a class="notion-hash-link" href="#03fb9424a57846039fdb1bdc86b9d178" title="解决饥饿"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">解决饥饿</span></span></h2><div class="notion-blank notion-block-4c0b510234b44b3087ec05579db1da07"> </div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Go的new和make区别]]></title>
            <link>https://hhmy27.github.io//new-and-make</link>
            <guid>https://hhmy27.github.io//new-and-make</guid>
            <pubDate>Mon, 21 Nov 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-14b6937ec53648c795f8b71b569ebc4d"><div class="notion-viewport"></div><div class="notion-table-of-contents notion-gray notion-block-1d25098fe6914ab68e052daa2ad1ec11"><a href="#05368d46c4f14a12a42c66c31f0baf82" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">简介</span></a><a href="#3d6d675234cc43b098f1324b156e2e18" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">make</span></a><a href="#46ae8ed7d7ee4b67ae48a689a9253e8c" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">new</span></a><a href="#9124ef644fc444ec9ca272a3146d0bcf" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">扩展</span></a><a href="#814be095d01d4014813bc448fb6039fe" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">指针比较原则</span></a><a href="#539338a95f7a465e949fa9795cdf6c44" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">传引用？还是传值？</span></a><a href="#3bf8e86a442b4df58c50ed9f3d1c2648" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">Ref</span></a></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-05368d46c4f14a12a42c66c31f0baf82" data-id="05368d46c4f14a12a42c66c31f0baf82"><span><div id="05368d46c4f14a12a42c66c31f0baf82" class="notion-header-anchor"></div><a class="notion-hash-link" href="#05368d46c4f14a12a42c66c31f0baf82" title="简介"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">简介</span></span></h2><div class="notion-text notion-block-9e7841fe7d184f47848feba93d01fde4">先上结论</div><div class="notion-text notion-block-c270d5ba017749a89bde6a28d3611cfb"><code class="notion-inline-code">new(T)</code>返回T类型的指针，指向T类型的零值</div><div class="notion-text notion-block-35b4c30f029c4b19990fa0eeba0c36aa"><code class="notion-inline-code">make(T)</code>返回初始化后的T的引用，只能用于<code class="notion-inline-code">slice、map、channel</code></div><div class="notion-text notion-block-44cf9019a007420caa4dd1753719b8a3">在Go里面，你几乎很少会遇到必须使用new的场景</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-3d6d675234cc43b098f1324b156e2e18" data-id="3d6d675234cc43b098f1324b156e2e18"><span><div id="3d6d675234cc43b098f1324b156e2e18" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3d6d675234cc43b098f1324b156e2e18" title="make"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">make</span></span></h2><div class="notion-text notion-block-38ac86c4c1684d43b055aed779b709d9">make用来初始化<code class="notion-inline-code">slice、map、channel</code>，并返回这些结构的引用</div><div class="notion-text notion-block-db3665094e09475a80d94803a0d31cf8">如果我们使用<code class="notion-inline-code">var</code> 来声明一个结构体，将会是nil值，对nil值操作可能会引起panic，只有赋值之后才能使用，下面我们看看这个测试用例</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestMake</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> m1 map<span class="token punctuation">[</span>int<span class="token punctuation">]</span>string
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#v\n"</span><span class="token punctuation">,</span> m1<span class="token punctuation">)</span>

	<span class="token literal-property property">m2</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>int<span class="token punctuation">]</span>string<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#v\n"</span><span class="token punctuation">,</span> m2<span class="token punctuation">)</span>

	<span class="token keyword">var</span> c1 chan string
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#v\n"</span><span class="token punctuation">,</span> c1<span class="token punctuation">)</span>

	<span class="token literal-property property">c2</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>chan string<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#v\n"</span><span class="token punctuation">,</span> c2<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-43b536c593ee4afa90e59b959545d0cf">输出结果：</div><pre class="notion-code language-go"><code class="language-go">map<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token function">string</span><span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
map<span class="token punctuation">[</span>int<span class="token punctuation">]</span>string<span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">(</span>chan string<span class="token punctuation">)</span><span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
<span class="token punctuation">(</span>chan string<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0x140000c0240</span><span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-bb2b6747131f4535aa7ca7c7997211a5">可以看到确实是符合我们上面的分析</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-46ae8ed7d7ee4b67ae48a689a9253e8c" data-id="46ae8ed7d7ee4b67ae48a689a9253e8c"><span><div id="46ae8ed7d7ee4b67ae48a689a9253e8c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#46ae8ed7d7ee4b67ae48a689a9253e8c" title="new"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">new</span></span></h2><div class="notion-text notion-block-e95f4078f6264a648b3df362559ebd28"><code class="notion-inline-code">new(T)</code> 适用的T范围更广，它返回T类型的指针，指向T类型的零值</div><div class="notion-text notion-block-8804f3e1d8ff44e5b423f33b4486ddd9">比如说这个例子：</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestNew</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> p1 <span class="token operator">*</span>int
	<span class="token literal-property property">a</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">1</span>
	<span class="token comment">// fmt.Println(*p1) p1 is nil, panic</span>
	p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>p1<span class="token punctuation">)</span>

	<span class="token literal-property property">p2</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span>
	p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>a
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-acc7768e1dd9492ba52ac32484a0841c">输出：</div><pre class="notion-code language-go"><code class="language-go"><span class="token number">1</span>
<span class="token number">0</span>
<span class="token number">1</span></code></pre><div class="notion-text notion-block-a006a90d6fdf4ff9aa6bb3958140ed99">我们可以通过这个例子看到<code class="notion-inline-code">var</code> 和<code class="notion-inline-code">new</code> 的区别，<code class="notion-inline-code">var</code>一个指针此时是nil的，未经赋值直接使用会panic，而<code class="notion-inline-code">new</code>就不会有这种问题出现</div><div class="notion-text notion-block-c9e79494a043470d9662528e870b1ad5">实际上我们很少会用到<code class="notion-inline-code">new</code> 因为它总是可以被其它操作替代</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestNew2</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> car1 <span class="token operator">*</span>Car
	<span class="token literal-property property">InnerCar</span> <span class="token operator">:</span><span class="token operator">=</span> Car<span class="token punctuation">{</span><span class="token punctuation">}</span>
	car1 <span class="token operator">=</span> <span class="token operator">&amp;</span>InnerCar

	<span class="token keyword">var</span> car2 <span class="token operator">*</span>Car <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>Car<span class="token punctuation">)</span>

	<span class="token literal-property property">car3</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token operator">&amp;</span>Car<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 最简洁的方式</span>

	<span class="token literal-property property">car4</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>Car<span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>car1<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>car2<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>car3<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>car4<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-66653bda38a0442eb98dfffaf3b23a5f">输出结果：</div><pre class="notion-code language-go"><code class="language-go"><span class="token number">0</span>
<span class="token number">0</span>
<span class="token number">0</span>
<span class="token number">0</span></code></pre><div class="notion-text notion-block-c96ab88ec44147c88709cd1154cd4d69">你可以看到上面四种Car都是指针，它们输出结果都是一致的，其中<code class="notion-inline-code">&amp;Car</code>是最简洁的声明方式了</div><div class="notion-text notion-block-36600af4f04e4f23854c9b8c28523575">C/C++语言的选手可能会感到疑惑，为什么不用<code class="notion-inline-code">(&amp;Car3).id</code> 也能拿到<code class="notion-inline-code">id</code>的值呢？</div><div class="notion-text notion-block-72d013a6b112411ab11aa0978304f6b3">这是因为Go从语言层面做了优化：</div><blockquote class="notion-quote notion-block-43f29b0b6df14708b7dc306597802f59">如果x是指针，&amp;x里面属性集合包含了m，那么x.m和(&amp;x).m是等价的，Go会自动转换</blockquote><div class="notion-blank notion-block-4e64fe4926c943a2893625bb0b4775cd"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-9124ef644fc444ec9ca272a3146d0bcf" data-id="9124ef644fc444ec9ca272a3146d0bcf"><span><div id="9124ef644fc444ec9ca272a3146d0bcf" class="notion-header-anchor"></div><a class="notion-hash-link" href="#9124ef644fc444ec9ca272a3146d0bcf" title="扩展"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">扩展</span></span></h2><div class="notion-text notion-block-b1db98e9a70e4a49ab56ecc99055e7bf">既然提到了指针，我们来聊聊指针相关的东西吧</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-814be095d01d4014813bc448fb6039fe" data-id="814be095d01d4014813bc448fb6039fe"><span><div id="814be095d01d4014813bc448fb6039fe" class="notion-header-anchor"></div><a class="notion-hash-link" href="#814be095d01d4014813bc448fb6039fe" title="指针比较原则"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">指针比较原则</span></span></h3><div class="notion-text notion-block-c52c04f2c09843cca8dada1c3337d495">Go定义了指针比较原则：</div><ul class="notion-list notion-list-disc notion-block-37f7998564464e7fb920567738d83ed8"><li>只有同类型的指针才能比较</li></ul><div class="notion-text notion-block-3897df8f0195455f84a1928936c038e5">如果你在1.18之前尝试对不同类型的指针比较，就会报错，提示你：</div><pre class="notion-code language-go"><code class="language-go"><span class="token punctuation">.</span><span class="token operator">/</span>slice_test<span class="token punctuation">.</span>go<span class="token operator">:</span><span class="token number">120</span><span class="token operator">:</span><span class="token number">17</span><span class="token operator">:</span> invalid operation<span class="token operator">:</span> p4 <span class="token operator">==</span> <span class="token function">p5</span> <span class="token punctuation">(</span>mismatched types <span class="token operator">*</span>int and <span class="token operator">*</span>string<span class="token punctuation">)</span>
<span class="token literal-property property">note</span><span class="token operator">:</span> module requires Go <span class="token number">1.18</span></code></pre><ul class="notion-list notion-list-disc notion-block-f8325c96b53647edb5e96f3ae3425cc8"><li>指针指向同一个对象，或者都是nil的时候比较结果是<code class="notion-inline-code">true</code></li></ul><ul class="notion-list notion-list-disc notion-block-5ed686df2cde4eccb3be792a1a6c4986"><li>否则比较结果都是<code class="notion-inline-code">false</code></li></ul><div class="notion-text notion-block-fa0122580af9484bb6c2db9d5c939a73">比如这个例子</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestNil</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> p1 <span class="token operator">*</span>int
	<span class="token keyword">var</span> p2 <span class="token operator">*</span>int
	<span class="token literal-property property">a</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">1</span>
	<span class="token literal-property property">p3</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span>
	p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>a
	<span class="token literal-property property">p4</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token operator">&amp;</span>a

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token comment">// true, p1 and p2 is nil</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p2 <span class="token operator">==</span> p3<span class="token punctuation">)</span> <span class="token comment">// false, p2 is nil, p3 non-nil </span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p4 <span class="token operator">==</span> p3<span class="token punctuation">)</span> <span class="token comment">// true, p3 and p4 指向同一个对象</span>
<span class="token punctuation">}</span></code></pre><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-539338a95f7a465e949fa9795cdf6c44" data-id="539338a95f7a465e949fa9795cdf6c44"><span><div id="539338a95f7a465e949fa9795cdf6c44" class="notion-header-anchor"></div><a class="notion-hash-link" href="#539338a95f7a465e949fa9795cdf6c44" title="传引用？还是传值？"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">传引用？还是传值？</span></span></h3><div class="notion-text notion-block-eef75676265a4557be2d98a7ff370022">先说结论：Go是值传递，所有类型数据都会拷贝一个副本到函数里面。</div><div class="notion-text notion-block-0345897226dd484e90c5731c25ba9aa3">但是Go又把数据类型分为两种：</div><ul class="notion-list notion-list-disc notion-block-5052e00a25cf4f9b91c300d08bb1ceb0"><li>引用类型：指针、slice、map、channel、接口、函数等</li></ul><ul class="notion-list notion-list-disc notion-block-f08bafb7c5944e6cba96df46cfb94f1d"><li>非引用类型：int、string、float、bool、数组和struct</li></ul><div class="notion-text notion-block-6643b0e10d45456293be0faefee5d5ca">引用类型传递的时候依然会拷贝一个副本，但是这个副本和引用指向了同一个对象，因此函数内的修改会影响原引用数据</div><div class="notion-text notion-block-79b28e868638493dae8bb175f78c39d1">而非引用类型就是普通的值传递了，不会影响到原有的数据</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestModify</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">a</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">1</span>
	<span class="token function">modifyInt</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 没有改变</span>

	<span class="token literal-property property">b</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>int<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
	<span class="token function">modifySlice</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">// 被改变了</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-4d76754c1cb64041b56caaf2048b95ac">输出结果：</div><pre class="notion-code language-go"><code class="language-go"><span class="token operator">-</span><span class="token number">1</span>
<span class="token number">1</span>
<span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">]</span></code></pre><div class="notion-blank notion-block-e5db92411295470b86e4d51a2fb4cf3e"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-3bf8e86a442b4df58c50ed9f3d1c2648" data-id="3bf8e86a442b4df58c50ed9f3d1c2648"><span><div id="3bf8e86a442b4df58c50ed9f3d1c2648" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3bf8e86a442b4df58c50ed9f3d1c2648" title="Ref"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Ref</span></span></h2><div class="notion-text notion-block-4a1fe34105a04d5e8888a67ed4395bd7"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://sanyuesha.com/2017/07/26/go-make-and-new/">理解 Go make 和 new 的区别 | 三月沙 (sanyuesha.com)</a></div><div class="notion-text notion-block-d60227a1cee04074bee019e88c482f0b"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.nhooo.com/golang/go-comparing-pointers.html">Go 语言指针比较 - Golang教程 - 基础教程在线 (nhooo.com)</a></div><div class="notion-text notion-block-247bc3c955be4b26a880c853de1b0ec0"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://zhuanlan.zhihu.com/p/383737884">Go的参数是传值还是传引用问题 - 知乎 (zhihu.com)</a></div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[聊聊Go的slice]]></title>
            <link>https://hhmy27.github.io//slice</link>
            <guid>https://hhmy27.github.io//slice</guid>
            <pubDate>Sun, 20 Nov 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-ed276d453e9140f4b3f7559061948489"><div class="notion-viewport"></div><div class="notion-table-of-contents notion-gray notion-block-bee150871fde4b1cbd4e958755ce42cd"><a href="#0d1b38c882ad46fdb186f3b4af64e890" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">查看slice的源码</span></a><a href="#b58282d0f068407b84c4415bd40ed44a" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">slice的初始化</span></a><a href="#96d380b7ecf94d1390f8ab6bcf282d53" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">slice的扩容机制</span></a><a href="#0544a40b35f941b0a5e15b1fdd0fea81" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">step 1. 步长</span></a><a href="#1d520e60088a438196033605ea112e4b" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">step 2. 内存对齐</span></a><a href="#b8ea8a743b7547b9afe37016e9d02d7b" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">总结</span></a><a href="#140a6d0f54004b3caa47abd1c65f52ad" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">slice的拷贝</span></a><a href="#1b0c90c1f9d547ba8ceae8e57c874be5" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">slice遍历的坑</span></a><a href="#4b2034c183954853b014953d8d61528e" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">一些问题</span></a><a href="#757d0ca7c7a24bfda45057a9bf0282f0" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">总结</span></a><a href="#e9f2d4601ba5407a9ac107f59828d6e8" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">Ref</span></a></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-0d1b38c882ad46fdb186f3b4af64e890" data-id="0d1b38c882ad46fdb186f3b4af64e890"><span><div id="0d1b38c882ad46fdb186f3b4af64e890" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0d1b38c882ad46fdb186f3b4af64e890" title="查看slice的源码"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">查看slice的源码</span></span></h2><div class="notion-text notion-block-afecb652d8c7499fa8b37e236d8038ee">查看go的版本</div><pre class="notion-code language-bash"><code class="language-bash">$ go version
go version go1<span class="token punctuation">.</span><span class="token number">16.15</span> darwin<span class="token operator">/</span>arm64</code></pre><div class="notion-text notion-block-a33a5f82359c41709eb13db2a27c3fdc">切换到我们的go安装路径，输入</div><pre class="notion-code language-bash"><code class="language-bash">$ grep <span class="token operator">-</span>n <span class="token string">"type slice struct"</span> <span class="token operator">-</span>r <span class="token punctuation">.</span><span class="token operator">/</span></code></pre><div class="notion-text notion-block-3efd2554ee4848e6948e17e340d11f33">得到输出</div><pre class="notion-code language-bash"><code class="language-bash"><span class="token punctuation">.</span><span class="token comment">//src/cmd/compile/internal/gc/go.go:77:// type slice struct {</span>
<span class="token punctuation">.</span><span class="token comment">//src/runtime/slice.go:13:type slice struct {</span></code></pre><div class="notion-text notion-block-d975d1bfb0b141a8a12d180b28839997">我们直接进<code class="notion-inline-code">slice.go</code> 这个文件看下</div><div class="notion-text notion-block-c410af47283548019f1e53a1e9cd346d">算上注释也就300行不到的代码，短小精悍，看看定义和函数列表</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-0ba992f76fff4750a224825dced20631"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc570d58b-7992-4cca-b1c1-ad9aea894226%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105342Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D401528538b6d83a38b78be1648359d0962683e187f35c8ccdd006731312919ce%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=0ba992f7-6fff-4750-a224-825dced20631&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-1997db5fab8544fbb33a846172d48e3d">结构体定义</div><pre class="notion-code language-go"><code class="language-go">type slice struct <span class="token punctuation">{</span>
	array unsafe<span class="token punctuation">.</span>Pointer    <span class="token comment">// 底层数组</span>
	len   int               <span class="token comment">// 数组长度</span>
	cap   int               <span class="token comment">// 数组容量</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-a59fd1a70e294cebb69c405cf67d90c6">slice是在底层的数组上面包了一层，array是指向底层数组的指针，底层数组是真正存储值的地方。而len和cap和分别表示数组当前长度和数组的容量，slice根据它们的大小关系来进行扩容。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-b58282d0f068407b84c4415bd40ed44a" data-id="b58282d0f068407b84c4415bd40ed44a"><span><div id="b58282d0f068407b84c4415bd40ed44a" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b58282d0f068407b84c4415bd40ed44a" title="slice的初始化"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">slice的初始化</span></span></h2><div class="notion-text notion-block-f8ccd834d0004691abb56a46410f2f3e">我们初始化一个slice，可以有两种方法，分别是：</div><pre class="notion-code language-go"><code class="language-go"><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>int<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>    <span class="token comment">// 初始化size为5，cap为5的slice</span>
<span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>int<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">// 初始化size为0，cap为5的slice，推荐使用该方式</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>int<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// 直接给定值声明</span></code></pre><div class="notion-text notion-block-847b28c8de4a4c49ba6aa40b049a9746">对于slice来说，make的第一个参数指定存储类型，这里是<code class="notion-inline-code">int</code>，第二个是size，可选为0，第三个是cap，指定容量</div><div class="notion-text notion-block-a4e3964a2af44c22b039ad68cc7bc7a1">我们一般推荐使用第二种方式，指定好cap，避免扩容带来的开销，而size我们一般指定为0，表示不存储任何元素。</div><div class="notion-text notion-block-774d631d482546ab9b481829ced121c3">如果我们指定了size，那么会在生成size个默认值在slice中，比如说int类型的默认值就是0。请看下面的打印结果</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestSlice</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">a</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>int<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token literal-property property">i</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		a <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token literal-property property">b</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>int<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token literal-property property">i</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		b <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token literal-property property">c</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>int<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 输出</span>
<span class="token comment">// [0 0 0 0 0 1 2 3 4 5] 10 10</span>
<span class="token comment">// [1 2 3 4 5] 5 10</span></code></pre><div class="notion-text notion-block-6a0b2874c3c04edca5ca741634a50d9e">用<code class="notion-inline-code">make([]int, size)</code> 方式初始化，很容易忘记我们已经存储了若干个值了。除非我们真的需要这样的slice，不然还是用第二种初始化方式比较好。</div><div class="notion-text notion-block-c38290ed650d438ebf219a8c045a85f4">下面我们看看初始化的源码：</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">makeslice</span><span class="token punctuation">(</span>et <span class="token operator">*</span>_type<span class="token punctuation">,</span> len<span class="token punctuation">,</span> cap int<span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{</span>
	mem<span class="token punctuation">,</span> <span class="token literal-property property">overflow</span> <span class="token operator">:</span><span class="token operator">=</span> math<span class="token punctuation">.</span><span class="token function">MulUintptr</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>cap<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> overflow <span class="token operator">||</span> mem <span class="token operator">></span> maxAlloc <span class="token operator">||</span> len <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> len <span class="token operator">></span> cap <span class="token punctuation">{</span>
		<span class="token comment">// NOTE: Produce a 'len out of range' error instead of a</span>
		<span class="token comment">// 'cap out of range' error when someone does make([]T, bignumber).</span>
		<span class="token comment">// 'cap out of range' is true too, but since the cap is only being</span>
		<span class="token comment">// supplied implicitly, saying len is clearer.</span>
		<span class="token comment">// See golang.org/issue/4085.</span>
		mem<span class="token punctuation">,</span> <span class="token literal-property property">overflow</span> <span class="token operator">:</span><span class="token operator">=</span> math<span class="token punctuation">.</span><span class="token function">MulUintptr</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> overflow <span class="token operator">||</span> mem <span class="token operator">></span> maxAlloc <span class="token operator">||</span> len <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token function">panicmakeslicelen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token function">panicmakeslicecap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>mem<span class="token punctuation">,</span> et<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-2a4c454c815740a3a305d4bdff6aa84b">外部的逻辑是检查我们开的容量会不会溢出，如果溢出就抛出panic，否则的话调用<code class="notion-inline-code">mallocgc</code> 进行初始化，mallocgc的源码涉及到一些go内存分配的知识，这里就不展开了，感兴趣可以自己看看。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-96d380b7ecf94d1390f8ab6bcf282d53" data-id="96d380b7ecf94d1390f8ab6bcf282d53"><span><div id="96d380b7ecf94d1390f8ab6bcf282d53" class="notion-header-anchor"></div><a class="notion-hash-link" href="#96d380b7ecf94d1390f8ab6bcf282d53" title="slice的扩容机制"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">slice的扩容机制</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-0544a40b35f941b0a5e15b1fdd0fea81" data-id="0544a40b35f941b0a5e15b1fdd0fea81"><span><div id="0544a40b35f941b0a5e15b1fdd0fea81" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0544a40b35f941b0a5e15b1fdd0fea81" title="step 1. 步长"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">step 1. 步长</span></span></h3><div class="notion-text notion-block-3ff3b7a98c5f43c0ae151afb2e790da7">当我们len超过cap的时候就会触发扩容，实际调用的函数是<code class="notion-inline-code">growslice</code>，我们来看看go是怎么实现的</div><pre class="notion-code language-go"><code class="language-go"><span class="token comment">// growslice handles slice growth during append.</span>
<span class="token comment">// It is passed the slice element type, the old slice, and the desired new minimum capacity,</span>
<span class="token comment">// and it returns a new slice with at least that capacity, with the old data</span>
<span class="token comment">// copied into it.</span>
<span class="token comment">// The new slice's length is set to the old slice's length,</span>
<span class="token comment">// NOT to the new requested capacity.</span>
<span class="token comment">// This is for codegen convenience. The old slice's length is used immediately</span>
<span class="token comment">// to calculate where to write new values during an append.</span>
<span class="token comment">// TODO: When the old backend is gone, reconsider this decision.</span>
<span class="token comment">// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.</span>
func <span class="token function">growslice</span><span class="token punctuation">(</span>et <span class="token operator">*</span>_type<span class="token punctuation">,</span> old slice<span class="token punctuation">,</span> cap int<span class="token punctuation">)</span> slice <span class="token punctuation">{</span>
	<span class="token operator">...</span>
	
	<span class="token literal-property property">newcap</span> <span class="token operator">:</span><span class="token operator">=</span> old<span class="token punctuation">.</span>cap
		<span class="token literal-property property">doublecap</span> <span class="token operator">:</span><span class="token operator">=</span> newcap <span class="token operator">+</span> newcap
		<span class="token keyword">if</span> cap <span class="token operator">></span> doublecap <span class="token punctuation">{</span>
			newcap <span class="token operator">=</span> cap
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> old<span class="token punctuation">.</span>cap <span class="token operator">&lt;</span> <span class="token number">1024</span> <span class="token punctuation">{</span>
				newcap <span class="token operator">=</span> doublecap
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
				<span class="token comment">// Check 0 &lt; newcap to detect overflow</span>
				<span class="token comment">// and prevent an infinite loop.</span>
				<span class="token keyword">for</span> <span class="token number">0</span> <span class="token operator">&lt;</span> newcap <span class="token operator">&amp;&amp;</span> newcap <span class="token operator">&lt;</span> cap <span class="token punctuation">{</span>
					newcap <span class="token operator">+=</span> newcap <span class="token operator">/</span> <span class="token number">4</span>
				<span class="token punctuation">}</span>
				<span class="token comment">// Set newcap to the requested cap when</span>
				<span class="token comment">// the newcap calculation overflowed.</span>
				<span class="token keyword">if</span> newcap <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
					newcap <span class="token operator">=</span> cap
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token operator">...</span>
<span class="token punctuation">}</span></code></pre><table class="notion-simple-table notion-block-91665dd778264dc69173aebebe417922"><tbody><tr class="notion-simple-table-row notion-block-c87f560e793f4ff990bf3befb4594c3a"><td class="" style="width:120px"><div class="notion-simple-table-cell">变量</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">含义</div></td></tr><tr class="notion-simple-table-row notion-block-48ea1d88513b4be7a2ba208a799e86f4"><td class="" style="width:120px"><div class="notion-simple-table-cell">cap</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">期望容量</div></td></tr><tr class="notion-simple-table-row notion-block-6f5da4024d214869a132ea621a54ada9"><td class="" style="width:120px"><div class="notion-simple-table-cell">old.cap</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">当前容量</div></td></tr><tr class="notion-simple-table-row notion-block-6225e51f3b7044a0a34065205638d61e"><td class="" style="width:120px"><div class="notion-simple-table-cell">doublecap</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">当前容量的两倍</div></td></tr><tr class="notion-simple-table-row notion-block-5f4dd636ebe249ec8e1f49f4d844cd31"><td class="" style="width:120px"><div class="notion-simple-table-cell">newcap</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">最终容量</div></td></tr></tbody></table><div class="notion-text notion-block-6b141b6ece554837b7541bb577142844">决策逻辑：</div><ul class="notion-list notion-list-disc notion-block-5576d2cab7c1459f9d39cde67e3d47cd"><li>如果期望容量超过当前容量的两倍，直接设置为期望容量，否则</li></ul><ul class="notion-list notion-list-disc notion-block-9c204879903a43d6a3850999ba4c425b"><li>如果当前容量的值小于1024，直接翻倍，否则</li></ul><ul class="notion-list notion-list-disc notion-block-6a23c330381a423d9f90ab851485a243"><li>如果newcap &lt; cap，不断以1.25倍的速度增长</li></ul><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-87cb9adbe52b4a258daa75edb8b69b64"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb8eced42-e046-4d89-894b-f3331bc1b6e5%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105342Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D93ccd1613e988d4f42216c76911d6cc91513a7fe2f822764eb1e5d3b8282059d%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=87cb9adb-e52b-4a25-8daa-75edb8b69b64&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-blank notion-block-dcf4343653f6413b9a4d5da029a8e0c9"> </div><div class="notion-text notion-block-6afb7cb8c8e34df5a77cb4ce981e2da6">对于1.25倍扩增速度，go的1.18.1版本作出了优化</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">growslice</span><span class="token punctuation">(</span>et <span class="token operator">*</span>_type<span class="token punctuation">,</span> old slice<span class="token punctuation">,</span> cap int<span class="token punctuation">)</span> slice <span class="token punctuation">{</span>
	<span class="token operator">...</span>	
	<span class="token literal-property property">newcap</span> <span class="token operator">:</span><span class="token operator">=</span> old<span class="token punctuation">.</span>cap
	<span class="token literal-property property">doublecap</span> <span class="token operator">:</span><span class="token operator">=</span> newcap <span class="token operator">+</span> newcap
	<span class="token keyword">if</span> cap <span class="token operator">></span> doublecap <span class="token punctuation">{</span>
			newcap <span class="token operator">=</span> cap
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token keyword">const</span> threshold <span class="token operator">=</span> <span class="token number">256</span>
			<span class="token keyword">if</span> old<span class="token punctuation">.</span>cap <span class="token operator">&lt;</span> threshold <span class="token punctuation">{</span>
					newcap <span class="token operator">=</span> doublecap
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
					<span class="token comment">// Check 0 &lt; newcap to detect overflow</span>
					<span class="token comment">// and prevent an infinite loop.</span>
					<span class="token keyword">for</span> <span class="token number">0</span> <span class="token operator">&lt;</span> newcap <span class="token operator">&amp;&amp;</span> newcap <span class="token operator">&lt;</span> cap <span class="token punctuation">{</span>
							<span class="token comment">// Transition from growing 2x for small slices</span>
							<span class="token comment">// to growing 1.25x for large slices. This formula</span>
							<span class="token comment">// gives a smooth-ish transition between the two.</span>
							newcap <span class="token operator">+=</span> <span class="token punctuation">(</span>newcap <span class="token operator">+</span> <span class="token number">3</span><span class="token operator">*</span>threshold<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">4</span>
					<span class="token punctuation">}</span>
					<span class="token comment">// Set newcap to the requested cap when</span>
					<span class="token comment">// the newcap calculation overflowed.</span>
					<span class="token keyword">if</span> newcap <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
							newcap <span class="token operator">=</span> cap
					<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token operator">...</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-08f6a449235d4ed8b8af6abd7625f009">这里的区别就是<code class="notion-inline-code">newcap += (newcap + 3*threshold) / 4</code> ，注释上说相比于旧版本，这里增长速度更加smooth，具体效果可以用python画图模拟一下，这里就不展开了。
</div><div class="notion-text notion-block-ae3a778d52d74d049744e99ce404c9ec">下面我们来看一段代码，看看结果是不是和我们上面分析得一样</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestSlice</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">c</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>int<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token comment">// 此时c满</span>
	c <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token comment">// 此时按照计算公式，期望容量为5，当前容量为2，则c的最终容量是5</span>
	c <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
	<span class="token comment">// 猜测为5 5</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-9fe6c4dd964842b6801a79234485dc1d">但是输出结果是<code class="notion-inline-code">5 6</code>，cap被设置成了6，这是为什么呢？原因是go还会进行内存对齐</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-1d520e60088a438196033605ea112e4b" data-id="1d520e60088a438196033605ea112e4b"><span><div id="1d520e60088a438196033605ea112e4b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1d520e60088a438196033605ea112e4b" title="step 2. 内存对齐"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">step 2. 内存对齐</span></span></h3><pre class="notion-code language-go"><code class="language-go">func <span class="token function">growslice</span><span class="token punctuation">(</span>et <span class="token operator">*</span>_type<span class="token punctuation">,</span> old slice<span class="token punctuation">,</span> cap int<span class="token punctuation">)</span> slice <span class="token punctuation">{</span>
	<span class="token operator">...</span>

	<span class="token literal-property property">newcap</span> <span class="token operator">:</span><span class="token operator">=</span> old<span class="token punctuation">.</span>cap
	<span class="token literal-property property">doublecap</span> <span class="token operator">:</span><span class="token operator">=</span> newcap <span class="token operator">+</span> newcap
	<span class="token keyword">if</span> cap <span class="token operator">></span> doublecap <span class="token punctuation">{</span>
		newcap <span class="token operator">=</span> cap
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> old<span class="token punctuation">.</span>cap <span class="token operator">&lt;</span> <span class="token number">1024</span> <span class="token punctuation">{</span>
			newcap <span class="token operator">=</span> doublecap
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token comment">// Check 0 &lt; newcap to detect overflow</span>
			<span class="token comment">// and prevent an infinite loop.</span>
			<span class="token keyword">for</span> <span class="token number">0</span> <span class="token operator">&lt;</span> newcap <span class="token operator">&amp;&amp;</span> newcap <span class="token operator">&lt;</span> cap <span class="token punctuation">{</span>
				newcap <span class="token operator">+=</span> newcap <span class="token operator">/</span> <span class="token number">4</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// Set newcap to the requested cap when</span>
			<span class="token comment">// the newcap calculation overflowed.</span>
			<span class="token keyword">if</span> newcap <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
				newcap <span class="token operator">=</span> cap
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">var</span> overflow bool
	<span class="token keyword">var</span> lenmem<span class="token punctuation">,</span> newlenmem<span class="token punctuation">,</span> capmem uintptr
	<span class="token comment">// Specialize for common values of et.size.</span>
	<span class="token comment">// For 1 we don't need any division/multiplication.</span>
	<span class="token comment">// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.</span>
	<span class="token comment">// For powers of 2, use a variable shift.</span>
	<span class="token keyword">switch</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> et<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">1</span><span class="token operator">:</span>
		<span class="token operator">...</span>
	<span class="token keyword">case</span> et<span class="token punctuation">.</span>size <span class="token operator">==</span> sys<span class="token punctuation">.</span>PtrSize<span class="token operator">:</span>
		<span class="token operator">...</span>
	<span class="token keyword">case</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token operator">:</span>
		<span class="token keyword">var</span> shift uintptr
		<span class="token keyword">if</span> sys<span class="token punctuation">.</span>PtrSize <span class="token operator">==</span> <span class="token number">8</span> <span class="token punctuation">{</span>
			<span class="token comment">// Mask shift for better code generation.</span>
			shift <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span><span class="token function">Ctz64</span><span class="token punctuation">(</span><span class="token function">uint64</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">63</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			shift <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span><span class="token function">Ctz32</span><span class="token punctuation">(</span><span class="token function">uint32</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">31</span>
		<span class="token punctuation">}</span>
		lenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>old<span class="token punctuation">.</span>len<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> shift
		newlenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>cap<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> shift
		capmem <span class="token operator">=</span> <span class="token function">roundupsize</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>newcap<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> shift<span class="token punctuation">)</span>
		overflow <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>newcap<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>maxAlloc <span class="token operator">>></span> shift<span class="token punctuation">)</span>
		newcap <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>capmem <span class="token operator">>></span> shift<span class="token punctuation">)</span>
	<span class="token keyword">default</span><span class="token operator">:</span>
		<span class="token operator">...</span>
	<span class="token punctuation">}</span>
	<span class="token operator">...</span>

	<span class="token keyword">return</span> slice<span class="token punctuation">{</span>p<span class="token punctuation">,</span> old<span class="token punctuation">.</span>len<span class="token punctuation">,</span> newcap<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-4ee3bdc04a584bcb924d9c8529d6920d">et.size指的是存储元素类型的大小，这里int类型字节是8，使用下面的函数判断通过</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span>x uintptr<span class="token punctuation">)</span> bool <span class="token punctuation">{</span>
	<span class="token keyword">return</span> x<span class="token operator">&amp;</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-1c4689cfe01d4d2e8723a763730600af">先不看代码，我们分析一下怎么内存对齐：</div><div class="notion-text notion-block-cc5a94670ea4443799fc764ca742730a">我们的slice现在存储了5个元素，int类型8个字节，则新的存储容量大小<code class="notion-inline-code">newcap = 5 * 8 = 40</code>，但是为了更好的内存分配减少碎片，go使用了和c一样的内存对齐策略，使用<code class="notion-inline-code">roundupsize</code> 向上调整大小，这里调整成了48，那么最终的<code class="notion-inline-code">cap = 48 / 8 = 6</code>，所以在上面的例子cap被设置为了6</div><div class="notion-text notion-block-d81f5fc71ef04fc0a1ec7c2e84ca0509"><b>为什么被调整到48呢？</b></div><div class="notion-text notion-block-c58832783f0841378fba00e27e1040f7">原因是Go语言的内存管理通常把这些内存块都预先申请好，并且被分为常用的规格，比如8，16， 32， 48， 64等，当我们申请40 bytes的时候，会申请一个足够大的内存块给我们，这就返回的是48 bytes</div><div class="notion-text notion-block-9354acb8e7cb4e3cb912ed480592071a">至于怎么设置的呢，这里有两个很巧妙的函数 <code class="notion-inline-code">Ctz64</code> 和 <code class="notion-inline-code">roundupsize</code></div><pre class="notion-code language-go"><code class="language-go"><span class="token comment">// Ctz64 counts trailing (low-order) zeroes,</span>
<span class="token comment">// and if all are zero, then 64.</span>
<span class="token comment">// 返回x中末尾0的个数</span>
func <span class="token function">Ctz64</span><span class="token punctuation">(</span>x uint64<span class="token punctuation">)</span> int <span class="token punctuation">{</span>
	x <span class="token operator">&amp;=</span> <span class="token operator">-</span>x                       <span class="token comment">// isolate low-order bit</span>
	<span class="token literal-property property">y</span> <span class="token operator">:</span><span class="token operator">=</span> x <span class="token operator">*</span> deBruijn64ctz <span class="token operator">>></span> <span class="token number">58</span>  <span class="token comment">// extract part of deBruijn sequence</span>
	<span class="token literal-property property">i</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>deBruijnIdx64ctz<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// convert to bit index</span>
	<span class="token literal-property property">z</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">57</span> <span class="token operator">&amp;</span> <span class="token number">64</span><span class="token punctuation">)</span>  <span class="token comment">// adjustment if zero</span>
	<span class="token keyword">return</span> i <span class="token operator">+</span> z
<span class="token punctuation">}</span>

func <span class="token function">roundupsize</span><span class="token punctuation">(</span>size uintptr<span class="token punctuation">)</span> uintptr <span class="token punctuation">{</span>
	<span class="token keyword">if</span> size <span class="token operator">&lt;</span> _MaxSmallSize <span class="token punctuation">{</span>
		<span class="token keyword">if</span> size <span class="token operator">&lt;=</span> smallSizeMax<span class="token operator">-</span><span class="token number">8</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>class_to_size<span class="token punctuation">[</span>size_to_class8<span class="token punctuation">[</span><span class="token function">divRoundUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> smallSizeDiv<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>class_to_size<span class="token punctuation">[</span>size_to_class128<span class="token punctuation">[</span><span class="token function">divRoundUp</span><span class="token punctuation">(</span>size<span class="token operator">-</span>smallSizeMax<span class="token punctuation">,</span> largeSizeDiv<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> size<span class="token operator">+</span>_PageSize <span class="token operator">&lt;</span> size <span class="token punctuation">{</span>
		<span class="token keyword">return</span> size
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token function">alignUp</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> _PageSize<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// alignUp rounds n up to a multiple of a. a must be a power of 2.</span>
func <span class="token function">alignUp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a uintptr<span class="token punctuation">)</span> uintptr <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token operator">^</span> <span class="token punctuation">(</span>a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// &amp;^ 是 ANT NOT 运算符</span></code></pre><div class="notion-text notion-block-c134267980374d3b83931449ae8c9bf8">然后我们再看这一块代码</div><pre class="notion-code language-go"><code class="language-go">	<span class="token keyword">case</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token operator">:</span>
		<span class="token keyword">var</span> shift uintptr
		<span class="token keyword">if</span> sys<span class="token punctuation">.</span>PtrSize <span class="token operator">==</span> <span class="token number">8</span> <span class="token punctuation">{</span>
			<span class="token comment">// Mask shift for better code generation.</span>
			shift <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span><span class="token function">Ctz64</span><span class="token punctuation">(</span><span class="token function">uint64</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">63</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			shift <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span><span class="token function">Ctz32</span><span class="token punctuation">(</span><span class="token function">uint32</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">31</span>
		<span class="token punctuation">}</span>
		capmem <span class="token operator">=</span> <span class="token function">roundupsize</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>newcap<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> shift<span class="token punctuation">)</span>
		newcap <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>capmem <span class="token operator">>></span> shift<span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-8926da40cd3f4a10985c182093f6442e">首先我们通过<code class="notion-inline-code">Ctz64(et.size)</code> 得到shift的值，int类型是8个字节，则8的二进制末尾有3个0，我们得到<code class="notion-inline-code">shift=3</code></div><div class="notion-text notion-block-51080fc4ba1041ff8d38ef97f182da16">然后<code class="notion-inline-code">newcap&lt;&lt;shift</code> 就是 <code class="notion-inline-code">5 &lt;&lt; 3</code> 得到40</div><div class="notion-text notion-block-7b5963cc69864eb3950c6c036d81d96b">经过<code class="notion-inline-code">roundupsize</code>，得到<code class="notion-inline-code">capmem = 48</code></div><div class="notion-text notion-block-f7dc82a409f5475bbccfbb8507df2309">最终再还原回来 <code class="notion-inline-code">newcap = int(48 &gt;&gt; 3) = 6</code></div><div class="notion-text notion-block-cc4483358a9845e48da9efd9067e1d3c">这样就能内存对齐啦</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-b8ea8a743b7547b9afe37016e9d02d7b" data-id="b8ea8a743b7547b9afe37016e9d02d7b"><span><div id="b8ea8a743b7547b9afe37016e9d02d7b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b8ea8a743b7547b9afe37016e9d02d7b" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h3><div class="notion-text notion-block-6b1d36fcc9de4b9f863b08968543a079">slice的扩容步骤有两步</div><ol start="1" class="notion-list notion-list-numbered notion-block-4af00b0decc740e4ae0b0188bb303f74"><li>调整期望容量</li><ol class="notion-list notion-list-numbered notion-block-4af00b0decc740e4ae0b0188bb303f74"><li>如果期望容量是当前容量的两倍，直接更新，否则</li><li>如果小于1024，直接翻倍当前容量，否则</li><li>当前容量按照1.25的速度增长，直到超过期望容量</li></ol></ol><ol start="2" class="notion-list notion-list-numbered notion-block-8c5c7f0f90574973a38f57cabfd20b1e"><li>进行内存对齐，向上调整到最接近的2的n次幂</li></ol><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-140a6d0f54004b3caa47abd1c65f52ad" data-id="140a6d0f54004b3caa47abd1c65f52ad"><span><div id="140a6d0f54004b3caa47abd1c65f52ad" class="notion-header-anchor"></div><a class="notion-hash-link" href="#140a6d0f54004b3caa47abd1c65f52ad" title="slice的拷贝"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">slice的拷贝</span></span></h2><div class="notion-text notion-block-94d43a124e1244d8ac21b03c270b05f7">切片拷贝的方法是slicecopy，我们看看是怎么做的：</div><pre class="notion-code language-go"><code class="language-go"><span class="token comment">// slicecopy is used to copy from a string or slice of pointerless elements into a slice.</span>
func <span class="token function">slicecopy</span><span class="token punctuation">(</span>toPtr unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> toLen int<span class="token punctuation">,</span> fromPtr unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> fromLen int<span class="token punctuation">,</span> width uintptr<span class="token punctuation">)</span> int <span class="token punctuation">{</span>
	<span class="token comment">// 如果有一个长度为0，提前退出</span>
	<span class="token keyword">if</span> fromLen <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> toLen <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token number">0</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">// 记录下较短的长度</span>
	<span class="token literal-property property">n</span> <span class="token operator">:</span><span class="token operator">=</span> fromLen
	<span class="token keyword">if</span> toLen <span class="token operator">&lt;</span> n <span class="token punctuation">{</span>
		n <span class="token operator">=</span> toLen
	<span class="token punctuation">}</span>
	<span class="token comment">// 如果指定的长度为0，那么提前退出</span>
	<span class="token keyword">if</span> width <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> n
	<span class="token punctuation">}</span>

	<span class="token literal-property property">size</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">*</span> width
	<span class="token operator">...</span>

	<span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span> <span class="token comment">// common case worth about 2x to do here</span>
		<span class="token comment">// TODO: is this still worth it with new memmove impl?</span>

		<span class="token comment">// 如果只有一个长度，直接指针转换即可</span>
		<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>byte<span class="token punctuation">)</span><span class="token punctuation">(</span>toPtr<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>byte<span class="token punctuation">)</span><span class="token punctuation">(</span>fromPtr<span class="token punctuation">)</span> <span class="token comment">// known to be a byte pointer</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token comment">// 从from.array 移动 size 个 bytes 拷贝到 to.array</span>
		<span class="token function">memmove</span><span class="token punctuation">(</span>toPtr<span class="token punctuation">,</span> fromPtr<span class="token punctuation">,</span> size<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> n
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-e9bf6c44b3df40bb885335598a46e9fb">执行看看效果</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestCopy</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">a</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>int<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>
	<span class="token literal-property property">b</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>int<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
	<span class="token literal-property property">c</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>int<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token literal-property property">n</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">copy</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> n<span class="token punctuation">)</span>
	n <span class="token operator">=</span> <span class="token function">copy</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> a<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> n<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// === RUN   TestCopy</span>
<span class="token comment">// [1 2 3 0 0] 3</span>
<span class="token comment">// [1 2] 2</span>
<span class="token comment">// --- PASS: TestCopy (0.00s)</span></code></pre><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-1b0c90c1f9d547ba8ceae8e57c874be5" data-id="1b0c90c1f9d547ba8ceae8e57c874be5"><span><div id="1b0c90c1f9d547ba8ceae8e57c874be5" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1b0c90c1f9d547ba8ceae8e57c874be5" title="slice遍历的坑"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">slice遍历的坑</span></span></h3><div class="notion-text notion-block-c2e5bb09c3ac48479e6b1bd743842807">但是我们拷贝有一个需要注意的地方：</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestFor</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">slice</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>int<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">}</span>
	<span class="token keyword">for</span> index<span class="token punctuation">,</span> <span class="token literal-property property">value</span> <span class="token operator">:</span><span class="token operator">=</span> range slice <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"value = %d , value-addr = %x , slice-addr = %x\n"</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>slice<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-afaa2b8897244edaa545d7dc3edc10c6">输出：</div><pre class="notion-code language-go"><code class="language-go"><span class="token operator">===</span> <span class="token constant">RUN</span>   TestFor
value <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">,</span> value<span class="token operator">-</span>addr <span class="token operator">=</span> <span class="token number">1400001e250</span> <span class="token punctuation">,</span> slice<span class="token operator">-</span>addr <span class="token operator">=</span> 1400001a0a0
value <span class="token operator">=</span> <span class="token number">20</span> <span class="token punctuation">,</span> value<span class="token operator">-</span>addr <span class="token operator">=</span> <span class="token number">1400001e250</span> <span class="token punctuation">,</span> slice<span class="token operator">-</span>addr <span class="token operator">=</span> 1400001a0a8
value <span class="token operator">=</span> <span class="token number">30</span> <span class="token punctuation">,</span> value<span class="token operator">-</span>addr <span class="token operator">=</span> <span class="token number">1400001e250</span> <span class="token punctuation">,</span> slice<span class="token operator">-</span>addr <span class="token operator">=</span> 1400001a0b0
value <span class="token operator">=</span> <span class="token number">40</span> <span class="token punctuation">,</span> value<span class="token operator">-</span>addr <span class="token operator">=</span> <span class="token number">1400001e250</span> <span class="token punctuation">,</span> slice<span class="token operator">-</span>addr <span class="token operator">=</span> 1400001a0b8
<span class="token operator">--</span><span class="token operator">-</span> <span class="token constant">PASS</span><span class="token operator">:</span> <span class="token function">TestFor</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span>00s<span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-a268f40a20284b86bdca0dff0ffccc83">可以看到，我们用range去遍历切片的时候，拿到的value其实是切片里面的<b>值拷贝</b>，所以每次Value的地址都不变。因此我们需要用<code class="notion-inline-code">&amp;slice[index]</code>才能拿到真实的地址</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-1d6ec7d17d9a4e97bf68fa41b4982844"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F07b1c3a3-a71d-49ab-af2d-f7b440c6c984%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105342Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D042654ba208121a4d8b1fed783ddfb4e0a988d3e2659bb2910f8ef7252477a78%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=1d6ec7d1-7d9a-4e97-bf68-fa41b4982844&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-e7b42623807b4efea632dd74b2dfa3af">ref: <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://halfrost.com/go_slice/">深入解析 Go 中 Slice 底层实现 (halfrost.com)</a></div><div class="notion-text notion-block-552b3b9e15124057ae02d0c5c88c0065">如果不注意到这点的话，会带来什么问题呢？当我们拷贝的时候可能就会踩坑了：</div><pre class="notion-code language-go"><code class="language-go">func <span class="token function">TestFor</span><span class="token punctuation">(</span><span class="token parameter">t <span class="token operator">*</span>testing<span class="token punctuation">.</span><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">slice</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>int<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">}</span>
	<span class="token literal-property property">to</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>int<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> _<span class="token punctuation">,</span> <span class="token literal-property property">value</span> <span class="token operator">:</span><span class="token operator">=</span> range slice <span class="token punctuation">{</span>
		to <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token operator">&amp;</span>value<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> _<span class="token punctuation">,</span> <span class="token literal-property property">value</span> <span class="token operator">:</span><span class="token operator">=</span> range to <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>value<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-64da06b3034548a3bc8be0d94d666d34">输出：</div><pre class="notion-code language-go"><code class="language-go"><span class="token operator">===</span> <span class="token constant">RUN</span>   TestFor
<span class="token number">40</span> <span class="token number">0x14000098168</span>
<span class="token number">40</span> <span class="token number">0x14000098168</span>
<span class="token number">40</span> <span class="token number">0x14000098168</span>
<span class="token number">40</span> <span class="token number">0x14000098168</span>
<span class="token operator">--</span><span class="token operator">-</span> <span class="token constant">PASS</span><span class="token operator">:</span> <span class="token function">TestFor</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span>00s<span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-18e2c75dadc442408916bef5faca7341">可以发现，每次append到to里面的地址都是创建的临时变量value，而value最后的值是40，所以导致最后输出值都是40，且指向的地址就是value的地址。</div><div class="notion-text notion-block-b8c22ae95b264b519f6656c97b85cd71">要避免这个坑，我们要记住for遍历的时候会创建临时变量，避免直接对临时变量操作。</div><pre class="notion-code language-go"><code class="language-go"><span class="token comment">// 方法一，直接操作slice的值</span>
<span class="token keyword">for</span> index<span class="token punctuation">,</span> <span class="token literal-property property">_</span> <span class="token operator">:</span><span class="token operator">=</span> range slice <span class="token punctuation">{</span>
		to <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token operator">&amp;</span>slice<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 方法二，创建临时变量</span>
<span class="token keyword">for</span> _<span class="token punctuation">,</span> <span class="token literal-property property">value</span> <span class="token operator">:</span><span class="token operator">=</span> range slice <span class="token punctuation">{</span>
		<span class="token literal-property property">tmp</span> <span class="token operator">:</span><span class="token operator">=</span> value
		to <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tmp<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><div class="notion-blank notion-block-867c81b0f9ac41e29617ac99ea63c4c5"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-4b2034c183954853b014953d8d61528e" data-id="4b2034c183954853b014953d8d61528e"><span><div id="4b2034c183954853b014953d8d61528e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#4b2034c183954853b014953d8d61528e" title="一些问题"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">一些问题</span></span></h2><ul class="notion-list notion-list-disc notion-block-6a1099bcde724398837d79a59cb1152d"><li>为什么1024之后的扩展速度变为1.25倍呢？</li></ul><div class="notion-text notion-block-0d770c11df914472969ab9bc2171893e">因为内存空间很宝贵，底层的数组是在内存中连续的空间，申请这样大规模连续的空间是很昂贵的，1024之后我们用1.25的速度扩展已经足够大了，这样相比于翻倍扩展能解决更多的空间</div><ul class="notion-list notion-list-disc notion-block-57056f1caeed4253a0b3f96f75d42790"><li>为什么要内存对齐？</li></ul><div class="notion-text notion-block-0153dc81cf6a4e07b02f5029049a3b2d">因为内存管理会预先申请内存后再进行分配，预先申请的大小都是常用的规格，比如说8，16，32，48，64等，因此我们需要进行内存对齐来返回一个足够大的内存块使用。这样避免任意大小的内存块产生内存碎片，影响空间申请和整理。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-757d0ca7c7a24bfda45057a9bf0282f0" data-id="757d0ca7c7a24bfda45057a9bf0282f0"><span><div id="757d0ca7c7a24bfda45057a9bf0282f0" class="notion-header-anchor"></div><a class="notion-hash-link" href="#757d0ca7c7a24bfda45057a9bf0282f0" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h2><div class="notion-text notion-block-1f83c65485034579beb19f4e60b509c8">简单介绍了一下slice的代码，短小精悍，主要有初始化、扩容、拷贝三种操作。</div><div class="notion-text notion-block-3cb61869eaa640718349e0a5e3b767e8">日常使用的时候，我们最好指定cap的上限，避免扩容带来的开销。同时避免切片遍历的坑。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-e9f2d4601ba5407a9ac107f59828d6e8" data-id="e9f2d4601ba5407a9ac107f59828d6e8"><span><div id="e9f2d4601ba5407a9ac107f59828d6e8" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e9f2d4601ba5407a9ac107f59828d6e8" title="Ref"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Ref</span></span></h2><div class="notion-text notion-block-e898e6fc27194768848554f709455f1f"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.lookcos.cn/archives/1204.html">浅谈 Go 1.18.1的切片扩容机制 - Lookcos 的网络日志</a></div><div class="notion-text notion-block-ed0dee31697e4624927dbae5d18df021"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://halfrost.com/go_slice/">深入解析 Go 中 Slice 底层实现 (halfrost.com)</a></div><div class="notion-text notion-block-137d2d198a1b43acba370b4dd8a39568"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/02.2.html">slice · 深入解析Go (gitbooks.io)</a></div><div class="notion-text notion-block-75fe0674fd2549d6a601d6fad808de90"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="http://lifegoeson.cn/2022/01/22/golang%20slice%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/">golang slice扩容机制 (lifegoeson.cn)</a></div><div class="notion-text notion-block-7c4ea0076f194c1d95f25ba833253d73"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://eddycjy.gitbook.io/golang/di-1-ke-za-tan/go-memory-align">1.5 在 Go 中恰到好处的内存对齐 - 跟煎鱼学 Go (gitbook.io)</a></div><div class="notion-text notion-block-189017a165734ddc8e8542292793cfe0"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://zhuanlan.zhihu.com/p/86765504">go：&amp;^ 运算符 - 知乎 (zhihu.com)</a></div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ACID和实现原理]]></title>
            <link>https://hhmy27.github.io//acid</link>
            <guid>https://hhmy27.github.io//acid</guid>
            <pubDate>Thu, 17 Nov 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-0001a0d655494fc5955f57c356d6e87e"><div class="notion-viewport"></div><div class="notion-table-of-contents notion-gray notion-block-2b54ec181e9c4251a7eb42fc2f33f6dd"><a href="#0a3701f73e774e11bfbea6467672c4a0" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">简介</span></a><a href="#8bb9947063ec4eaaa06d00a86995c5b8" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">基础概念</span></a><a href="#beb19c4de38e47ee92e228d2204ed5a7" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">原子性</span></a><a href="#99fb1eb54ec7464b8358fd2c6c1f5044" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">实现原理 undo log</span></a><a href="#ba89199e7b6c440494e509b1c9a666d8" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">持久性</span></a><a href="#81c7c0b03acd46888a7fc1635e0bd82c" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">实现原理 redo log</span></a><a href="#acd626ba84dc4af695a0e247775e5507" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">隔离性</span></a><a href="#b1fe6ae1d6cb4b659c7dade714a13bcd" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">隔离不足出现的问题</span></a><a href="#f1fc417bb3824444892a0446e63a543d" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">事务隔离级别</span></a><a href="#57ccb5cf1912402ba46ead3010e6b74c" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">RR隔离级别如何解决不可重复读和幻读</span></a><a href="#108c2302a9874e8baffd93e1122db6c6" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">一致性</span></a><a href="#a20114a9979348dfb541b7520d745fd9" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">如何实现一致性</span></a><a href="#8610896280b9410f8eadba5a322840c8" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">总结</span></a><a href="#24a4fee48068441b86e14a944b371fc1" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">Ref</span></a></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-0a3701f73e774e11bfbea6467672c4a0" data-id="0a3701f73e774e11bfbea6467672c4a0"><span><div id="0a3701f73e774e11bfbea6467672c4a0" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0a3701f73e774e11bfbea6467672c4a0" title="简介"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">简介</span></span></h2><div class="notion-text notion-block-08d9d1a154be431d8aac7694cf59120f">本文主要解释事务的ACID特性和相关实现原理，背景是Mysql5.6，数据引擎是Inno db</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-8bb9947063ec4eaaa06d00a86995c5b8" data-id="8bb9947063ec4eaaa06d00a86995c5b8"><span><div id="8bb9947063ec4eaaa06d00a86995c5b8" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8bb9947063ec4eaaa06d00a86995c5b8" title="基础概念"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">基础概念</span></span></h2><div class="notion-text notion-block-9f7dcc5b145a4d22b5478d4f185728e8">事务是指一组操作，这组操作要么全都执行成功，要么全都不执行。</div><div class="notion-text notion-block-512ddd62a58f42de99cf83ef2be0e1e7"><b>MySQL的架构</b></div><div class="notion-text notion-block-5ac3288282e04280a46f8f5a852302c3">首先我们了解一下MySQL的架构</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-0ba1237b49d24b389f1fa449cd1417ff"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:554px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6ef19ad6-d28a-4a6e-9841-0833386af85d%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105343Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Debd58fe3c8db35f74cce1bd4b4678b72c525c4e239d0826f3477ff03efba16c9%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=0ba1237b-49d2-4b38-9f1f-a449cd1417ff&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-5d1283186e304c23b568a659ecf78cbe">MySQL的结构一共可以分为三层</div><ol start="1" class="notion-list notion-list-numbered notion-block-1aa0e18c41974742987fd9d47fbb8048"><li>链接层，处理链接，授权认证等</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-e92deecbb42542e89e8ef66620a16860"><li>服务器层，负责语句的解析、优化</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-59771b209e6e4438be7f1eb78a6b83aa"><li>存储引擎层，其中使用最广泛的存储引起是InnoDB。MySQL本身是不支持事务的，事务是由存储引擎实现的。</li></ol><div class="notion-text notion-block-b47f33c4661c49f5ab2a5c54beba5289"><b>事务的提交</b></div><pre class="notion-code language-sql"><code class="language-sql">start transaction<span class="token punctuation">;</span> # 开启一个事务
……  #一条或多条sql语句
commit<span class="token punctuation">;</span> # 提交</code></pre><div class="notion-text notion-block-1d098562b7134ce5baa9aea86c509dce">Mysql中默认是autocommit（自动提交）模式，如果没有显示的开启一个事务，那么每个SQL语句都会当作一个事务执行。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-d47aae2a0c56448ea3fc1b227320c939"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:298px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F973a0d0a-5de9-446e-822d-af04d7cee855%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105343Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D4743e12c634e7f50e11735e8a5ea1b56447870f3d4565b8657c2d44c3ed0dee1%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=d47aae2a-0c56-448e-a3fc-1b227320c939&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-1bc7d398d3d3425c8d77fb0592a52905">我们也可以通过<code class="notion-inline-code"> set autocommit = 0</code>，关闭自动提交；需要注意的是，autocommit参数是针对连接的，在一个连接中修改了参数，不会对其他连接产生影响。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-98ea60f8427f42849f5a4d946099ffa5"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:289px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdac21077-644b-4a99-9fab-29ef336a31ba%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105343Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3D6d033f0536ef0807c222dcb7de082055008b6387314e235de76ea11c226c048e%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=98ea60f8-427f-4284-9f5a-4d946099ffa5&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-9e8b93b0cb564ef0bc9e44b7316c997c">如果关闭了autocommit，则所有的sql语句都在一个事务中，直到执行了commit或rollback，该事务结束，同时开始了另外一个事务。</div><div class="notion-text notion-block-dcce819a33f34620ba9c200898444260"><b>强制提交的命令</b></div><div class="notion-text notion-block-f38d8ff88b3c4e17a649a08293e31d56">在MySQL中，存在一些特殊的命令，如果在事务中执行了这些命令，会马上强制执行commit提交事务；如DDL语句(create table/drop table/alter/table)、lock tables语句等等。</div><div class="notion-text notion-block-6b8ab9a79f8d4d818fcb0c8ca973c233">不过，常用的select、insert、update和delete命令，都不会强制提交事务。</div><div class="notion-text notion-block-e6b94365a51841279de0c7b606f8abde"><b>ACID</b></div><ul class="notion-list notion-list-disc notion-block-9921fb00e28642bcb722e3692da52113"><li>原子性 Atomicity</li></ul><ul class="notion-list notion-list-disc notion-block-09b95a186e864af99892f654e80b3bed"><li>一致性 Consistency</li></ul><ul class="notion-list notion-list-disc notion-block-56fe21e46c9e4d97a88fca8144a3afe9"><li>隔离性 Isolation</li></ul><ul class="notion-list notion-list-disc notion-block-7f3fcd8e3aba42f6b8cf8e42dea4214a"><li>持久性 Durability</li></ul><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-beb19c4de38e47ee92e228d2204ed5a7" data-id="beb19c4de38e47ee92e228d2204ed5a7"><span><div id="beb19c4de38e47ee92e228d2204ed5a7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#beb19c4de38e47ee92e228d2204ed5a7" title="原子性"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">原子性</span></span></h2><div class="notion-text notion-block-2fbcfca90ebb4d54856f35fae3d9e9ab">原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-99fb1eb54ec7464b8358fd2c6c1f5044" data-id="99fb1eb54ec7464b8358fd2c6c1f5044"><span><div id="99fb1eb54ec7464b8358fd2c6c1f5044" class="notion-header-anchor"></div><a class="notion-hash-link" href="#99fb1eb54ec7464b8358fd2c6c1f5044" title="实现原理 undo log"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">实现原理 undo log</span></span></h3><div class="notion-text notion-block-e999346e5d1547daa09e6472b0a47912">可以看到实现原子性的关键是，我们必须要保证sql执行失败的时候进行回滚。在innodb中，回滚的关键依靠的就是undo log。</div><div class="notion-text notion-block-15422d81bd2f4e2bb3b29ba4b48098cd">每当我们对数据库进行修改的时候，就会记录相应操作到undo log中，如果事务需要回滚，那么就会根据undo log里面的记录把数据回滚到初始值。</div><div class="notion-text notion-block-453cab5c74b744429ba5ce225adc6a95">当发生回滚的时候，innodb会根据undo log里面的操作执行逆操作，例如：</div><ul class="notion-list notion-list-disc notion-block-159fbd0a31f7431e9a099181b2721879"><li>记录了insert，就执行delete；记录了delete，就执行insert</li></ul><ul class="notion-list notion-list-disc notion-block-f71610c12b914714a51e6c58b1e7628d"><li>记录了update，则执行相反的update</li></ul><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-ba89199e7b6c440494e509b1c9a666d8" data-id="ba89199e7b6c440494e509b1c9a666d8"><span><div id="ba89199e7b6c440494e509b1c9a666d8" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ba89199e7b6c440494e509b1c9a666d8" title="持久性"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">持久性</span></span></h2><div class="notion-text notion-block-61908d3fca06457799357bedcf2039ad">持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-81c7c0b03acd46888a7fc1635e0bd82c" data-id="81c7c0b03acd46888a7fc1635e0bd82c"><span><div id="81c7c0b03acd46888a7fc1635e0bd82c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#81c7c0b03acd46888a7fc1635e0bd82c" title="实现原理 redo log"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">实现原理 redo log</span></span></h3><div class="notion-text notion-block-fb1bbd33fdd84889bf2f8d48d748be35">持久性的实现关键在于及时的把操作记录下来，避免丢失。</div><div class="notion-text notion-block-32dfe978f918410ca0c20ea5dae45ceb">innodb的实现机制是redo log。</div><div class="notion-text notion-block-bc0b056508a04aa6ae643fd7d3c193e1">InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。</div><div class="notion-text notion-block-9b74ddbf006240bc92ccbe0f4a93c338">Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</div><div class="notion-text notion-block-b6421d292fe948809ec1368c47446f99">于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。</div><div class="notion-text notion-block-13eb8d7d8e8d43a9bb0ac6d299acaf4c">redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</div><blockquote class="notion-quote notion-block-5f9d4acbb29540939d70a7dd33a1fd28">二阶段提交：先写redo log，执行操作，操作成功后再写bin log</blockquote><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-acd626ba84dc4af695a0e247775e5507" data-id="acd626ba84dc4af695a0e247775e5507"><span><div id="acd626ba84dc4af695a0e247775e5507" class="notion-header-anchor"></div><a class="notion-hash-link" href="#acd626ba84dc4af695a0e247775e5507" title="隔离性"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">隔离性</span></span></h2><div class="notion-text notion-block-b5f5e1a1fba94fcb9e5ac2993b06a84e">隔离性要求事务之间互相隔离，不会干扰对方操作。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-b1fe6ae1d6cb4b659c7dade714a13bcd" data-id="b1fe6ae1d6cb4b659c7dade714a13bcd"><span><div id="b1fe6ae1d6cb4b659c7dade714a13bcd" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b1fe6ae1d6cb4b659c7dade714a13bcd" title="隔离不足出现的问题"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">隔离不足出现的问题</span></span></h3><ul class="notion-list notion-list-disc notion-block-3fed38f34f83479aacb1d03837b60d6a"><li>脏读</li></ul><div class="notion-text notion-block-e30e23dda8964f26ac06f8063b55bb48">A事务读取到B事务未提交的数据，一旦B事务回滚，那么读取到的数据就是脏数据</div><ul class="notion-list notion-list-disc notion-block-4d8119b0517343afa7123c1ff754db76"><li>不可重复读</li></ul><div class="notion-text notion-block-17329a6c227c44d5a6ce9fb97d2c9f86">A事务读取的数据被B事务修改，导致前后读取结果不一致</div><ul class="notion-list notion-list-disc notion-block-cd73a46e40d64a08a0125a0e89662d9e"><li>幻读</li></ul><div class="notion-text notion-block-b848670216cd4ca1ae2bcd853366d833">A事务执行范围查询的期间，B事务在范围内写入了一些数据导致A事务再次执行范围查询的时候两次结果不一致</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-f1fc417bb3824444892a0446e63a543d" data-id="f1fc417bb3824444892a0446e63a543d"><span><div id="f1fc417bb3824444892a0446e63a543d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f1fc417bb3824444892a0446e63a543d" title="事务隔离级别"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">事务隔离级别</span></span></h3><div class="notion-text notion-block-8ffc68cb14b64b9e99522d54b60649f2">SQL定义了四种隔离级别，每种隔离级别均解决了一定的问题</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-7ad9eb557b634adc868b9e4b1f0477cf"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:549px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3.us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2aa8a3e6-4e93-4eb5-be0c-87010cf10e7b%2FUntitled.png%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Content-Sha256%3DUNSIGNED-PAYLOAD%26X-Amz-Credential%3DAKIAT73L2G45EIPT3X45%252F20221216%252Fus-west-2%252Fs3%252Faws4_request%26X-Amz-Date%3D20221216T105343Z%26X-Amz-Expires%3D86400%26X-Amz-Signature%3Dd28f6eec0bae58d80c3c59152271c3dd0043a225dd540938bcab64108d2869dc%26X-Amz-SignedHeaders%3Dhost%26x-id%3DGetObject?table=block&amp;id=7ad9eb55-7b63-4adc-868b-9e4b1f0477cf&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-cf4da6402db345b5b0492ac22f2a1491">innodb的默认隔离级别是RR，在SQL标准中RR无法解决幻读问题，但是innodb通过MVCC和加锁解决了幻读问题</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-57ccb5cf1912402ba46ead3010e6b74c" data-id="57ccb5cf1912402ba46ead3010e6b74c"><span><div id="57ccb5cf1912402ba46ead3010e6b74c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#57ccb5cf1912402ba46ead3010e6b74c" title="RR隔离级别如何解决不可重复读和幻读"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">RR隔离级别如何解决不可重复读和幻读</span></span></h3><div class="notion-text notion-block-b5a1abbedc424ee8a1a66c3238f9c3f7">一句话总结：</div><ul class="notion-list notion-list-disc notion-block-a1c9f0e815fa43d2b28d318accc94ed9"><li>当前读场景下使用加锁解决</li></ul><ul class="notion-list notion-list-disc notion-block-dd9b9644c39c4913899a520098b91f50"><li>快照读场景下使用MVCC解决</li></ul><div class="notion-text notion-block-f6a164060d9946f5abdec7468c5f3abc"><b>当前读</b></div><div class="notion-text notion-block-da649356810f4908b0362140a0a5d607">定义：读取的数据是最新数据就是当前读</div><div class="notion-text notion-block-0a4929b2ee1e4f3592001f4a67404be8">当前读的触发语句：</div><pre class="notion-code language-sql"><code class="language-sql">select<span class="token operator">...</span>lock <span class="token keyword">in</span> share mode  # 共享锁

select<span class="token operator">...</span><span class="token keyword">for</span> update # 排他锁

update <span class="token punctuation">,</span> <span class="token keyword">delete</span> <span class="token punctuation">,</span> insert</code></pre><div class="notion-text notion-block-790dc0d26e21457f888e75269c5600a2">如果我们执行<code class="notion-inline-code">update , delete , insert</code> 这些写操作的语句，那么Mysql就会加行锁，保证涉及到的数据同一时刻只能被一个事务操作。</div><div class="notion-text notion-block-1fb409c858aa49b49ecd0bdde04e5927">如果显式的加锁，执行select语句，那么mysql就会加上next-key lock来避免产生幻读问题</div><div class="notion-text notion-block-395fc70f62814d05b02fb2f173e779ad">next-key lock是行锁和间隙锁的结合体，首先使用行锁来锁住涉及到的数据，然后同时使用间隙锁锁住数据之间的间隙，不让其他事务进行插入。</div><div class="notion-text notion-block-9f354af42cfd43db98b75d998e6870c3"><b>快照读</b></div><div class="notion-text notion-block-9e6453392a3043e2851e561f7df39790">快照读指的是读取到的数据是某一时刻的快照</div><div class="notion-text notion-block-f3eeeb1e1bab4b8aa7686c34c8cf6139">快照读的触发语句：</div><pre class="notion-code language-sql"><code class="language-sql"><span class="token function">简单的select操作</span><span class="token punctuation">(</span>不包括 select <span class="token operator">...</span> lock <span class="token keyword">in</span> share mode<span class="token punctuation">,</span> select <span class="token operator">...</span> <span class="token keyword">for</span> update<span class="token punctuation">)</span>。</code></pre><div class="notion-text notion-block-71d1fce20490445daabf362812cfa3b7">快照读解决不可重复读和幻读问题的是MVCC。</div><div class="notion-text notion-block-00696189db7a4fa290320bbdbbfd91ee"><b>MVCC</b></div><div class="notion-text notion-block-c7923d720e694917a99a7427c83ceef9">多版本并发控制。</div><div class="notion-text notion-block-e853c645cbc44fd1abad342f8ca5892c">MVCC依赖于几个关键组件</div><ul class="notion-list notion-list-disc notion-block-82cf96148f0b40aeabd64b069e7ce81f"><li>隐藏列</li></ul><div class="notion-text notion-block-05dd04f6376f4998b852d73d6beb6c40">innodb中的隐藏列有：<div class="notion-text-children"><ul class="notion-list notion-list-disc notion-block-9fc713ca1d0e4dd8948707d3260b7991"><li>本行数据的事务id，指向undo log的指针，自增id</li></ul></div></div><ul class="notion-list notion-list-disc notion-block-b6febcae34a54099af6e197f7bbf5a8d"><li>基于undo log的版本链</li></ul><div class="notion-text notion-block-89ec89477fdd4d47bcd66a6517511710">每个指针会指向更早版本的undo log，从而形成一条版本脸</div><ul class="notion-list notion-list-disc notion-block-eb1993700e4246bca285d5f044d6bc89"><li>ReadView</li></ul><div class="notion-text notion-block-7de7146eece04699a3016e1af89221b8">通过版本链和隐藏列，Mysql可以将数据恢复到指定版本。</div><div class="notion-text notion-block-6ad992da732e4298a27cdd8210cabfbe">所谓的ReadView就是事务某一时刻给整个事务系统（trx_sys）打快照，之后在进行读操作的时候，根据事务id和快照相比，从而判断数据是否对当前事务可见。</div><div class="notion-text notion-block-247fde6bb4044c1a9e6d415fbca97799">trx_sys中又包含了几个字段</div><ul class="notion-list notion-list-disc notion-block-70bd1414b1f14c4aaf7b585db02c5216"><li>low_limit_id：表示生成ReadView时系统中应该分配给下一个事务的id。如果数据的事务id大于等于low_limit_id，则对该ReadView不可见。</li></ul><ul class="notion-list notion-list-disc notion-block-7a8087c530764bbbbe42a41febad73eb"><li>up_limit_id：表示生成ReadView时当前系统中活跃的读写事务中最小的事务id。如果数据的事务id小于up_limit_id，则对该ReadView可见。</li></ul><ul class="notion-list notion-list-disc notion-block-77a1208f3b35438bba2679065d3ea2c8"><li>rw_trx_ids：表示生成ReadView时当前系统中活跃的读写事务的事务id列表。如果数据的事务id在low_limit_id和up_limit_id之间，则需要判断事务id是否在rw_trx_ids中：如果在，说明生成ReadView时事务仍在活跃中，因此数据对ReadView不可见；如果不在，说明生成ReadView时事务已经提交了，因此数据对ReadView可见。</li></ul><div class="notion-text notion-block-0b3fadacad2649a6a4666c46d5bc5b77">总结：</div><div class="notion-text notion-block-7baa289aeb91427d955205746bbdc6f2">依靠快照和事务id，MVCC决定哪些数据可见哪些数据不可见，从而解决了不可重复读和幻读问题。MVCC和核心是undo log的版本链，通过版本链可以恢复数据。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-108c2302a9874e8baffd93e1122db6c6" data-id="108c2302a9874e8baffd93e1122db6c6"><span><div id="108c2302a9874e8baffd93e1122db6c6" class="notion-header-anchor"></div><a class="notion-hash-link" href="#108c2302a9874e8baffd93e1122db6c6" title="一致性"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">一致性</span></span></h2><div class="notion-text notion-block-715a02ae077441469afde55493bc3e70">一致性是指事务执行结束后，<b>数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</b>数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。</div><div class="notion-text notion-block-13898e3ec31d4a0b9b66c25220b5fc11">常见的例子就是，A用户给B用户转账1万元，转账前后两个账户钱的和是一致的，不会产生变化。相当于从一个合法的状态转换到了另一个合法的状态。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-a20114a9979348dfb541b7520d745fd9" data-id="a20114a9979348dfb541b7520d745fd9"><span><div id="a20114a9979348dfb541b7520d745fd9" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a20114a9979348dfb541b7520d745fd9" title="如何实现一致性"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">如何实现一致性</span></span></h3><div class="notion-text notion-block-dd06f68cd25d444e948b0cd59e745189">一致性是事务追求的最终目标，它的实现基于原子性、隔离性、持久性的实现基础。在此基础上，要求数据库提供保障，例如不允许向整形列插入字符串值等。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-8610896280b9410f8eadba5a322840c8" data-id="8610896280b9410f8eadba5a322840c8"><span><div id="8610896280b9410f8eadba5a322840c8" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8610896280b9410f8eadba5a322840c8" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h2><ul class="notion-list notion-list-disc notion-block-5d268e60c47043d3a5f1beeb6d6e7c5c"><li>原子性</li><ul class="notion-list notion-list-disc notion-block-5d268e60c47043d3a5f1beeb6d6e7c5c"><li>要么全部执行，要么全部不执行</li><li>undo log，回滚数据</li></ul></ul><ul class="notion-list notion-list-disc notion-block-c563d9319ae044f7977557f8d1a23eb8"><li>持久性</li><ul class="notion-list notion-list-disc notion-block-c563d9319ae044f7977557f8d1a23eb8"><li>事物的操作是永久的</li><li>redo log，预写操作，保证操作不丢失及时落盘</li></ul></ul><ul class="notion-list notion-list-disc notion-block-3e7d2aaca7f34356b7d9121e04e75a3c"><li>隔离性</li><ul class="notion-list notion-list-disc notion-block-3e7d2aaca7f34356b7d9121e04e75a3c"><li>事务之间互相隔离，不影响对方执行</li><li>当前读使用锁机制，快照读使用MVCC</li></ul></ul><ul class="notion-list notion-list-disc notion-block-1668658ccd7d46e0819c849db7baf6e3"><li>一致性</li><ul class="notion-list notion-list-disc notion-block-1668658ccd7d46e0819c849db7baf6e3"><li>事务执行前后，数据的状态是合法的，数据库的完整性约束没有被破坏</li><li>要求我们实现好原子性、持久性、隔离性</li></ul></ul><div class="notion-blank notion-block-90e5495ab14a4fc2a85469a6ccdeaa49"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-24a4fee48068441b86e14a944b371fc1" data-id="24a4fee48068441b86e14a944b371fc1"><span><div id="24a4fee48068441b86e14a944b371fc1" class="notion-header-anchor"></div><a class="notion-hash-link" href="#24a4fee48068441b86e14a944b371fc1" title="Ref"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Ref</span></span></h2><div class="notion-text notion-block-7ef6aa6d75f84c2b96206e17d52ce643"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.cnblogs.com/kismetv/p/10331633.html">深入学习MySQL事务：ACID特性的实现原理 - 编程迷思 - 博客园 (cnblogs.com)</a></div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[leetcode 上的 peak finding 问题汇总]]></title>
            <link>https://hhmy27.github.io//peak-finding</link>
            <guid>https://hhmy27.github.io//peak-finding</guid>
            <pubDate>Thu, 17 Nov 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-31a25d19926143adb43ea31d39f64545"><div class="notion-viewport"></div><div class="notion-table-of-contents notion-gray notion-block-88fb19e910344a8a87524994b4a077fa"><a href="#b3b8e9d850f94ab39bc83d9ee1d04ef2" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">题目</span></a><a href="#a6ee9c870e27499b9f7fe97edca15c47" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">852. 山脉数组的峰顶索引</span></a><a href="#1e227a8ecfc8491d9605eb621c8f81e6" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">方法1 暴力</span></a><a href="#ac8658a5c8c74fdea8414fc190670553" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">方法2 二分</span></a><a href="#c439536dfc964aa598fb79e1ce8662be" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">162. 寻找峰值</span></a><a href="#17262cd26de44c888715587e4bb5b741" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">方法1 暴力</span></a><a href="#91d2467851614afda1887425fefa1f23" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">方法2 二分</span></a><a href="#d516ef379bf449b1b78a1dfcbfd54372" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">方法3 改进的暴力</span></a><a href="#dc8dc1a6b72f46029e9cb913603088f1" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">方法4 改进的二分</span></a><a href="#305d765ad8f84524a1189211ae1de198" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">74. 搜索二维矩阵</span></a><a href="#ef7935b017f74a8aa64a0a8f10bb1e45" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">方法1 暴力</span></a><a href="#76d1be15edd2493082f7c01e3bcdb7b8" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">方法2 二分</span></a><a href="#e7778d53c2114a3aa7a247a5c0699b24" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">方法3 利用数组特性</span></a><a href="#3be08939e4954e2d959a305f8d5d7c9e" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">总结</span></a></div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-b3b8e9d850f94ab39bc83d9ee1d04ef2" data-id="b3b8e9d850f94ab39bc83d9ee1d04ef2"><span><div id="b3b8e9d850f94ab39bc83d9ee1d04ef2" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b3b8e9d850f94ab39bc83d9ee1d04ef2" title="题目"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">题目</span></span></h3><div class="notion-text notion-block-0776fab751ed4ad2a818908644376ecf">一共三道，每道题之间互相有联系</div><div class="notion-text notion-block-b3cd95c593ee45eeae2f7f83329bae68"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/">https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/</a></div><div class="notion-text notion-block-c0badd9d4e82402db98c3e8c4c08e6e1"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://leetcode-cn.com/problems/find-peak-element/">https://leetcode-cn.com/problems/find-peak-element/</a></div><div class="notion-text notion-block-b25a408fd5214a2d8eab278b263c0292"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://leetcode-cn.com/problems/search-a-2d-matrix/">https://leetcode-cn.com/problems/search-a-2d-matrix/</a></div><div class="notion-text notion-block-1113e0a0794944448d24789993c215a1">题目虽然没有保证 distinct，不过我们仍然可以用 divide and conquer 的思想尝试解题</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-a6ee9c870e27499b9f7fe97edca15c47" data-id="a6ee9c870e27499b9f7fe97edca15c47"><span><div id="a6ee9c870e27499b9f7fe97edca15c47" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a6ee9c870e27499b9f7fe97edca15c47" title="852. 山脉数组的峰顶索引"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">852. 山脉数组的峰顶索引</span></span></h3><div class="notion-text notion-block-54dbdd2715b34f8b80848345ceaea821"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/">https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/</a></div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-1e227a8ecfc8491d9605eb621c8f81e6" data-id="1e227a8ecfc8491d9605eb621c8f81e6"><span><div id="1e227a8ecfc8491d9605eb621c8f81e6" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1e227a8ecfc8491d9605eb621c8f81e6" title="方法1 暴力"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">方法1 暴力</span></span></h4><div class="notion-text notion-block-b4d1c406c76748539c07c019a0005b76">读题，数据范围很小，直接遍历即可</div><div class="notion-text notion-block-f5ee6a4cf7834189908d6479c6b41fa9">这里有一个技巧，我们不需要真的去判断 <code class="notion-inline-code">A[i - 1], A[i], A[i + 1]</code> 的关系，我们只需要找到第一个<code class="notion-inline-code">A[i] &gt; A[i + 1]</code>的<code class="notion-inline-code">i</code>即可，因为这个<code class="notion-inline-code">i</code>必然满足<code class="notion-inline-code">A[i - 1] &lt; A[i]</code></div><pre class="notion-code language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> int <span class="token function">peakIndexInMountainArray</span><span class="token punctuation">(</span><span class="token parameter">int<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">A</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token constant">A</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-ac8658a5c8c74fdea8414fc190670553" data-id="ac8658a5c8c74fdea8414fc190670553"><span><div id="ac8658a5c8c74fdea8414fc190670553" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ac8658a5c8c74fdea8414fc190670553" title="方法2 二分"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">方法2 二分</span></span></h4><div class="notion-text notion-block-ded2ca6545c544d5bc7b31b169650fe5">二分查找的思想，山脉数组总是一个先上升后下降的趋势，那么按照二分的思想，每次取得mid进行判断</div><ol start="1" class="notion-list notion-list-numbered notion-block-aa834f98f837413bac9933ca993bb198"><li>mid就是山顶，返回mid</li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-981f550aa6af4170ad7e0162213614e4"><li>mid处于局部上升的区间，返回右边区间的二分</li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-9d63afc816714ca39582343ec9fe9b82"><li>mid处于局部下降的区间，返回左边区间的二分</li></ol><div class="notion-text notion-block-11e1b51d4d044869a3359e5d17f1682a">由此可以写出代码：</div><pre class="notion-code language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> int <span class="token function">peakIndexInMountainArray</span><span class="token punctuation">(</span><span class="token parameter">int<span class="token punctuation">[</span><span class="token punctuation">]</span> arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        int n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            int m <span class="token operator">=</span> i <span class="token operator">+</span> j <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> m<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span> i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-f4aa187adbe843ff989bf13575de88c4">特别的，由于题目输入保证有解，我们可以初始化边界为 1 和 n - 2</div><hr class="notion-hr notion-block-f48192f5480b46bb80ebbfb8c64a4a10"/><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-c439536dfc964aa598fb79e1ce8662be" data-id="c439536dfc964aa598fb79e1ce8662be"><span><div id="c439536dfc964aa598fb79e1ce8662be" class="notion-header-anchor"></div><a class="notion-hash-link" href="#c439536dfc964aa598fb79e1ce8662be" title="162. 寻找峰值"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">162. 寻找峰值</span></span></h3><div class="notion-text notion-block-b81f3f5f95884d8dad1e2b18f348ed52"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://leetcode-cn.com/problems/find-peak-element/">https://leetcode-cn.com/problems/find-peak-element/</a></div><div class="notion-text notion-block-4e461cf5a1434356bee49a8f29f7039a">就是之前提到的1D-finding问题，不过在leetcode上面可以做得更巧妙</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-17262cd26de44c888715587e4bb5b741" data-id="17262cd26de44c888715587e4bb5b741"><span><div id="17262cd26de44c888715587e4bb5b741" class="notion-header-anchor"></div><a class="notion-hash-link" href="#17262cd26de44c888715587e4bb5b741" title="方法1 暴力"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">方法1 暴力</span></span></h4><div class="notion-text notion-block-adec75f214f64ad4a40a812dabe1bdc0">自然而然就想到的做法</div><pre class="notion-code language-plain text"><code class="language-plain text"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> int <span class="token function">findPeakElement</span><span class="token punctuation">(</span><span class="token parameter">int<span class="token punctuation">[</span><span class="token punctuation">]</span> a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token comment">// 特殊判断</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token comment">// 判断是否在边界</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token comment">// 不在边界就一定在中间</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-91d2467851614afda1887425fefa1f23" data-id="91d2467851614afda1887425fefa1f23"><span><div id="91d2467851614afda1887425fefa1f23" class="notion-header-anchor"></div><a class="notion-hash-link" href="#91d2467851614afda1887425fefa1f23" title="方法2 二分"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">方法2 二分</span></span></h4><div class="notion-text notion-block-42384190136446838fbc44ca4925f781">之前的文章我们分析过了，如果一个数组是<code class="notion-inline-code">distinct</code>的，那么这个数组至少会有一个峰值，且如果峰值的下标i不属于<span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>，那么峰值一定会出现在数组A的起始或者末尾，基于上述的结论，二分法在distinct的数组里面一定能找到峰值，我们不断往更大值的方向走就行了。</div><pre class="notion-code language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> int <span class="token function">findPeakElement</span><span class="token punctuation">(</span><span class="token parameter">int<span class="token punctuation">[</span><span class="token punctuation">]</span> nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        int n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> m <span class="token operator">=</span> i <span class="token operator">+</span> j <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            m <span class="token operator">=</span> i <span class="token operator">+</span> j <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> m <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 边界条件提前退出</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> m<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">?</span> m <span class="token operator">:</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">?</span> m <span class="token operator">:</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token comment">// 非边界条件，正常返回i</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-d516ef379bf449b1b78a1dfcbfd54372" data-id="d516ef379bf449b1b78a1dfcbfd54372"><span><div id="d516ef379bf449b1b78a1dfcbfd54372" class="notion-header-anchor"></div><a class="notion-hash-link" href="#d516ef379bf449b1b78a1dfcbfd54372" title="方法3 改进的暴力"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">方法3 改进的暴力</span></span></h4><div class="notion-text notion-block-0283e71ccbb64c18b3d010e4c5e8c6d0">由山脉数组这道题推导得来的结论
其实这种严格不重复的数组不外乎就四种形状</div><ul class="notion-list notion-list-disc notion-block-12fce12000ba4128ac7bce7485172fa3"><li>一直上升</li></ul><ul class="notion-list notion-list-disc notion-block-228edd91e85a4362b9b24d15e8fe4609"><li>一直下降</li></ul><ul class="notion-list notion-list-disc notion-block-4fb2880e20da43c292dceba4385bde9c"><li>先上升后下降</li></ul><ul class="notion-list notion-list-disc notion-block-4ba08dc37e514e03815d5ba7ec26e41b"><li>先下降再上升</li></ul><div class="notion-text notion-block-c7d6b8f3bcff4040b85ecb44ea3739ad">任何更复杂的数组，它的局部一定能找到上述形状，既然局部存在着上述形状，那么一定会存在峰值，所以我们可以分析这四种形状来解决问题</div><div class="notion-text notion-block-40e2ecf8e2054e948d015f29d12c5de0">基于这个性质，我提出假设：<code class="notion-inline-code">我们使i=0，然后从第一个元素开始比较，只需要比较第i个元素和第i+1个元素的大小即可</code></div><div class="notion-text notion-block-3e7fc7b2b8f04be4ae9bd404b5217c80">对于假设的证明，我们使用反证法：</div><blockquote class="notion-quote notion-block-06bb18e0c8484de194afe25c1ae7c520">对于i属于0到A.length-1，当A[i]&gt;A[i+1]的时候，A[i]一定是峰值。
这是因为如果A[i]不是峰值，那么必定有A[i-1]&gt;A[i]，此时如果A[i-1]是峰值就不会遍历到A[i]，所以A[i-1]不是峰值，继续往上推导，得出结论A[0]一定大于A[1]，否则A[1]是峰值，但是A[1]不是，所以A[0]一定大于A[1]，于是A[0]是峰值，但是A[0]必然不是峰值，因为已经遍历到A[i]，所以可以得出A[0],A[1]...A[i-1]一定是小于A[i]的，反证法得出A[i]一定是峰值</blockquote><div class="notion-text notion-block-9c34fe62f74b4c07b422d3384967bd14">由上我们可以得出更加简洁的暴力法</div><pre class="notion-code language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> int <span class="token function">findPeakElement</span><span class="token punctuation">(</span><span class="token parameter">int<span class="token punctuation">[</span><span class="token punctuation">]</span> nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        int i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-dc8dc1a6b72f46029e9cb913603088f1" data-id="dc8dc1a6b72f46029e9cb913603088f1"><span><div id="dc8dc1a6b72f46029e9cb913603088f1" class="notion-header-anchor"></div><a class="notion-hash-link" href="#dc8dc1a6b72f46029e9cb913603088f1" title="方法4 改进的二分"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">方法4 改进的二分</span></span></h4><div class="notion-text notion-block-c6372147350c4882ae463eb5aa2e841f">我们再继续讨论一下二分法能否用在这个问题上，对于nums，我们随机取得一个下标mid，<span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>，当nums[mid]同时满足<code class="notion-inline-code">nums[mid-1]&lt;nums[mid]&lt;nums[mid+1]</code>的时候，mid对应了一个峰值。</div><div class="notion-text notion-block-2c2873ce7268431c830ef38f2183a8d4">但是经过上述的讨论我们发现，改进的暴力法只需要比较nums[mid]和nums[mid+1]的大小即可，由此我们先<b>尝试</b>写出二分的三个步骤，再验证是否正确。
三个步骤就是：满足条件（二分边界），往左二分，往右二分</div><div class="notion-text notion-block-249800eed2164bc0acf7ea0ff1d2f6af">取mid</div><ol start="1" class="notion-list notion-list-numbered notion-block-a02c73428477482eaa1039ecdd9471c3"><li>如果<code class="notion-inline-code">nums[mid]&gt;nums[mid+1]</code>，此时需要判断<code class="notion-inline-code">nums[mid-1]</code>与<code class="notion-inline-code">nums[mid]</code>的关系，需要往左边二分，由于<code class="notion-inline-code">nums[mid]</code>有可能是峰顶，所以我们往左边二分的区间是<code class="notion-inline-code">[left,mid]</code></li></ol><ol start="2" class="notion-list notion-list-numbered notion-block-a64d1dcf8804459f852b0f7a9093c1a8"><li>如果<code class="notion-inline-code">nums[mid]&lt;nums[mid+1]</code>，那么<code class="notion-inline-code">nums[mid]</code>必然不是峰顶，而<code class="notion-inline-code">numd[mid+1]</code>是峰顶的可能性存在，所以我们需要往右边二分，二分的区间是<code class="notion-inline-code">[mid+1,right]</code></li></ol><ol start="3" class="notion-list notion-list-numbered notion-block-9d26696d9310496fbb49af58fe2f98c0"><li>上面分别是往左和往右二分的情况，现在我们需要终止二分的条件，思考<b>极端情况</b>，当数组元素只有一个的时候，那么这个元素一定是峰值，所以我们可以得出，当二分的left和right相等的时候，此时直接返回left即可，这个元素一定是峰值</li></ol><div class="notion-text notion-block-10f11e425a224b79ad5972aa9056574b">观察1，2两个步骤，可能会有疑问，如果往左或者往右二分的时候，峰值不存在怎么办？回到这篇文章的1D finding推论，当多次二分达到边界之后，此时边界一定会是峰值，所以这样二分是正确的</div><div class="notion-text notion-block-3d5b4f9f91164e77aae7628d637c4b55">由此可以写出代码</div><pre class="notion-code language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> int <span class="token function">findPeakElement</span><span class="token punctuation">(</span><span class="token parameter">int<span class="token punctuation">[</span><span class="token punctuation">]</span> nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        int n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            int m <span class="token operator">=</span> i <span class="token operator">+</span> j <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                j <span class="token operator">=</span> m<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><hr class="notion-hr notion-block-d4c784c09fc446cf9f282b547fe788b8"/><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-305d765ad8f84524a1189211ae1de198" data-id="305d765ad8f84524a1189211ae1de198"><span><div id="305d765ad8f84524a1189211ae1de198" class="notion-header-anchor"></div><a class="notion-hash-link" href="#305d765ad8f84524a1189211ae1de198" title="74. 搜索二维矩阵"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">74. 搜索二维矩阵</span></span></h3><div class="notion-text notion-block-625b0a5596864d6c92b8d4aea050c61f"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://leetcode-cn.com/problems/search-a-2d-matrix/">https://leetcode-cn.com/problems/search-a-2d-matrix/</a></div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-ef7935b017f74a8aa64a0a8f10bb1e45" data-id="ef7935b017f74a8aa64a0a8f10bb1e45"><span><div id="ef7935b017f74a8aa64a0a8f10bb1e45" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ef7935b017f74a8aa64a0a8f10bb1e45" title="方法1 暴力"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">方法1 暴力</span></span></h4><div class="notion-text notion-block-dfc0238b0b1c42d98a953f947d6fe3a8">首先暴力法很容易想到，时间复杂度$O(MN)$</div><pre class="notion-code language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> boolean <span class="token function">searchMatrix</span><span class="token punctuation">(</span><span class="token parameter">int<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> int target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>int j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> 
                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-76d1be15edd2493082f7c01e3bcdb7b8" data-id="76d1be15edd2493082f7c01e3bcdb7b8"><span><div id="76d1be15edd2493082f7c01e3bcdb7b8" class="notion-header-anchor"></div><a class="notion-hash-link" href="#76d1be15edd2493082f7c01e3bcdb7b8" title="方法2 二分"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">方法2 二分</span></span></h4><div class="notion-text notion-block-e1f201a5c7cc4424896171947e7e0872">一个二维矩阵，总是可以展开成一维数组来存储，满足题目中条件的矩阵展开成一维数组后就是一个升序序列，求一个升序序列中是否存在目标值，当然可以用二分法来做，明确可以用二分之后，也有很多种做法，这里先写用整个矩阵来二分</div><pre class="notion-code language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> boolean <span class="token function">searchMatrix</span><span class="token punctuation">(</span><span class="token parameter">int<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> int target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        int r <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">,</span> c <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">,</span> size <span class="token operator">=</span> r <span class="token operator">*</span> c<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            int m <span class="token operator">=</span> i <span class="token operator">+</span> j <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
            int x <span class="token operator">=</span> m <span class="token operator">/</span> c<span class="token punctuation">,</span> y <span class="token operator">=</span> m <span class="token operator">%</span> c<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        int x <span class="token operator">=</span> i <span class="token operator">/</span> c<span class="token punctuation">,</span> y <span class="token operator">=</span> i <span class="token operator">%</span> c<span class="token punctuation">;</span> 
        <span class="token keyword">return</span> target <span class="token operator">==</span> matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-5af69ac526c247eeb64d48d1ce11baec">上面是用整个矩阵做二分，时间复杂度是<span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>。</div><div class="notion-text notion-block-2122f81efd2142ba9500aeeb6eec4bd1">注意到这个矩阵里面，每一行都是一个升序序列，那么我们可以确定target在矩阵中大概位于哪一行，然后再在那个区间判断，这样不需要对整个矩阵做二分了</div><div class="notion-text notion-block-aeead7e7552449d68c0fbd4b889c317b">改进后的二分解法，时间复杂度是$O(m+log(n))$</div><pre class="notion-code language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> boolean <span class="token function">searchMatrix</span><span class="token punctuation">(</span><span class="token parameter">int<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> int target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        int r <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">,</span> c <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">,</span> size <span class="token operator">=</span> r <span class="token operator">*</span> c<span class="token punctuation">;</span>
        <span class="token comment">// 1. 确认target处于哪一行</span>
				int ind <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>ind <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ind <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> ind <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>ind<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>ind<span class="token punctuation">]</span><span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ind <span class="token operator">==</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        int<span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> matrix<span class="token punctuation">[</span>ind<span class="token punctuation">]</span><span class="token punctuation">;</span>
			  <span class="token comment">// 注意边界条件，我们在循环内部判断i == j的情况，外层直接返回false即可</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            int m <span class="token operator">=</span> i <span class="token operator">+</span> j <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">></span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span> i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-e81d535e82e94a298b01413157e781df">注意到 矩阵的第一列一定也是一个升序数组，所以我们对第一个遍历过程改成二分</div><pre class="notion-code language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> boolean <span class="token function">searchMatrix</span><span class="token punctuation">(</span><span class="token parameter">int<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> int target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        int ind <span class="token operator">=</span> <span class="token function">findIndex</span><span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ind <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>ind<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> int <span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">int<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> int target</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            int m <span class="token operator">=</span> i <span class="token operator">+</span> j <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果起始元素大于target，hi不动，让lo逼近hi</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                j <span class="token operator">=</span> m<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> boolean <span class="token function">helper</span><span class="token punctuation">(</span><span class="token parameter">int <span class="token constant">A</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> int target</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            int m <span class="token operator">=</span> i <span class="token operator">+</span> j <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> 
                j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-6020a6f59af640f4be307fb773c7d4ec">写得很复杂，没有原来的方法简洁，但是时间复杂度变为<span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span></div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-e7778d53c2114a3aa7a247a5c0699b24" data-id="e7778d53c2114a3aa7a247a5c0699b24"><span><div id="e7778d53c2114a3aa7a247a5c0699b24" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e7778d53c2114a3aa7a247a5c0699b24" title="方法3 利用数组特性"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">方法3 利用数组特性</span></span></h4><div class="notion-text notion-block-46a79ce6fdf3411c9e2fd668abb274b0">这个数组的特点很明显，要想办法利用一下</div><blockquote class="notion-quote notion-block-cbbd11f7c9a440778a76ffe1c3f5b14b">每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。</blockquote><pre class="notion-code language-plain text"><code class="language-plain text">matrix <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>   <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token number">5</span><span class="token punctuation">,</span>  <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span>
<span class="token punctuation">]</span></code></pre><div class="notion-text notion-block-4a5a54dea6fb4394a402ebe9437624af">比如这个数组，我们逆时针旋转90度，以7为出发点，就能得到一颗类似于二叉搜索树的矩阵，那么我们从根节点出发，利用搜索树的特性就能得到答案了</div><pre class="notion-code language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> boolean <span class="token function">searchMatrix</span><span class="token punctuation">(</span><span class="token parameter">int<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> int target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        int n <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">,</span> m <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        int x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> y <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                y <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-75336fe3b3a241f988c35157cb0b7f2a">时间复杂度<span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>，上面的解法在《剑指offer》里面也有介绍</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-3be08939e4954e2d959a305f8d5d7c9e" data-id="3be08939e4954e2d959a305f8d5d7c9e"><span><div id="3be08939e4954e2d959a305f8d5d7c9e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3be08939e4954e2d959a305f8d5d7c9e" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h3><div class="notion-text notion-block-2e667b88a1a64b848026337d91d30dc7">上面这三道题就是finding问题，由于数组的特殊性，巧妙的解法都是从<code class="notion-inline-code">A[M]</code>和<code class="notion-inline-code">A[M-1],A[M+1]</code>的关系来入手的</div><div class="notion-blank notion-block-9e42295148504d9fadebd1e0060edaf7"> </div></main>]]></content:encoded>
        </item>
    </channel>
</rss>