<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>《图解TCP/IP》中的TCP与UDP&nbsp;|&nbsp;Notablog</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="《图解TCP/IP》中的TCP与UDP">
  
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>关于我</span>
        </div>
      </a>
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <h1 class="Header__Title">《图解TCP/IP》中的TCP与UDP</h1>
    
      <div class="DateTagBar">
        
          <span class="DateTagBar__Item DateTagBar__Date">Posted on Wed, Nov 16, 2022</span>
        
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--purple">
            <a href="tag/计算机网络.html">计算机网络</a>
          </span>
        
      </div>
    
  </header>
  <article id="https://www.notion.so/cf334beb59e147738c01cf916f3a5625" class="PageRoot"><ul id="https://www.notion.so/d0c9a1d327e94ce49e74aa4ef105a2ef" class="ColorfulBlock ColorfulBlock--ColorGray TableOfContents"><li class="TableOfContents__Item"><a href="#https://www.notion.so/1d24d55f37d146ba90c20ee06fbe1cfb"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">简介</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/67ece120eb164a569a498344c260f234"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">UDP</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/10ee0ecb01f24e748f63ec18f4b0bbaa"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">TCP</span></span></div></a></li></ul><h1 id="https://www.notion.so/1d24d55f37d146ba90c20ee06fbe1cfb" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/1d24d55f37d146ba90c20ee06fbe1cfb"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">简介</span></span></h1><div id="https://www.notion.so/5b48a49d2e9c4e5499cd51f7907c3ac7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">TCP（Transmission Control Protocol）与UDP（User Datagram Protocol）是传输层中两个主要协议。往下是网络层IP协议，往上是应用层HTTP协议，它们对承上启下起了很重要的作用。</span></span></p></div><h1 id="https://www.notion.so/67ece120eb164a569a498344c260f234" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/67ece120eb164a569a498344c260f234"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">UDP</span></span></h1><div id="https://www.notion.so/bf1023f87a8f468188c1a90eed3fa915" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">UDP</strong></span><span class="SemanticString">是不具有可靠性的数据报协议。UDP只会负责把数据发送出去，并不负责数据是否有接受对象。通常情况下，UDP主要应用于那些对高速传输和实时性有较高要求的通信和广播通信。如IP电话，视频，语音聊天等，即使丢失部分数据，也并无大碍。
</span></span></p></div><div id="https://www.notion.so/f5844c1840c94be5992354b32ec85b9a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">UDP的特点及其目的</strong></span></span></p></div><div id="https://www.notion.so/21e649b30b864739a2f39db4ed0416c1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。</span></span></p></div><div id="https://www.notion.so/2cac28b2b63d4dd89ddc80cf6d8ad892" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">UDP面对网络拥堵的情况下，无法进行流量控制等避免网络拥塞的行为。</span></span></p></div><div id="https://www.notion.so/453ff964690646acae9c1d39ed7214f7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">UDP在传输过程中即使丢包，也不负责重发。</span></span></p></div><div id="https://www.notion.so/adfd87e49d25422cbbdf2798bb83566b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">UDP并不会调整包到达接受端的顺序，当数据包出现乱序时，需要使用UDP的应用程序自行管理。</span></span></p></div><div id="https://www.notion.so/ebc68180750c46dd8a626418331324e8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">UDP主要应用于：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/4260600114864e6eb32097aac60ac98b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">包总量较少的通信：DNS，SNMP等</span></span></li><li id="https://www.notion.so/dd33b58b6bda4e67b97cec038f1ef22c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">视频、音频等多媒体通信</span></span></li><li id="https://www.notion.so/721c9a3f7791401096bc8ed14d5b268c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">广播通信（广播、多播）</span></span></li></ul><div id="https://www.notion.so/381afd85ee8a43008b9c795e73c31fea" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h1 id="https://www.notion.so/10ee0ecb01f24e748f63ec18f4b0bbaa" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/10ee0ecb01f24e748f63ec18f4b0bbaa"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">TCP</span></span></h1><div id="https://www.notion.so/d3ff9ac836f7417c864df77a488b60e1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">TCP</strong></span><span class="SemanticString">是面向连接的，可靠的流协议，通过检验和，序列号，确认应答，重发控制，连接管理以及窗口控制等机制实现可靠性传输。TCP更多应用在对数据安全有要求的场景。</span></span></p></div><div id="https://www.notion.so/3a45bd15462842729383d2881c7ea7a0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">TCP的特点及其目的</strong></span></span></p></div><div id="https://www.notion.so/ec701e2a574141f2bffa6a72aab92edc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">与UDP相比，TCP是一种面向有连接的协议，只有在确认通信对端存在是才会返送数据，从而可以控制通信流量的浪费。TCP通过检验和，序列号，确认应答，重发控制，连接管理以及窗口控制等机制实现可靠性传输。</span></span></p></div><div id="https://www.notion.so/bfe5c9cd46c64a52a1cffd0f1c10f44e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">如何保证可靠传输？</strong></span></span></p></div><div id="https://www.notion.so/018da4085bda474aae795fd5dbf9d889" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">TCP通过序列号保证数据的可靠</span></span></p></div><div id="https://www.notion.so/61563209378b42f88cf6c3ae0d88aba0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在TCP中，当发送端的数据到达接受主机时，接收端主机会返回一个已收到消息的通知，这个消息叫做确认应答（ACK）。</span></span></p></div><div id="https://www.notion.so/f1deb0679b014898aea849173cea7315" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">ACK (Acknowledgement）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。</span></span></p></div><div id="https://www.notion.so/132ca21f99ce471cb6b86fd3f6235fe6" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/67b6974e849c4fc286b5950236a5ad7f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这样，TCP就能通过ACK实现可靠的数据传输。
ACK通常通过序列号来确定。
序列号是按顺序给发送数据的每一个字节（8位字节）都标上号码的面好，接受端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接受的序号作为应答返回给发送端。通过序列号和确认应答号，TCP就可以实现可靠传输。</span></span></p></div><div id="https://www.notion.so/fb77b0a30cf544a79b9d2f943b376f6c" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/623562a3c1d24536a75cf38e77b6ed35" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/68387944bef24a57889385b8a4eb750e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">通常有两种情况会导致ACK接收不正常，为了避免丢包，就引入了重发机制进行管理。###TCP以端为单位发送数据
在建立TCP链接的同时，往往胡确定发送数据包的单位，我们将其称为“最大消息长度”（MSS:Maximum Segment Size)。最理想的情况正好是IP中不会被分片处理的最大数据长度。
TCP在传送大量数据是，是以MSS的大小将数据进行分割发送，进行重发时也会以MSS为单位。</span></span></p></div><div id="https://www.notion.so/97ae5dbc57b34198a68c65810e4762f6" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/892587737c6b40a98251c2c1cdc45444" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">###利用窗口提高传输速度
前面提到TCP以MSS为单位进行传输，为确保数据的可靠性，每次发送一个包就会进行一次确认应答，这样做虽然能确保数据可靠无误，但是会降低通信性能。</span></span></p></div><div id="https://www.notion.so/c97c9df4476643d9b39a4a20ca82f2f3" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/26722fadaee74dd7884e52d671f89dd9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">为了解决这个问题，TCP引入了窗口，此时确认应答不再是以每个分段，而是以更大的单位进行确认，这样会大幅度缩短转发时间。</span></span></p></div><div id="https://www.notion.so/082cab17dadf41d097f3e200d7ac566e" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/facea7aadd864133b2edcf4b84e0e156" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这个机制实现使用了大量的缓冲区。例如发送端A拥有自己的发送缓冲区，同样接收端B也拥有自己的接收缓冲区。当数据从A到B传输时，B没办法一次接收所有数据，所以先把数据存入缓冲区，然后再写入设备中。所以限制了A每次发送分段制定数量的字节数。这样就确认了窗口的大小。
下图时窗口工作流程，下面会介绍更细分的窗口控制。</span></span></p></div><div id="https://www.notion.so/4fd82c18b4924fde9ce4f5d5ed21c9d0" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/729b3bdb638d44e19a22ea12e5c2e5f9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">（注：窗口流程介绍转载自</strong></span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="http://network.51cto.com/art/201501/464002.htm"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">大师带你了解TCP基本功之滑动窗口</strong></a></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">）</strong></span></span></p></div><div id="https://www.notion.so/ceda358e4d544f648ed21c70f042fa9e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果我们在任一时间点对于这一过程做一个“快照”，那么我们可以将TCP buffer中的数据分为以下四类</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/7a6e15f298da4364b4247a2af6dfcf50" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><em class="SemanticString__Fragment SemanticString__Fragment--Italic">已发送已确认</em></span><span class="SemanticString">
数据流中最早的字节已经发送并得到确认。这些数据是站在发送设备的角度来看的。如下图所示，31个字节已经发送并确认。</span></span></li><li id="https://www.notion.so/2b01358d637a4246b4f1b7f8f68b7781" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><em class="SemanticString__Fragment SemanticString__Fragment--Italic">已发送但尚未确认</em></span><span class="SemanticString">
已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。下图所示14字节为第2类。</span></span></li><li id="https://www.notion.so/c303313851684f95911b6bd7ff126d15" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString"><em class="SemanticString__Fragment SemanticString__Fragment--Italic">未发送而接收方已Ready 设备尚未将数据发出</em></span><span class="SemanticString">
但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。如图，第3类有6字节。</span></span></li><li id="https://www.notion.so/da645fdb662e4d3c8b85745c09d2118a" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString"><em class="SemanticString__Fragment SemanticString__Fragment--Italic">未发送而接收方Not Ready</em></span><span class="SemanticString">
由于接收方not ready，还不允许将这部分数据发出。
</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">发送窗口与可用窗口：</strong></span><span class="SemanticString">
整个过程关键的操作在于接收方允许发送方一次能容纳的未确认的字节数。这称为发送窗口，有时也称为窗口。该窗口决定了发送方允许传送的字节数，也是2类和3类的字节数之和。因此，最后两类(接收方准备好而尚未发送，接收方未准备好)的分界线在于添加了从第一个未确认字节开始的窗口。本例中，第一个未确认字节是32，整个窗口大小是20。
可用窗口的定义是：考虑到正在传输的数据量，发送方仍被允许发送的数据量。实际上等于第3类的大小。左边界就是窗口中的第一个字节(字节32)，右边界是窗口中最后一个字节(字节51)。概念的详细解释看下图。
</span><span class="SemanticString">
可用窗口字节发送后TCP类目与窗口大小的改变：</span></span><div id="https://www.notion.so/50cce779110a4be9928b115650e4242f" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/ebba61848a3d4b36917c247c5099282a" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div></li></ol><div id="https://www.notion.so/c93f9ae28982420cac89f0ce608d2c01" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当上图中第三类的6字节立即发送之后，这6字节从第3类转移到第2类。字节变为如下：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/f3c1a28657684eb3858115098fd9bfe2" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">已发送已确认字节1至31。</span></span></li><li id="https://www.notion.so/1e35035532754eb88ce28e1861f91089" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">已发送但尚未确认字节32至51。</span></span></li><li id="https://www.notion.so/c69ab7a8e7a643dfbe3e5e98b6a44a93" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">未发送而接收方已Ready字节为0。</span></span></li><li id="https://www.notion.so/897c5f7b4df04d3dbeb96d71f46d0125" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">未发送而接收方Not Ready字节52至95。
</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">确认处理以及窗口缩放：</strong></span></span><div id="https://www.notion.so/fa73f6ffe5f84b1da018ba802f824cc2" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div></li></ol><div id="https://www.notion.so/2bac0eb14a984a7dbe32e85247b2b89f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">过了一段时间，目标设备向发送方传回确认信息。目标设备不会特别列出它已经确认的字节，因为这会导致效率低下。目标设备会发送自上一次成功接收后的最长字节数。</span></span></p></div><div id="https://www.notion.so/e94cb17216a54da4a3a6f64732538794" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">例如，假设已发送未确认字节(32至45)分为4段传输：32-34，35-36，37-41，42-45。第1，2，4已经到达，而3段没有收到。接收方只会发回32-36的确认信息。接收方会保留42-45但不会确认，因为这会表示接收方已经收到了37-41。这是很必要的，因为TCP的确认机制是累计的，只使用一个数字来确认数据。这一数字是自上一次成功接收后的最长字节数。假设目标设备同样将窗口设为20字节。</span></span></p></div><div id="https://www.notion.so/997ea8f902e14298ac83e30181f3109c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当发送设备接收到确认信息，则会将一部分第2类字节转移到第1类，因为它们已经得到了确认。由于5个字节已被确认，窗口大小没有改变，允许发送方多发5个字节。结果，窗口向右滑动5个字节。同时5个字节从第二类移动到第1类，5个字节从第4类移动至第3类，为接下来的传输创建了新的可用窗口。因此，在接收到确认信息以后，看起来如下图所示。字节变为如下：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/88700a2b0f6646ec818cd926bfe13b69" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">已发送已确认字节1至36。</span></span></li><li id="https://www.notion.so/b1cddbb512dd4259b8bb4d964dd536f5" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">已发送但尚未确认字节37至51。</span></span></li><li id="https://www.notion.so/94b144718aa340aeb5315426b51e5355" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">未发送而接收方已Ready字节为52至56。</span></span></li><li id="https://www.notion.so/d6b310bd18d54dc98f57b48c558167a5" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">未发送而接收方Not Ready字节57至95。
</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">处理丢失确认信息</strong></span><span class="SemanticString">：
但是丢失的42-45如何处理呢?在接收到第3段(37-41)之前，接收设备不会发送确认信息，也不会发送这一段之后字节的确认信息。发送设备可以将新的字节添加到第3类之后，即52-56。发送设备之后会停止发送，窗口停留在37-41。
TCP包括一个传输及重传的计时机制。TCP会重传丢失的片段。但有一个缺陷是：因为它不会对每一个片段分别进行确认，这可能会导致其他实际上已经接收到的片段被重传(比如42至45)。
###TCP在丢包时有重发控制
ACK接收不正常一般有两种原因，一种是发送端发送的报文丢失，另一种是接收端返回的ACK丢失。TCP有两种机制，一种是无窗口下的超时重发机制，另一种是有窗口控制下的高速重发机制。这两种机制都对上述的两种原因有应对方法。
####在无窗口下的重发控制
#####发送端丢包
</span><span class="SemanticString">
#####ACK丢失
</span><span class="SemanticString">
通过上述两张图片可以看出无窗口模式下的重发机制。即等待一段特定的时间间隔，然后重新发送数据。那么问题来了，为了提高速度，这个超时重发的具体时间长度有如何确定呢？
TCP对每次发包时都会计算往返时间及其偏差。为了避免丢包，重发时间就是比往返时间家偏差总和要稍大的时间。</span></span><div id="https://www.notion.so/bc992855e101418995a2332be56b3c9f" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/88132630842342f8a413296a7a4bcb5e" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/3bb1f893282d46b0ba9d7a898c0d691b" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/412f1efaea2d40508f1bf01e73890533" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div></li></ol><div id="https://www.notion.so/0ba404ff6915496d93fa176be4a6ff3b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">####在窗口控制下的重发机制
1.ACK丢失</span></span></p></div><div id="https://www.notion.so/696e4d3a6f45426fa2d5855cf8670bb2" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/6b84926b9f77416d963dec0a39d0ce34" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">前面介绍了窗口以更大的段为单位发送数据，所以少部分丢失并无大碍。
2.发送端丢包</span></span></p></div><div id="https://www.notion.so/5dd716382acd47ba99060500188c831c" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/5c06c6e1d8eb4156a5f8f9283baef0a9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">###TCP对次序乱掉的分包进行顺序控制传递
（转载自</span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://blog.csdn.net/ggxxkkll/article/details/7894112">TCP是如何保证包的顺序传输？</a></span><span class="SemanticString">）
主机每次发送数据时，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认，如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等，接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理。
具体步骤如下：
（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；</span></span></p></div><div id="https://www.notion.so/d4c1797dd7594902aeb49389d7afce24" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">（2）并为每个已发送的数据包启动一个超时定时器；</span></span></p></div><div id="https://www.notion.so/146b428a14cf4ac88d5932101dbfe831" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;</span></span></p></div><div id="https://www.notion.so/a312dd7c78a9449f9bb98eeef04a7d10" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。</span></span></p></div><div id="https://www.notion.so/112a8a8b7e6c467faa0826024b1111e8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">（5）接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</span></span></p></div><div id="https://www.notion.so/78d8256a246641c1be6dedd47b02e80a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">###最后介绍三种控制：流控制，拥塞控制，Nagle算法
####流控制
发送端根据自己的实际情况发送数据，但是接收端可能收到一个对自己来说毫无意义同时需要花费时间处理的数据包。接受数据包过多，就会引发高负荷，此时无法再接受任何数据。当接收端不得不丢弃自己本该接受的数据时，又会触发重发机制。
因此我们需要引入流机制——让发送端根据接受端的实际接受能力控制发送的数据量。</span></span></p></div><div id="https://www.notion.so/6c1592330bb740aa9f442b46c6ebcf7f" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/ec0fb0d079aa43788a80b2d4b8a9101f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">####拥塞控制
有了TCP的窗口控制，收发主机不在以一个数据段为单位发送确认应答，同时能够连续发送大量的数据包。
但是，如果在通信刚开始时就发送大量的数据，也可能会引发其它问题。
TCP为了防止这些问题的出来，在通信开始时就会通过一个叫做慢启动算法来对数据的发送量进行控制。</span></span></p></div><div id="https://www.notion.so/03c149c0291e4a89a55b439c1674be91" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/5827b9985954496ab4baa58313c3bd1e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">####Nagle算法
转载自</span></span></p></div><div id="https://www.notion.so/4264f54536ba4576b591bb838521871b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://blog.csdn.net/wdscq1234/article/details/52432095">TCP-IP详解：Nagle算法</a></span></span></p></div><div id="https://www.notion.so/58dad9d98d1f47368b0dc7979bb32367" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在使用一些协议通讯的时候，比如Telnet，会有一个字节字节的发送的情景，每次发送一个字节的有用数据，就会产生41个字节长的分组，20个字节的IP Header 和 20个字节的TCP Header，这就导致了1个字节的有用信息要浪费掉40个字节的头部信息，这是一笔巨大的字节开销，而且这种Small packet在广域网上会增加拥塞的出现。
Nagle算法主要是避免发送小的数据包，要求TCP连接上最多只能有一个未被确认的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的小分组，并在确认到来时以一个分组的方式发出去。</span></span></p></div></article>
  <footer class="Footer">
  <div>&copy; Notablog 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>