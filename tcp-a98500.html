<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>TCP的重传机制、滑动窗口、流量控制、拥塞控制&nbsp;|&nbsp;Notablog</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="TCP的重传机制、滑动窗口、流量控制、拥塞控制">
  
    <meta name="description" content="针对不稳定网络环境提出的补偿机制">
    <meta property="og:description" content="针对不稳定网络环境提出的补偿机制">
  
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>关于我</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <h1 class="Header__Title">TCP的重传机制、滑动窗口、流量控制、拥塞控制</h1>
    
      <div class="DateTagBar">
        
          <span class="DateTagBar__Item DateTagBar__Date">Posted on Tue, Nov 22, 2022</span>
        
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--purple">
            <a href="tag/计算机网络.html">计算机网络</a>
          </span>
        
      </div>
    
  </header>
  <article id="https://www.notion.so/a98500dc0a284e5fa8f5b910166fc203" class="PageRoot"><ul id="https://www.notion.so/5512127c23ac4425ba6458e160da6e4e" class="ColorfulBlock ColorfulBlock--ColorGray TableOfContents"><li class="TableOfContents__Item"><a href="#https://www.notion.so/731682e6cc1b4388b8ae7cc3c633db74"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">简介</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/bf0b545b8ede4e2fae20de56121ef266"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">重传机制</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/6c367ce154cf43b99256c96524b040c9"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">超时重传</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/6bfeb9f05a0947d69cfd46c12e43b6c0"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">快速重传</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/5b1376bc7736499c993b1139fe820dd7"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">SACK方法</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/e624528509fb42628f89e427a959c074"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">DSACK方法</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/ba5cdc2322364d2faa38c0f36913cba0"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">滑动窗口</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/dd8ee87e27864649ba3df2345bcdff48"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">流量控制</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/da454dfa40e84d938fb8641bd5f8aaf8"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">拥塞控制</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/f32971daa0694402936f9e8f987ad286"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">什么是拥塞窗口</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/1f15c75706b24e458bbf01d5be5af417"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">慢启动</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/2c573c5eec3c45d5850967f5394b5991"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">拥塞避免</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/dcca9c5dab2048e7a6c2c7faab022fba"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">拥塞发生算法</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/44c84247d9ad460b80b5e4166148a574"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">快速恢复</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/12c5b4586f384e5bb6ac7ec34e2be511"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">Ref</span></span></div></a></li></ul><h1 id="https://www.notion.so/731682e6cc1b4388b8ae7cc3c633db74" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/731682e6cc1b4388b8ae7cc3c633db74"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">简介</span></span></h1><blockquote id="https://www.notion.so/7b384203f4664f77a0622c5584c0f1be" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">本文是阅读</span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding (xiaolincoding.com)</a></span><span class="SemanticString">的笔记，想要了解更多细节请看原文</span></span></blockquote><div id="https://www.notion.so/a306cb8420db4b04b958234ac3146659" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">先说结论</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/000fd40e69e645f4b4ad61b3297612a0" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">流量控制：针对发送方和接收方速度不匹配的问题，限制发送方的速度，是端对端的场景</span></span></li><li id="https://www.notion.so/de0b2d76410641cfa7d971bf792c6eee" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">拥塞控制：根据整个网络环境来调整发送速度，避免引起网络拥塞导致传输质量下降，是针对整个网络环境而言的</span></span></li></ul><div id="https://www.notion.so/74aed26b28074c58939b662359b2b015" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">为了更详细的介绍这两种控制机制，我们先引入重传和滑动窗口这两个概念。</span></span></p></div><h1 id="https://www.notion.so/bf0b545b8ede4e2fae20de56121ef266" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/bf0b545b8ede4e2fae20de56121ef266"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">重传机制</span></span></h1><div id="https://www.notion.so/7eb519d416b447d8a4337ed6d49bb4e9" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F71a8f7c0-1b8d-4e77-88db-56364a4037df%2FUntitled.png?width=1952&amp;table=block&amp;id=7eb519d4-16b4-47d8-a433-7ed6d49bb4e9"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F71a8f7c0-1b8d-4e77-88db-56364a4037df%2FUntitled.png?width=1952&amp;table=block&amp;id=7eb519d4-16b4-47d8-a433-7ed6d49bb4e9" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><blockquote id="https://www.notion.so/b904926ccfce44c6a21a5c51fc00dad5" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">针对网络环境不稳定，可能会出现丢包情况设计的补偿机制。一共有四种：超时重传，快速重传，SACK方法，D-SACK方法</span></span></blockquote><div id="https://www.notion.so/8ee471d509964269a7ea82e16b7e5f6c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">首先说我们为什么需要重传？理想状态下的网络环境不会丢失，发送方发送一个，接收方就返回一个ACK确认消息。但是实际情况下，发送方的消息和接收方的ACK都有可能会丢失，如果不做重传补偿的话，丢失的数据是无法正常交付的。</span></span></p></div><div id="https://www.notion.so/e432099ddb1c44b0b543297480141591" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">针对这种情况，TCP设计了重传机制，一共有四种重传机制：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/570d467cefb74fc7818ffdcddbec0e4c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">超时重传：设计一个时间间隔</span></span></li><li id="https://www.notion.so/0e21883c9f4242ff897038d38366b214" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">快速重传：重复3次ACK就重传</span></span></li><li id="https://www.notion.so/dc67db82e7994a30b8fc006ff4e99e20" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">SACK 方法：通过额外信息告知发送方如何重传</span></span></li><li id="https://www.notion.so/d89c06bdc35741e6ae8ec035363f7a5f" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Duplicate SACK：告知发送方丢失包的原因</span></span></li></ul><h2 id="https://www.notion.so/6c367ce154cf43b99256c96524b040c9" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/6c367ce154cf43b99256c96524b040c9"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">超时重传</span></span></h2><div id="https://www.notion.so/b6a9977f09694ca38823de0bd29873f5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">核心思想就是设置一个定时器，如果一定时间内发送方没有接收到ACK，那么就视为数据包丢失，需要进行重传。</span></span></p></div><div id="https://www.notion.so/2ae0e51c85964edea5244fbe2d3b2b49" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F40b0315e-7141-40c1-b83a-744687b9ccac%2FUntitled.png?width=1092&amp;table=block&amp;id=2ae0e51c-8596-4ede-a524-4fbe2d3b2b49"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F40b0315e-7141-40c1-b83a-744687b9ccac%2FUntitled.png?width=1092&amp;table=block&amp;id=2ae0e51c-8596-4ede-a524-4fbe2d3b2b49" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/cbe8dd8e408b42928c0969df593e8410" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">那么现在问题的难点在于怎么定义这个超时时间：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/e72f9b6a140941fab7a5aa1ce80e9ad8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果RT0过小的时候，可能会频繁传输已经接受到的数据</span></span></li><li id="https://www.notion.so/e3ed3876bc734016937c37b1df9b77c0" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果RT0过大，接收方会迟迟收不到丢失的数据包</span></span></li></ul><div id="https://www.notion.so/806e3c02b99346a48b7ce8eb8a1d6c8e" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb83a4c93-86f5-4234-9fd9-5e51309df2d1%2FUntitled.png?width=1412&amp;table=block&amp;id=806e3c02-b993-46a4-8b7c-e8eb8a1d6c8e"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb83a4c93-86f5-4234-9fd9-5e51309df2d1%2FUntitled.png?width=1412&amp;table=block&amp;id=806e3c02-b993-46a4-8b7c-e8eb8a1d6c8e" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/0e998c9c2dcb42f3af518afd3d41948b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">为此TCP引入了</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">RTT( Round-Trip Time 往返时延)</code></span><span class="SemanticString">的概念，RTT指的是数据发送时刻到收到确认时刻的差值，也就是接收ACK时间-发送时间。</span></span></p></div><div id="https://www.notion.so/d83504a5f0834beda0e2b726a4c93b7f" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F37fa9b0d-bbf9-4a5d-80a2-068d2a5a7b80%2FUntitled.png?width=782&amp;table=block&amp;id=d83504a5-f083-4bed-a0e2-b726a4c93b7f"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F37fa9b0d-bbf9-4a5d-80a2-068d2a5a7b80%2FUntitled.png?width=782&amp;table=block&amp;id=d83504a5-f083-4bed-a0e2-b726a4c93b7f" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/fe883d5e10804ed9ade97aa8a3b528ac" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">超时重传时间是</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">RT0（Retransmission Timeout）</code></span><span class="SemanticString"> ，我们应该把RT0设置为略大于RTT。</span></span></p></div><div id="https://www.notion.so/e801e826557f40a9bdbecce0f7154f5c" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F641888fd-331c-4ce2-8b9e-d73bc35e5d14%2FUntitled.png?width=617&amp;table=block&amp;id=e801e826-557f-40a9-bdbe-cce0f7154f5c"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F641888fd-331c-4ce2-8b9e-d73bc35e5d14%2FUntitled.png?width=617&amp;table=block&amp;id=e801e826-557f-40a9-bdbe-cce0f7154f5c" style="width:617px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/a01fe3db26fd49f9b4c60a858bf72251" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">网络环境是不断变化的，RTT也是动态的，RTT的计算方法有很多，可以看这篇文章的介绍：</span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0">4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding (xiaolincoding.com)</a></span></span></p></div><div id="https://www.notion.so/ceec70d3f9a045ea8d78e9645b7d6be9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">超时重传的缺陷就是要设定这些超参数，快速重传设计思想不依赖于这些超参数。不过我们应该了解到重传机制并不是互斥的，我们可以在超时重传的基础上搭配快速重传。</span></span></p></div><h2 id="https://www.notion.so/6bfeb9f05a0947d69cfd46c12e43b6c0" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/6bfeb9f05a0947d69cfd46c12e43b6c0"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">快速重传</span></span></h2><div id="https://www.notion.so/3d42681bd2384ad1923b0e7048fb0c02" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">快速重传的核心思想很简单：</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">收到三次重复的ACK就进行重传</strong></span></span></p></div><div id="https://www.notion.so/a5cbb674fc0f493d90b4cdf8446e414c" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb1bebcc0-1b32-43e7-ba8d-09562ebcaa67%2FUntitled.png?width=647&amp;table=block&amp;id=a5cbb674-fc0f-493d-90b4-cdf8446e414c"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb1bebcc0-1b32-43e7-ba8d-09562ebcaa67%2FUntitled.png?width=647&amp;table=block&amp;id=a5cbb674-fc0f-493d-90b4-cdf8446e414c" style="width:647px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/3f2377bd3f43460dabf89b544ceb3f92" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">比如上面的例子，发送方在发送了Seq3、4、5的时候累计收到了3次ACK2的信号，那么就会重发Seq2。</span></span></p></div><div id="https://www.notion.so/f4672c186e124a9d86c4ec78db710364" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">但其实这里还有一个问题，就是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">发送方应该重传所有包，还是单个包</strong></span><span class="SemanticString">？</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/a4d61d950dc54c32afafa68a69418839" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">重传单个包：重传效率很低，如果ACK3也发生丢失，那么接下来收到3个ACK3，才能重传</span></span></li><li id="https://www.notion.so/758350a2457d465eb5dd8158e094fb8e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">重传所有包：如果没有发生丢失，会发送大量的重复数据，导致资源浪费</span></span></li></ul><div id="https://www.notion.so/887105e9b0504e03989eedc007c3cead" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">我们可以看出来这里问题的关键点在于，发送方不知道哪些包发生了丢失，因此无法很好的选择重传的范围。因此设计了SACK选项，让接收方告诉发送方应该重传哪些包。</span></span></p></div><h2 id="https://www.notion.so/5b1376bc7736499c993b1139fe820dd7" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/5b1376bc7736499c993b1139fe820dd7"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">SACK方法</span></span></h2><div id="https://www.notion.so/c7357e9a0346405daf56c2121df23b13" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">SACK是TCP的一个选项，也就是头部字段里面的一个值，用来告知发送方真正接受的包。要使用SACK，两个设备都必须同时支持SACK。</span></span></p></div><div id="https://www.notion.so/508d225eee2448e3921c4fafd24a431c" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff51888a6-b04f-4331-803d-03b4a083a106%2FUntitled.png?width=1413&amp;table=block&amp;id=508d225e-ee24-48e3-921c-4fafd24a431c"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff51888a6-b04f-4331-803d-03b4a083a106%2FUntitled.png?width=1413&amp;table=block&amp;id=508d225e-ee24-48e3-921c-4fafd24a431c" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/826d6d7708e946b78a723202ebc0c142" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">上面这张图，在200~299的时候发送了丢失，接收方重传了3次ACK 200，此时接收方知道了200数据包发送丢失。而SACK返回了 300~500，这表示接收方已经接受了300~500的数据包。那么发送方此时根据ACK和SACK的值，重传200～299的数据包即可</span></span></p></div><h2 id="https://www.notion.so/e624528509fb42628f89e427a959c074" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/e624528509fb42628f89e427a959c074"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">DSACK方法</span></span></h2><div id="https://www.notion.so/87fcd2c414254d489b68884677047dcf" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">D-SACK即Duplicate SACK，它可以告知发送方哪些数据被重复接受了。</span></span></p></div><div id="https://www.notion.so/e35c687cd431499c8b4168a16b2a6c44" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">下面用两个例子来说明D-SACK的作用</span></span></p></div><div id="https://www.notion.so/704b3fcb2c764e5c90b369986c0edfdd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">例子1 ACK丢包</strong></span></span></p></div><div id="https://www.notion.so/edee62f9477545eab47ff47cd2dfc45d" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa0cd0960-f406-431a-8285-bd2bb4a2aa9c%2FUntitled.png?width=887&amp;table=block&amp;id=edee62f9-4775-45ea-b47f-f47cd2dfc45d"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa0cd0960-f406-431a-8285-bd2bb4a2aa9c%2FUntitled.png?width=887&amp;table=block&amp;id=edee62f9-4775-45ea-b47f-f47cd2dfc45d" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/1624592f23e940819715e66e76d1304a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果ACK号&gt;SACK号，那么就表示这是一个D-SACK包。上面是ACK丢失的情况，此时出发超时重传，重发3000~3499的数据包，后续收到了ACK=4000，表示此时4000之前的数据都被收到了，同时SACK=3000~3500，那么表示3000~3500的数据包被重复接受了，发送方就会得知：</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">是ACK丢失了</strong></span></span></p></div><div id="https://www.notion.so/a652b678f7804f8bb2facc590acbe4f8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">例子2 网络延时</strong></span></span></p></div><div id="https://www.notion.so/e52a2505379e471aa9c2cfb9023f32c7" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0dc5ece1-935f-4ba0-b89a-e1427dfae4bf%2FUntitled.png?width=962&amp;table=block&amp;id=e52a2505-379e-471a-a9c2-cfb9023f32c7"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0dc5ece1-935f-4ba0-b89a-e1427dfae4bf%2FUntitled.png?width=962&amp;table=block&amp;id=e52a2505-379e-471a-a9c2-cfb9023f32c7" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/677b56c3ae9049c8ab7bf7575fbdb5f7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这个例子中，ACK没有丢失，同时重发了三次，而1000~1499因为网络延迟没有到达，于是接收方重发了1000~1499。</span></span></p></div><div id="https://www.notion.so/509ef9bbfbbe4b5b91ce81f89398e857" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">后续接收方收到延时的数据后会重发一个ACK=3000，SACK=1000~1500，那么接收方就知道了重传的原因是：</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">网络延时</strong></span></span></p></div><div id="https://www.notion.so/406ae2b55ac545628b6c400956cb8dbf" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">我们可以通过上面两个例子得知D-SACK的好处：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/9055f45620e745bb8c13aa2362052a43" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">可以让发送方知道重传的原因</span></span></li><li id="https://www.notion.so/43abb872d58f4085b2e1a38576b5af5a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">可以知道哪些数据是被重复接收的。</span></span></li></ul><div id="https://www.notion.so/9c5264f3f95043f0824b9c9d88fcc024" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">而D-SACK和SACK的判断依据在于：</span></span></p></div><div id="https://www.notion.so/5e27c4d93d5449ac83bfc13bd7ec04f1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果ACK&gt;SACK，那么SACK就是一个D-SACK包，其中的数据是重复接收的</span></span></p></div><div id="https://www.notion.so/f9e3f45f8f464940876e801956ed11f4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果ACK&lt;SACK，那么SACK就是表示已经接收的数据。</span></span></p></div><h1 id="https://www.notion.so/ba5cdc2322364d2faa38c0f36913cba0" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/ba5cdc2322364d2faa38c0f36913cba0"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">滑动窗口</span></span></h1><div id="https://www.notion.so/e58e355b7055420e8b09c997f6f0d949" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8a2ddda7-46de-41a3-8de4-46a221ef174b%2FUntitled.png?width=1288&amp;table=block&amp;id=e58e355b-7055-420e-8b09-c997f6f0d949"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8a2ddda7-46de-41a3-8de4-46a221ef174b%2FUntitled.png?width=1288&amp;table=block&amp;id=e58e355b-7055-420e-8b09-c997f6f0d949" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/05b5b56ec9ab4386af511b4cfb90ff27" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">提高通信效率</strong></span></span></p></div><div id="https://www.notion.so/c2587f36804942a4b9809c91958e9716" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">上面介绍的通信模式都是发送方发送一个包，接收方返回一个ACK。放到现实生活中就是A说一句话，B要等A说完再说话，就这样轮流交替。这种通信模式效率太低下了</span></span></p></div><div id="https://www.notion.so/2a332848ec5a46c5931a6f44b85808f5" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fcb054a56-3bde-4d3a-a0d6-10224a11acb3%2FUntitled.png?width=480&amp;table=block&amp;id=2a332848-ec5a-46c5-931a-6f44b85808f5"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fcb054a56-3bde-4d3a-a0d6-10224a11acb3%2FUntitled.png?width=480&amp;table=block&amp;id=2a332848-ec5a-46c5-931a-6f44b85808f5" style="width:480px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/f908af2b0c6e4129b046a6bcca4ced29" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">为了解决这个问题，TCP引入了</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">窗口</strong></span><span class="SemanticString">的概念，窗口可以支持批量发送数据，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">窗口大小</strong></span><span class="SemanticString">指的就是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">可以继续发送数据的最大值</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/abe248e4ac6840deb1e053418f160c0d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">窗口的底层实际上是操作系统为网络通信开辟的一个缓存空间，发送主机在等到ACK之前，必须在缓冲区中保存发送过的数据，如果收到了ACK，那么就可以清除这些旧数据。</span></span></p></div><div id="https://www.notion.so/31e6bef99d784278b769ca2cc94b5941" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">假设窗口大小为3，那么发送方可以连续发送3个包，如果中途有ACK丢失，可以根据最新的ACK来选择重发的数据。</span></span></p></div><div id="https://www.notion.so/c26a6df94c5f46b5abb5e926e9ca2141" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2a8c03a8-645e-4265-a9f3-b0c95b9f88f4%2FUntitled.png?width=857&amp;table=block&amp;id=c26a6df9-4c5f-46b5-abb5-e926e9ca2141"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2a8c03a8-645e-4265-a9f3-b0c95b9f88f4%2FUntitled.png?width=857&amp;table=block&amp;id=c26a6df9-4c5f-46b5-abb5-e926e9ca2141" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/6b256e402b3f43ef96a05bcb09e2081a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">比如说上图中，ACK 600丢失了，但是最新返回的是ACK 700，这表示700之前的数据都被接收了，600不需要重发就可以继续进行发送。</span></span></p></div><blockquote id="https://www.notion.so/300c73ae9338456e9e4b9658ffb7210f" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">在HTTP1.1中，开启管道后也是类似的通信方式，每次都可以发送一批数据</span></span><div id="https://www.notion.so/b180ff9919714a7aaa1a09a745cc7c9f" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdea6a647-7d9b-4132-8800-a86a0248433a%2FUntitled.png?width=1852&amp;table=block&amp;id=b180ff99-1971-4a7a-aa1a-09a745cc7c9f"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdea6a647-7d9b-4132-8800-a86a0248433a%2FUntitled.png?width=1852&amp;table=block&amp;id=b180ff99-1971-4a7a-aa1a-09a745cc7c9f" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div></blockquote><div id="https://www.notion.so/6d27d7f003994f22b29f2af18b8b9b39" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">窗口大小由哪一方决定？</strong></span></span></p></div><div id="https://www.notion.so/152b24b831c84ac49ec1f8ab8d036366" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">发送速度和消费速度可能会不一致，我们应该考虑消费速度，避免接收方处理不过来。</span></span></p></div><div id="https://www.notion.so/64f83257f1c24ba581b1317b0af61640" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">TCP头里面有一个字段叫做</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Window</code></span><span class="SemanticString"> ，也就是窗口大小，一般是以接收方的窗口大小决定的。</span></span></p></div><div id="https://www.notion.so/d76119fc9a3d47f8a1bc42665c194662" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">发送方的滑动窗口</strong></span></span></p></div><div id="https://www.notion.so/771c970bfec74309a04f68151df600cb" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F49889321-d15b-4891-9111-b13423648fa1%2FUntitled.png?width=1428&amp;table=block&amp;id=771c970b-fec7-4309-a04f-68151df600cb"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F49889321-d15b-4891-9111-b13423648fa1%2FUntitled.png?width=1428&amp;table=block&amp;id=771c970b-fec7-4309-a04f-68151df600cb" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/a273fb6bffe04914bcba47f82a3d1be5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">发送方的滑动窗口可以分为四个部分：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/7b70967a06d248f38dc9566f401abb30" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">已经发送且收到ACK的数据</span></span></li><li id="https://www.notion.so/c1ef246c7df3485e9b24f25d23e94859" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">发送窗口</strong></span><span class="SemanticString">：已经发送但未收到ACK的数据</span></span></li><li id="https://www.notion.so/89b275517653435f89906bb2101d39c8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">可用窗口</strong></span><span class="SemanticString">：未发送但是可以发送的数据</span></span></li><li id="https://www.notion.so/0824193bf0614f1286f8050c2dfa5246" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">未发送且超过接收方处理范围的数据</span></span></li></ul><div id="https://www.notion.so/c61407d1023c41b38a58b841abe45020" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当发送方全部发送数据后，可用窗口就为0，发送窗口就是整个窗口大小了</span></span></p></div><div id="https://www.notion.so/825fe28927b1445a917d7b7c57f117f1" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F02d3f17a-ff2a-470d-b0a9-4c9474727b9b%2FUntitled.png?width=1428&amp;table=block&amp;id=825fe289-27b1-445a-917d-7b7c57f117f1"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F02d3f17a-ff2a-470d-b0a9-4c9474727b9b%2FUntitled.png?width=1428&amp;table=block&amp;id=825fe289-27b1-445a-917d-7b7c57f117f1" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/11612ab0cf714db4b7fde149764ad657" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/c1444ced4ea84f31a3ca7171a905c93f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果此时收到37的ACK，那么就可以往后移动窗口了</span></span></p></div><div id="https://www.notion.so/c6bfefd8bb31442ca0a21b208fb60e3b" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F796a38c6-32ac-4ad5-a8dc-f82f7a1b464e%2FUntitled.png?width=1608&amp;table=block&amp;id=c6bfefd8-bb31-442c-a0a2-1b208fb60e3b"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F796a38c6-32ac-4ad5-a8dc-f82f7a1b464e%2FUntitled.png?width=1608&amp;table=block&amp;id=c6bfefd8-bb31-442c-a0a2-1b208fb60e3b" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/1637ba2570684016b942ddc4cc3b4c3e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">注意发送方的滑动窗口移动依据是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">ACK号</strong></span></span></p></div><div id="https://www.notion.so/5f936635a07e48199dd17218aa56d05f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">发送方的窗口表达</strong></span></span></p></div><div id="https://www.notion.so/4f21a231093a4c6e8db037134d40c826" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F15236f2b-27b6-447c-9e41-80dc8e796608%2FUntitled.png?width=1428&amp;table=block&amp;id=4f21a231-093a-4c6e-8db0-37134d40c826"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F15236f2b-27b6-447c-9e41-80dc8e796608%2FUntitled.png?width=1428&amp;table=block&amp;id=4f21a231-093a-4c6e-8db0-37134d40c826" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/59abeb32de1a4eda948eed526d731b56" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/acd881e1400d489987860ab0794aa6a1" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">SND.WND</code></span><span class="SemanticString">：表示发送窗口的大小（大小是由接收方指定的）；</span></span></li><li id="https://www.notion.so/203b53ca0cd24d8c86811bd8a483d55b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">SND.UNA</code></span><span class="SemanticString">（</span><span class="SemanticString"><em class="SemanticString__Fragment SemanticString__Fragment--Italic">Send Unacknoleged</em></span><span class="SemanticString">）：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</span></span></li><li id="https://www.notion.so/c604141850b2417e952558118aa0a1e4" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">SND.NXT</code></span><span class="SemanticString">：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</span></span></li><li id="https://www.notion.so/a7822b7e74a34821a04cfffe532f865e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">指向 #4 的第一个字节是个相对指针，它需要 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">SND.UNA</code></span><span class="SemanticString"> 指针加上 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">SND.WND</code></span><span class="SemanticString"> 大小的偏移量，就可以指向 #4 的第一个字节了。</span></span></li></ul><div id="https://www.notion.so/894639afe2b94d7fad4e92ba054b8e3c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">那么可用窗口大小的计算就可以是：</span></span></p></div><div id="https://www.notion.so/9639334bc8fd46a1954cd483e501be3d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedBg SemanticString__Fragment--BgRed">可用窗口大小 = SND.WND -（SND.NXT - SND.UNA）</mark></span></span></p></div><div id="https://www.notion.so/f1b31a35cf1c41a8bf56f914021b96d8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">接收方的滑动窗口</strong></span></span></p></div><div id="https://www.notion.so/8a583b02f9264f7282926f7fc070cd76" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc7c27898-a57b-461a-a034-4b7eee1f96d4%2FUntitled.png?width=1429&amp;table=block&amp;id=8a583b02-f926-4f72-8292-6f7fc070cd76"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc7c27898-a57b-461a-a034-4b7eee1f96d4%2FUntitled.png?width=1429&amp;table=block&amp;id=8a583b02-f926-4f72-8292-6f7fc070cd76" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/1de3979c09b845b781ae7f3ea5db07c8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">RCV.WND</code></span><span class="SemanticString">：表示接收窗口的大小，它会通告给发送方。</span></span></li><li id="https://www.notion.so/5dc650036ff54e32a4c6d8784482f989" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">RCV.NXT</code></span><span class="SemanticString">：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</span></span></li><li id="https://www.notion.so/0e5da3328a44495d9de898fcb14c4315" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">指向 #4 的第一个字节是个相对指针，它需要 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">RCV.NXT</code></span><span class="SemanticString"> 指针加上 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">RCV.WND</code></span><span class="SemanticString"> 大小的偏移量，就可以指向 #4 的第一个字节了。</span></span></li></ul><h1 id="https://www.notion.so/dd8ee87e27864649ba3df2345bcdff48" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/dd8ee87e27864649ba3df2345bcdff48"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">流量控制</span></span></h1><div id="https://www.notion.so/00a2c1e500164b44893fdc76f608c884" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F977f3a00-5d9c-41fc-8b54-5b3f31947801%2FUntitled.png?width=1414&amp;table=block&amp;id=00a2c1e5-0016-4b44-893f-dc76f608c884"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F977f3a00-5d9c-41fc-8b54-5b3f31947801%2FUntitled.png?width=1414&amp;table=block&amp;id=00a2c1e5-0016-4b44-893f-dc76f608c884" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/9bfe2f1910db4a5a8646b1fc13966d29" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">流量控制指的是端对端通信时，协调发送方的发送速度和接收方的处理速度，避免接收方处理不过来。TCP使用流量控制让发送方根据接收方的实际接受能力控制发送数据量。</span></span></p></div><div id="https://www.notion.so/46100534973e4faaab42d530e71f320b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">假设接收方的可用窗口大小是400，那么这个值会在建立连接的时候告诉发送方，同时在通信过程中不断告知当前接收方的可用窗口大小</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">rwnd</code></span><span class="SemanticString">，发送方会根据这个大小发送数据。</span></span></p></div><div id="https://www.notion.so/0cecd6aec3fb4d28bad23c1e301769dd" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbd03514d-1645-4f82-8da7-15926664367b%2FUntitled.png?width=1333&amp;table=block&amp;id=0cecd6ae-c3fb-4d28-bad2-3c1e301769dd"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbd03514d-1645-4f82-8da7-15926664367b%2FUntitled.png?width=1333&amp;table=block&amp;id=0cecd6ae-c3fb-4d28-bad2-3c1e301769dd" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/f90bdf25385c4c4e8f1c62d05d54ecfe" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">简述一下就是返回的信息里面带有接收方的可用窗口大小，让发送方避免发出处理范围之外的数据。</span></span></p></div><div id="https://www.notion.so/18a6f970475e472c9503c4262028625c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">另外这里有一个额外的知识点，那就是滑动窗口的大小依赖于缓冲区大小，如果操作系统调小了缓冲区大小，那么就会引起滑动窗口的收缩。而这个事件的发生顺序是要</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">先收缩滑动窗口，再调小缓冲区</strong></span></span></p></div><div id="https://www.notion.so/fcea4fdb72bf4ccab195be186c5872a4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">否则的话可能还没来得及读取滑动窗口内的数据，就已经被限制读取范围了，导致部分数据永远读取不到了。</span></span></p></div><div id="https://www.notion.so/5d69c7d724384cd186c0bc918d72b48b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">窗口关闭</strong></span></span></p></div><div id="https://www.notion.so/b4dce15bc1ef47a4917cf9d5535583e1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">窗口关闭指的是接收方告知发送方可用窗口大小为0，此时发送方只有等待接收方告诉他可用窗口增加后才能发送数据。那么这里可能就有一个问题：非0窗口通知丢失。</span></span></p></div><div id="https://www.notion.so/6478a1a31c7645b5867ae53d8044ac57" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F662e7b61-6210-441f-a796-3c4b7742f3ae%2FUntitled.png?width=1104&amp;table=block&amp;id=6478a1a3-1c76-45b5-867a-e53d8044ac57"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F662e7b61-6210-441f-a796-3c4b7742f3ae%2FUntitled.png?width=1104&amp;table=block&amp;id=6478a1a3-1c76-45b5-867a-e53d8044ac57" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/7b9684e5216b4b2daad2ccc9907ab035" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果非0窗口丢失了，那么就会出现循环等待的现象。</span></span></p></div><div id="https://www.notion.so/98b32de731104e09bbf5b7355e80ca87" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">解决这个问题其实很简单，发送方收到0窗口通知后，就会开启一个计时器，一段时间后会发送一个</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">探测报文</strong></span><span class="SemanticString">，要求对方给出当前的可用窗口大小，那么这样就能避免死锁的现象了。</span></span></p></div><div id="https://www.notion.so/4c5713109c9c4f4ca6d64219c8ea38da" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">糊涂窗口综合症</strong></span></span></p></div><div id="https://www.notion.so/46c12e9dd815444aa96aa57e81dcf767" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">就是接收方处理不过来，导致每次可用窗口大小都是几个字节，而发送方收到大小后就发送几个字节数据，这样的开销其实是很大的。</span></span></p></div><div id="https://www.notion.so/931eb7b0084944e28e51071df42bcd56" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这个问题现象产生于：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/46b4293bf1a24321aad2efab9742ef65" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">接收方告诉小窗口给发送方</span></span></li><li id="https://www.notion.so/d817bef95f1b41b18d1803e149e3a960" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">发送方可以发送小数据</span></span></li></ul><div id="https://www.notion.so/7ab9c0287bc349eaa3e53451bd3cf05f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">解决这个问题只需要把这两个现象处理掉就好了</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/04232b53da79402ab46723c858c5ac87" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">接收方不告知小窗口</span></span></li><li id="https://www.notion.so/0acf8556df964f37b84c6e147ee5ef50" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">发送方等待一批数据后再发送</span></span></li></ul><blockquote id="https://www.notion.so/a27949b258d543ffa89c4082235ad947" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">怎么让接收方不通告小窗口呢？</span></span></blockquote><div id="https://www.notion.so/c7d552fb6c644db09ff3cfe358ed8974" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">接收方通常的策略如下:</span></span></p></div><div id="https://www.notion.so/3603f61e6db6471fa46874914d0a6b8c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">0</code></span><span class="SemanticString">，也就阻止了发送方再发数据过来。</span></span></p></div><div id="https://www.notion.so/67785ec0bcb04f81acb63e96382b4bd0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">等到接收方处理了一些数据后，窗口大小 &gt;= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</span></span></p></div><blockquote id="https://www.notion.so/23e234a76b0e4f9494c0d78c3dcc05d3" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">怎么让发送方避免发送小数据呢？</span></span></blockquote><div id="https://www.notion.so/44819f5e585b449ba9f0ae753236f4c4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">发送方通常的策略如下:</span></span></p></div><div id="https://www.notion.so/8c04500f496b4c69be74603486a3ae7d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才可以发送数据：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/8b6823967c36470cb5c5c3c101593393" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">条件一：要等到窗口大小 &gt;= </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">MSS</code></span><span class="SemanticString"> 并且 数据大小 &gt;= </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">MSS</code></span><span class="SemanticString">；</span></span></li><li id="https://www.notion.so/82ded1d1a8ef48cabe40f3b6dafa3638" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">条件二：收到之前发送数据的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ack</code></span><span class="SemanticString"> 回包；</span></span></li></ul><div id="https://www.notion.so/3e08307adebf4aa89f34861327addb2e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">只要上面两个条件都不满足，发送方一直在囤积数据，直到满足上面的发送条件。</span></span></p></div><div id="https://www.notion.so/f10eed7921164bb0a49164aab0834c6d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Nagle 伪代码如下：</span></span></p></div><pre id="https://www.notion.so/42b72372838e439b86df09c89106dd62" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>if 有数据要发送 {
    if 可用窗口大小 &gt;= MSS and 可发送的数据 &gt;= MSS {
    	立刻发送MSS大小的数据
    } else {
        if 有未确认的数据 {
            将数据放入缓存等待接收ACK
        } else {
            立刻发送数据
        }
    }
}</span></span></span></code></pre><div id="https://www.notion.so/137a390677fe483e9cf52938af32207f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">注意，如果接收方不能满足「不通告小窗口给发送方」，那么即使开了 Nagle 算法，也无法避免糊涂窗口综合症，因为如果对端 ACK 回复很快的话（达到 Nagle 算法的条件二），Nagle 算法就不会拼接太多的数据包，这种情况下依然会有小数据包的传输，网络总体的利用率依然很低。</span></span></p></div><div id="https://www.notion.so/822cc90fbcfe43eeb9dfef30a020ccaa" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">所以，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">接收方得满足「不通告小窗口给发送方」+ 发送方开启 Nagle 算法，才能避免糊涂窗口综合症</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/c2861af1b2274045b2103601a24a50fb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">另外，Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。</span></span></p></div><div id="https://www.notion.so/16317b4ee65c4887abb77428453f2318" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">可以在 Socket 设置 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">TCP_NODELAY</code></span><span class="SemanticString"> 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）</span></span></p></div><div id="https://www.notion.so/e2ad920dc5934ace971d5f534729f24b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"></span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&amp;value, sizeof(int));</code></span></span></p></div><h1 id="https://www.notion.so/da454dfa40e84d938fb8641bd5f8aaf8" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/da454dfa40e84d938fb8641bd5f8aaf8"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">拥塞控制</span></span></h1><div id="https://www.notion.so/c13bf9f56c4c4bb49099e068f3aca821" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/1ad953468cc9451d83459987077fbf6c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</span></span></p></div><div id="https://www.notion.so/ce3409bf9f1b4042b57c089924c8f2b1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。</span></span></p></div><div id="https://www.notion.so/192d0f18f68446cc8e676fb074958fe4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....</strong></span></span></p></div><div id="https://www.notion.so/8e7c872fac4d4f92bbc657ca777209b3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</span></span></p></div><div id="https://www.notion.so/237c96cb5e9344b6a93ca10399fc89c0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">于是，就有了</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">拥塞控制</strong></span><span class="SemanticString">，控制的目的就是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">避免「发送方」的数据填满整个网络。</strong></span></span></p></div><div id="https://www.notion.so/24bdefdf0c6c4c98bfaeb2e1b8fce229" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">为了在「发送方」调节所要发送数据的量，定义了一个叫做「</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">拥塞窗口</strong></span><span class="SemanticString">」的概念。</span></span></p></div><h2 id="https://www.notion.so/f32971daa0694402936f9e8f987ad286" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/f32971daa0694402936f9e8f987ad286"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">什么是拥塞窗口</span></span></h2><div id="https://www.notion.so/710abd0abc694bf1be8b5715ce706066" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">TCP中一共有三种窗口：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/2cc0eabadb104fce85b32a27ba69b668" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">rwnd：接收窗口</span></span></li><li id="https://www.notion.so/d08a436b01fe40e6a1243a0a1e4a0d52" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">swnd：发送窗口</span></span></li><li id="https://www.notion.so/02eb3005eb564d43971f94a95ee2c4d0" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">cwnd：拥塞窗口</span></span></li></ul><div id="https://www.notion.so/91cdec45986a45018120637fee3d1f76" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">拥塞窗口 cwnd</strong></span><span class="SemanticString">是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">发送方</strong></span><span class="SemanticString">维护的一个的状态变量，它会根据</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">网络的拥塞程度动态变化的</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/7bfd18986add4c338ea2d5bceb821dad" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">我们在前面提到过发送窗口 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">swnd</code></span><span class="SemanticString"> 和接收窗口 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">rwnd</code></span><span class="SemanticString"> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</span></span></p></div><div id="https://www.notion.so/a92033389032495ba6097f198429224c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">拥塞窗口 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">cwnd</code></span><span class="SemanticString"> 变化的规则：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/762c1990ba8e4d3ca409446180af701a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">只要网络中没有出现拥塞，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">cwnd</code></span><span class="SemanticString"> 就会增大；</span></span></li><li id="https://www.notion.so/9dc7b93b491b4c1084cac484d542642c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">但网络中出现了拥塞，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">cwnd</code></span><span class="SemanticString"> 就减少；</span></span></li></ul><div id="https://www.notion.so/02c4cd57bf98442ca5bc89318f45633d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedBg SemanticString__Fragment--BgYellow">那么怎么知道当前网络是否出现了拥塞呢？</mark></span></span></p></div><div id="https://www.notion.so/7fbdf4d6df164f73bfa3419b34124534" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">发生了超时重传，就会认为网络出现了拥塞。</strong></span></span></p></div><div id="https://www.notion.so/539264ee28ee47a4a215b146fe839534" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedBg SemanticString__Fragment--BgYellow">拥塞控制有哪些控制算法？</mark></span></span></p></div><div id="https://www.notion.so/7c550922c38e4fcbbe9b7db8da68b1c0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">拥塞控制主要是四个算法：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/6e534ea35c1440bc80b977ff6100158a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">慢启动</span></span></li><li id="https://www.notion.so/c0d72d5733d943ff9cecefd303100642" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">拥塞避免</span></span></li><li id="https://www.notion.so/2e490a20b345465abe655431154bc838" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">拥塞发生</span></span></li><li id="https://www.notion.so/300a3995ccab4112a6ecea45a9b690bc" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">快速恢复</span></span></li></ul><h2 id="https://www.notion.so/1f15c75706b24e458bbf01d5be5af417" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/1f15c75706b24e458bbf01d5be5af417"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">慢启动</span></span></h2><div id="https://www.notion.so/fb7d561c8f474757b9e2390a6e60142d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">慢启动的核心思想是控制一开始发送方的发送速度，不要一上来速度就拉满。</span></span></p></div><div id="https://www.notion.so/b5e0d8730fd34b729a5a47b4aedeb320" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">规则：当发送方每接受一个ACK，拥塞窗口cwnd的大小就会加1</span></span></p></div><div id="https://www.notion.so/6f339f3ce105474e8161f07c8315d5c5" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1f8bbd60-210b-4891-894f-10775abb247f%2FUntitled.png?width=1016&amp;table=block&amp;id=6f339f3c-e105-474e-8161-f07c8315d5c5"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1f8bbd60-210b-4891-894f-10775abb247f%2FUntitled.png?width=1016&amp;table=block&amp;id=6f339f3c-e105-474e-8161-f07c8315d5c5" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/1e60ced8c7064d87ab88aff9b135e156" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">每个ACK都使得cwnd大小加1，而cwnd变大的同时还能发送多个数据包，因此它的增长速度就是指数性的增长。</span></span></p></div><div id="https://www.notion.so/10979eb3f4bf4fe2aef87845c9286f0e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">但是cwnd并不是无限增长的，有一个叫做慢启动门限 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ssthresh (slow start threshold</code></span><span class="SemanticString">) 状态变量</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/48e6d1014c184d70abc57e54ab6990bf" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">当cwnd &lt; ssthresh，使用慢启动算法</span></span></li><li id="https://www.notion.so/02b4a913b2b54e5586d93f22d05895e0" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">当cwnd ≥ ssthresh，使用拥塞避免算法</span></span></li></ul><h2 id="https://www.notion.so/2c573c5eec3c45d5850967f5394b5991" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/2c573c5eec3c45d5850967f5394b5991"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">拥塞避免</span></span></h2><div id="https://www.notion.so/07ec2ea5c1034eddb2c2f994901f3792" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F863a108b-cb4c-46a0-b046-81ca6a23aea8%2FUntitled.png?width=1616&amp;table=block&amp;id=07ec2ea5-c103-4edd-b2c2-f994901f3792"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F863a108b-cb4c-46a0-b046-81ca6a23aea8%2FUntitled.png?width=1616&amp;table=block&amp;id=07ec2ea5-c103-4edd-b2c2-f994901f3792" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/e5ea8c5c22824ba8a2baa29b85073f20" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">前面说道，当拥塞窗口 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">cwnd</code></span><span class="SemanticString"> 「超过」慢启动门限 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ssthresh</code></span><span class="SemanticString"> 就会进入拥塞避免算法。</span></span></p></div><div id="https://www.notion.so/5e4f1baf0d1548148157b6c50375ff19" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一般来说 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ssthresh</code></span><span class="SemanticString"> 的大小是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">65535</code></span><span class="SemanticString"> 字节。</span></span></p></div><div id="https://www.notion.so/f7b7609fb6274f50aed94b190d50132d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">那么进入拥塞避免算法后，它的规则是：</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong></span></span></p></div><div id="https://www.notion.so/ad06b4b832af4564b367e94ddee6375b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">接上前面的慢启动的栗子，现假定 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ssthresh</code></span><span class="SemanticString"> 为 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">8</code></span><span class="SemanticString">：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/f111cc3f200a4095acc8d8a93435358c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">MSS</code></span><span class="SemanticString"> 大小的数据，变成了</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">线性增长。</strong></span></span></li></ul><div id="https://www.notion.so/ecde948f989b48ad89ab487474f40f41" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">拥塞避免算法的变化过程如下图：</span></span></p></div><div id="https://www.notion.so/a60dac5973bd4a38b58ab4701a876ef0" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb45ef61b-54f7-4324-9c7f-7f20cad46c6b%2FUntitled.png?width=872&amp;table=block&amp;id=a60dac59-73bd-4a38-b58a-b4701a876ef0"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb45ef61b-54f7-4324-9c7f-7f20cad46c6b%2FUntitled.png?width=872&amp;table=block&amp;id=a60dac59-73bd-4a38-b58a-b4701a876ef0" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/9c4a84cfec8c4ab2a7deb44b6468e06d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">也就是说一旦cwnd越过了阈值，那么就会变成线性增长</span></span></p></div><div id="https://www.notion.so/36f4de6ea9c84af9b493755577efa8c4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</span></span></p></div><div id="https://www.notion.so/04ff9097ec8c4d2c89131306ac4e9cba" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</span></span></p></div><div id="https://www.notion.so/0861e8614c024e79a941424bae2f88fb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当触发了重传机制，也就进入了「</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">拥塞发生算法</strong></span><span class="SemanticString">」。</span></span></p></div><h2 id="https://www.notion.so/dcca9c5dab2048e7a6c2c7faab022fba" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/dcca9c5dab2048e7a6c2c7faab022fba"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">拥塞发生算法</span></span></h2><div id="https://www.notion.so/17dda99cbed94db284a09071d237d806" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">我们之前介绍了两种重传机制，分别是：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/d461f15634ef4ddd8e6ef257e1c38dd8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">超时重传</span></span></li><li id="https://www.notion.so/90a9281175264a158009cec994025a92" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">快速重传</span></span></li></ul><div id="https://www.notion.so/ca415042481a432abe302e53b08e1e53" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">根据重传机制不同，拥塞发生算法也会不同。</span></span></p></div><div id="https://www.notion.so/b966a2801535430cb8249dafbb6eea6a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">发生超时重传的拥塞算法</strong></span></span></p></div><div id="https://www.notion.so/1f3b1c238db84a168b3ddf3dd97bbcf3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当发生了「超时重传」，则就会使用拥塞发生算法。</span></span></p></div><div id="https://www.notion.so/c5a644d11b764bdcb79ab2a8d6ad6e14" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这个时候，ssthresh 和 cwnd 的值会发生变化：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/ea05addb4cf643b09d363e19e54bef2a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ssthresh</code></span><span class="SemanticString"> 设为 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">cwnd/2</code></span><span class="SemanticString">，</span></span></li><li id="https://www.notion.so/7940069433854c23ae275c71df403c18" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">cwnd</code></span><span class="SemanticString"> 重置为 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">1</code></span><span class="SemanticString"> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</span></span></li></ul><div id="https://www.notion.so/7c349698a54b40e7a27c136f5a6166b5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedBg SemanticString__Fragment--BgYellow">怎么查看系统的cwnd初始值？</mark></span></span></p></div><div id="https://www.notion.so/35fd2b93d7cd4e55acf4e3c4e4213a62" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Linux 针对每一个 TCP 连接的 cwnd 初始化值是 10，也就是 10 个 MSS，我们可以用 ss -nli 命令查看每一个 TCP 连接的 cwnd 初始化值，如下图</span></span></p></div><div id="https://www.notion.so/df0f4b0b36bd4e3eb9b6274ecc434782" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe04caa44-63ab-4981-9f02-cbbe366b0f8f%2FUntitled.png?width=2130&amp;table=block&amp;id=df0f4b0b-36bd-4e3e-b9b6-274ecc434782"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe04caa44-63ab-4981-9f02-cbbe366b0f8f%2FUntitled.png?width=2130&amp;table=block&amp;id=df0f4b0b-36bd-4e3e-b9b6-274ecc434782" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/a97a77a44b4644d8bcc1fc268baa26fd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">拥塞发生算法的变化如下图：</span></span></p></div><div id="https://www.notion.so/8bbeff72d6964ab1b5b843dbdea09878" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbd4240a0-bc30-461e-ad3d-8b7cba2951ec%2FUntitled.png?width=1142&amp;table=block&amp;id=8bbeff72-d696-4ab1-b5b8-43dbdea09878"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbd4240a0-bc30-461e-ad3d-8b7cba2951ec%2FUntitled.png?width=1142&amp;table=block&amp;id=8bbeff72-d696-4ab1-b5b8-43dbdea09878" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/8b00ed19d66a495eac6a1f52a5a59c42" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。</span></span></p></div><div id="https://www.notion.so/06c19242ba67448a8869f09f66fc292b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</span></span></p></div><div id="https://www.notion.so/edf25c18893848fe8ae5afeb72234c21" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">发生快速重传的拥塞发生算法</strong></span></span></p></div><div id="https://www.notion.so/c66129ee171a41278b3c2f831ce24efa" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</span></span></p></div><div id="https://www.notion.so/7a498310b41347c6b575dcbf79bf436f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ssthresh</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">cwnd</code></span><span class="SemanticString"> 变化如下：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/8a753fa45aaa41a9917dc92a7507543a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">cwnd = cwnd/2</code></span><span class="SemanticString"> ，也就是设置为原来的一半;</span></span></li><li id="https://www.notion.so/e79ffb36e986482daca8a3c7b7fe51e5" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ssthresh = cwnd</code></span><span class="SemanticString">;</span></span></li><li id="https://www.notion.so/2f343fd5476645bd96ecb27c062e9d30" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">进入快速恢复算法</strong></span></span></li></ul><h2 id="https://www.notion.so/44c84247d9ad460b80b5e4166148a574" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/44c84247d9ad460b80b5e4166148a574"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">快速恢复</span></span></h2><div id="https://www.notion.so/6a9f07cf69774767a2559c25e8eea466" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">RTO</code></span><span class="SemanticString"> 超时那么强烈。</span></span></p></div><div id="https://www.notion.so/c8249233bf9c4125b34a4cef31f62007" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">正如前面所说，进入快速恢复之前，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">cwnd</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ssthresh</code></span><span class="SemanticString"> 已被更新了：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/bda2bb0c42ec40cd87989f5aeeb3da3c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">cwnd = cwnd/2</code></span><span class="SemanticString"> ，也就是设置为原来的一半;</span></span></li><li id="https://www.notion.so/27f71723e1b04e36aff6c911af328ffe" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ssthresh = cwnd</code></span><span class="SemanticString">;</span></span></li></ul><div id="https://www.notion.so/842daa7f717f498da64b9303ea2c2285" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">然后，进入快速恢复算法如下：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/88963d1571b1470d8f4a5ac34b7aadd5" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">拥塞窗口 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">cwnd = ssthresh + 3</code></span><span class="SemanticString"> （ 3 的意思是确认有 3 个数据包被收到了）；</span></span></li><li id="https://www.notion.so/a3e938200d9d4f76abfd22f371f9730e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">重传丢失的数据包；</span></span></li><li id="https://www.notion.so/ed4091a7e62f4ad7bc7e4e1495788575" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果再收到重复的 ACK，那么 cwnd 增加 1；</span></span></li><li id="https://www.notion.so/2c6df8bb771d4e43b30b26d957ed9234" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</span></span></li></ul><div id="https://www.notion.so/08d25f0cbbce42dea47cded09ffb78ac" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。</span></span></p></div><div id="https://www.notion.so/cb811aa160c74225a8f61062a8bb7a6d" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdf302fba-21b0-41ee-b0a0-542a3da54b70%2FUntitled.png?width=1352&amp;table=block&amp;id=cb811aa1-60c7-4225-a8f6-1062a8bb7a6d"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdf302fba-21b0-41ee-b0a0-542a3da54b70%2FUntitled.png?width=1352&amp;table=block&amp;id=cb811aa1-60c7-4225-a8f6-1062a8bb7a6d" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/b9359b9c0c9c489a999a37286d6bb514" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">很多人问题，快速恢复算法过程中，为什么收到新的数据后，cwnd 设置回了 ssthresh ？</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/ac9133d779484d19be9052c2b4a15037" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">在快速恢复的过程中，首先 ssthresh = cwnd/2，然后 cwnd = ssthresh + 3，表示网络可能出现了阻塞，所以需要减小 cwnd 以避免，加 3 代表快速重传时已经确认接收到了 3 个重复的数据包；</span></span></li><li id="https://www.notion.so/77e67bcfb5574761bcad4b9c04a4682a" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">随后继续重传丢失的数据包，如果再收到重复的 ACK，那么 cwnd 增加 1。加 1 代表每个收到的重复的 ACK 包，都已经离开了网络。这个过程的目的是尽快将丢失的数据包发给目标。</span></span></li><li id="https://www.notion.so/da3e711e967d4c1080dbb04e691db87c" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，恢复过程结束。</span></span></li></ol><div id="https://www.notion.so/5708dd8ea34e4fa184226d3fd1673e2f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">首先，快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低 cwnd 来减缓拥塞，所以必然会出现 cwnd 从大到小的改变。</strong></span></span></p></div><div id="https://www.notion.so/dc2ae877d04a42eda35f77d55429702c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">其次，过程2（cwnd逐渐加1）的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题（三次相同的 ACK 导致的快速重传），所以这一过程中 cwnd 反而是逐渐增大的。</strong></span></span></p></div><div id="https://www.notion.so/083ae9eb818b40a68d19e0f0045d9086" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedBg SemanticString__Fragment--BgYellow">总结：</mark></span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/9a39cd804b5848a5a7e78c08ed40e9ee" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">首先减半cwnd，然后将阈值设置为减半后的cwnd</span></span></li><li id="https://www.notion.so/f814f85708fe43e69648de52e2e7f9cd" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">进入恢复阶段，此时的目标是将数据包尽可能的重传给对方，cwnd += 3表示之前接收了3个相同的ACK，然后进入线性增长</span></span></li><li id="https://www.notion.so/be17163886374e2bae245fb936e095af" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果收到新的ACK，表示恢复阶段结束，将cwnd设置回阈值，避免拥塞</span></span></li></ul><div id="https://www.notion.so/02d9fc4733c048a4a20f898a6fef8f74" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/201fe195f2e14d1b85f653af9ed940ab" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h1 id="https://www.notion.so/12c5b4586f384e5bb6ac7ec34e2be511" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/12c5b4586f384e5bb6ac7ec34e2be511"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Ref</span></span></h1><div id="https://www.notion.so/7186c254e802496c9717c48ffb7eef4d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://juejin.cn/post/7080339555995369503">【计算机网络】TCP的流量控制和拥塞控制 - 掘金 (juejin.cn)</a></span></span></p></div><div id="https://www.notion.so/7eb49abead8a449db102d43e9fc5b011" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://www.zhihu.com/question/38749788">流量控制与拥塞控制的区别。为什么要把流量控制与拥塞控制分为两个名词？ - 知乎 (zhihu.com)</a></span></span></p></div><div id="https://www.notion.so/662891f1a3bd4f0a9debdb00a2841da0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0">4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding (xiaolincoding.com)</a></span></span></p></div><div id="https://www.notion.so/0dcc9ed0fb324cb1a12a47fbdca3244a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://blog.csdn.net/wdscq1234/article/details/52503315"> TCP-IP详解：SACK选项（Selective Acknowledgment）_CQ小子的博客-CSDN博客</a></span></span></p></div><div id="https://www.notion.so/81949277ac83473399fb329c0bca4cbe" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div></article>
  <footer class="Footer">
  <div>&copy; Notablog 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>